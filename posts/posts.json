[
  {
    "path": "posts/2022-09-10-post-19-go-with-the-flow-alluvial-plots-with-ggplot/",
    "title": "Post #19. Go with the flow - alluvial diagrams in ggplot",
    "description": "Let's make flowy alluvial diagrams in ggplot using the extension package `ggalluvial`!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-09-10",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nIntroduction\r\nAlluvial\r\ndiagrams are a type of chart that shows the relationships between\r\ncategorical variables for a given quantity (number of people, amount of\r\nenergy, etc.) They look like a stacked barplot with flow streams\r\nconnecting the stacks of adjacent bars (that’s why it gets its name!).\r\nThese diagrams are useful for visualizing pathways and trends across\r\nvariables. Another similar chart is bump\r\ncharts, which emphasize the change in rankings of multiple objects\r\nover time.\r\nCreate alluvial\r\ndiagrams with ggalluvial\r\nWe’ll be using the extension package ggalluvial\r\nto create alluvial diagrams in ggplot. The functions in\r\nggalluvial can take data in both wide and long format, and\r\nwe’ll start with the wide format here.\r\nWorking with wide format\r\ndata\r\nFirst, let’s prepare our example data using the diamonds\r\ndataset: We’ll classify the carat of the diamonds into “Large” and\r\n“Small” as well as the price into “Low”, “Mid”, and “High”, and then\r\ntally the numbers of diamonds by carat, cut, and price.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Prepare wide format diamonds data\r\ndiamonds_wide <- diamonds %>% \r\n  mutate(price_cat = case_when(price < quantile(price, 0.33) ~ \"Low\",\r\n                               price > quantile(price, 0.67) ~ \"High\",\r\n                               TRUE ~ \"Mid\"),\r\n         price_cat = factor(price_cat, levels = c(\"High\", \"Mid\", \"Low\")),\r\n         carat_cat = ifelse(carat > median(carat), \"Large\", \"Small\"),\r\n         cut = fct_rev(cut)) %>% \r\n  group_by(carat_cat, cut, price_cat) %>%\r\n  summarise(count = n()) %>% \r\n  ungroup()\r\n\r\nhead(diamonds_wide)\r\n\r\n# A tibble: 6 x 4\r\n  carat_cat cut       price_cat count\r\n  <chr>     <ord>     <fct>     <int>\r\n1 Large     Ideal     High       5808\r\n2 Large     Ideal     Mid        2648\r\n3 Large     Premium   High       5649\r\n4 Large     Premium   Mid        2283\r\n5 Large     Premium   Low           2\r\n6 Large     Very Good High       4135\r\n\r\n\r\nNow having the appropriate data on hand, we can visualize the\r\nrelationships between carat, cut, and price in an alluvial diagram.\r\nThere are a few things worth noting in the below code chunk:\r\nThe flow\r\nstreams and bars are drawn using geom_alluvium() and\r\ngeom_stratum(), respectively\r\nThe bars are\r\npositioned along the horizontal axis using the arguments\r\naes(axis1 = carat_cat, axis2 = cut, axis3 = price_cat)\r\nThe function\r\ngeom_stratum() will create a new internal variable\r\n“stratum” that can be used to label the bars via the\r\nargument aes(label = after_stat(stratum))\r\nThe flow\r\nstreams are colored by price\r\n\r\n\r\n# install.packages(\"ggalluvial\")  # install the package if you haven't\r\nlibrary(ggalluvial)\r\nlibrary(scales)  # for the function \"comma_format()\"\r\n\r\nggplot(diamonds_wide, aes(axis1 = carat_cat, axis2 = cut, axis3 = price_cat, y = count)) +\r\n  geom_alluvium(aes(fill = price_cat), width = 1/5) +\r\n  geom_stratum(width = 1/5, fill = \"#fee6ce\", color = \"grey30\") +\r\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum)), size = 2.5) +\r\n  scale_x_discrete(limits = c(\"Carat\", \"Cut\", \"Price\"), expand = c(0, 0.2)) +\r\n  scale_y_continuous(expand = c(0, 0), labels = comma_format()) + \r\n  labs(y = \"Count\") + \r\n  scale_fill_brewer(name = \"Price\", palette = \"Set1\") + \r\n  theme_classic(base_size = 13) + \r\n  theme(axis.line.x = element_blank(),\r\n        axis.ticks.x = element_blank())\r\n\r\n\r\n\r\nIt seems that no large diamond has a low price and no small diamond\r\nhas a high price, regardless of the cut quality.\r\nFrom this plot, we can further produce the so-called “parallel\r\nsets” by adjusting the width of the bars, the knot position (the\r\ninflection point) of the flow streams, and the orientation of the\r\ndiagram:\r\n\r\n\r\nggplot(diamonds_wide, aes(axis1 = carat_cat, axis2 = cut, axis3 = price_cat, y = count)) +\r\n  geom_alluvium(aes(fill = price_cat), width = 0, knot.pos = 0, show.legend = F) +  # knot.pos = 0 generates straight flow streams\r\n  geom_stratum(width = 0.02, fill = \"black\", color = \"white\") +  # reduce the bar width to create thick lines\r\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum)), size = 2.5, nudge_x = 0.05) +\r\n  scale_x_discrete(limits = c(\"Carat\", \"Cut\", \"Price\"), expand = c(0, 0.1)) +\r\n  scale_y_continuous(expand = c(0, 0), labels = comma_format()) + \r\n  labs(y = \"Count\") + \r\n  scale_fill_brewer(palette = \"Set1\") + \r\n  coord_flip() +  # change the orientation of the diagram\r\n  theme_classic(base_size = 13) + \r\n  theme(axis.line.y = element_blank(),\r\n        axis.ticks.y = element_blank())\r\n\r\n\r\n\r\n\r\nWorking with long format\r\ndata\r\nAs mentioned earlier, ggalluvial also works with data in\r\nlong format. So let’s convert the data now. Note that we need to add an\r\nID column to the dataframe before melting it into long format. These\r\nID’s will tell the functions how to connect the flows between adjacent\r\nbars (each ID represents a flow stream across all the bars from left to\r\nright).\r\n\r\n\r\n# Convert the wide data into long format\r\ndiamonds_long <- diamonds_wide %>%\r\n  mutate(alluvium_ID = row_number()) %>%  # add an ID for each row\r\n  pivot_longer(cols = -c(count, alluvium_ID), names_to = \"variable\", values_to = \"level\") %>% \r\n  mutate(level = factor(level, levels = c(\"Large\", \"Small\", \"Ideal\", \"Premium\", \"Very Good\", \"Good\", \"Fair\", \"High\", \"Mid\", \"Low\")))  # adjust the level order for later plotting\r\n\r\nhead(diamonds_long)\r\n\r\n# A tibble: 6 x 4\r\n  count alluvium_ID variable  level\r\n  <int>       <int> <chr>     <fct>\r\n1  5808           1 carat_cat Large\r\n2  5808           1 cut       Ideal\r\n3  5808           1 price_cat High \r\n4  2648           2 carat_cat Large\r\n5  2648           2 cut       Ideal\r\n6  2648           2 price_cat Mid  \r\n\r\n\r\nGreat. It’s time to make the diagram! As the data are now in long\r\nformat, the argument specifications are a bit different from those we\r\nused for previous plots:\r\nThe flow\r\nstreams are drawn using geom_flow() instead of\r\ngeom_alluvium(), and the alluvium ID’s are specified via\r\nthe argument aes(alluvium = alluvium_ID)\r\nThe positions\r\nof the bars along the x-axis are specified via\r\naes(x = variable), and the stacks of the bars are specified\r\nvia aes(stratum = level)\r\nThe bars are\r\nlabeled directly via the argument aes(label = ) without\r\nhaving to call after_stat()\r\n\r\n\r\n# Create a color palette for the bars\r\ncolor_pal <- set_names(c(\"#bdbdbd\", \"#525252\", \"#fde725\", \"#7ad151\", \"#22a884\", \"#2a788e\", \"#414487\", \"#e41a1c\", \"#377eb8\", \"#4daf4a\"), nm = levels(diamonds_long$level))\r\n\r\nggplot(diamonds_long, aes(x = variable, y = count, stratum = level, alluvium = alluvium_ID)) +\r\n  geom_flow(aes(fill = level), width = 1/5) +\r\n  geom_stratum(aes(fill = level), alpha = 0.75, width = 1/5) +\r\n  geom_text(stat = \"stratum\", aes(label = level), size = 3) +\r\n  scale_x_discrete(labels = c(\"Carat\", \"Cut\", \"Price\"), expand = c(0, 0.2)) +\r\n  scale_y_continuous(expand = c(0, 0), labels = comma_format()) + \r\n  labs(x = \"\", y = \"Count\") +\r\n  guides(fill = \"none\") + \r\n  scale_fill_manual(values = color_pal) +\r\n  theme_classic(base_size = 13) + \r\n  theme(axis.line.x = element_blank(),\r\n        axis.ticks.x = element_blank())\r\n\r\n\r\n\r\nDo you notice the difference from the previous alluvial diagrams\r\ncreated with wide format data? You’re right! The bars and flows have\r\ntheir own colors now! With this method, we are able to color the bars\r\nand the flows between adjacent bars by their corresponding levels (the\r\nflow color will be the same as that of the bar stack where the flow\r\noriginates).\r\nSummary\r\nTo recap what we’ve done in this post, we started by creating a\r\nstandard alluvial diagram with wide format diamonds data\r\nusing the package ggalluvial. We then modified the diagram\r\nto produce parallel sets. Finally, we converted the data into long\r\nformat and created another alluvial diagram that had different bar and\r\nflow colors.\r\nAs mentioned in the beginning, alluvial diagrams are best for\r\nvisualizing the relationships between categorical variables. And if the\r\nbars along the axis are ordered by time, distance, or some kind of\r\nfactor gradients, then they can help reveal trends.\r\nHope you learn something useful from this post and don’t forget to\r\nleave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-09-10-post-19-go-with-the-flow-alluvial-plots-with-ggplot/../../homepage_images/Post19.png",
    "last_modified": "2022-09-16T08:11:46-07:00",
    "input_file": "post-19-go-with-the-flow-alluvial-plots-with-ggplot.knit.md",
    "preview_width": 1536,
    "preview_height": 864
  },
  {
    "path": "posts/2022-08-01-post-18-bump-charts-with-ggplot/",
    "title": "Post #18. Bump charts with ggplot",
    "description": "Come and learn how to create nice bump charts with ggplot!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-08-01",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nIntroduction\r\nBump charts are a special type of line charts that visualize the\r\nrankings of multiple objects over time. These charts are especially\r\nuseful for comparing and highlighting trends. Honestly, I haven’t really\r\nheard of this kind of charts before until recently I came across a Tweet\r\nabout creating bump charts using ggplot. I then took a deeper dive into\r\nit and felt that this would certainly make an interesting blog topic.\r\nAlso, I believe the charts will come in handy someday in the future,\r\nboth for myself and for the readers like you!\r\nSo without further ado, let’s jump right in!\r\nPrepare the data\r\nAs mentioned earlier, bump charts are useful for visualizing rankings\r\nof items over time. Instead of using a built-in R dataset, this time\r\nI’ll prepare my own one, which focuses on the rankings of five\r\necological journals (Journal of\r\nEcology, Journal of Animal\r\nEcology, Journal of Applied\r\nEcology, Functional\r\nEcology, and Methods in\r\nEcology and Evolution) from the British\r\nEcological Society. Specifically, I would like to see how the\r\nrankings of these five journals, in terms of their impact factors (IFs),\r\nchange over the past decade.\r\nTo get the data, I visited Journal\r\nCitation Reports website and downloaded the journals’ IF\r\nrecords.\r\nLet’s read in the datasets and do some data wrangling:\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(janitor)  # for the function \"row_to_names()\"\r\n\r\n# Create a list of url paths\r\nBES_journals <- c(\"J_ECOL\", \"J_ANIM_ECOL\", \"J_APPL_ECOL\", \"FUNCT_ECOL\", \"METHODS_ECOL_EVOL\")\r\ndataset_urls <- str_glue(\"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2022-08-01-post-18-bump-charts-with-ggplot/BES_journals_data/{BES_journals}.csv\")\r\n\r\n# Loop through the url paths\r\nBES_journals_data <- map(dataset_urls, function(x){\r\n  read_csv(x) %>% \r\n    row_to_names(row_number = 5) %>%  # set the fifth row as column names\r\n    slice_head(n = nrow(.)-4)  # remove the last four rows\r\n  }) %>%\r\n  `names<-`(BES_journals) %>%\r\n  bind_rows(.id = \"Journal\") %>%  # convert the list to a dataframe\r\n  select(Journal, Year, IF = `Journal impact factor`) %>% \r\n  filter(Year >= 2011) %>%  # retain data starting from 2011\r\n  group_by(Year) %>% \r\n  mutate(IF = as.numeric(IF),\r\n         Ranking = row_number(desc(IF))) %>%  # add the journal rankings by year\r\n  arrange(Year, Journal)\r\n\r\nlibrary(DT)  # for the function \"datatable()\"\r\ndatatable(BES_journals_data, options = list(pageLength = 5))\r\n\r\n\r\n\r\nBasic bump chart\r\nNow we have our data on hand, it’s time for the chart!\r\nCreating a basic bump chart is as simple as making a scatterplot (or\r\ndotplot) of time vs. rankings and “connecting the dots” with lines,\r\nwhich can be done with geom_line() and\r\ngeom_point(). Also, we can use\r\nscale_y_reverse() to flip the y-axis so that the\r\nhighest-ranking item stays on the top of the plot.\r\n\r\n\r\n# A color palette for the journals\r\ncol_pal <- set_names(c(\"#0e96d4\", \"#7581bd\", \"#48a749\", \"#e38d26\", \"#de2127\"), nm = BES_journals)\r\n\r\n# The basic bump chart\r\nggplot(BES_journals_data) + \r\n  geom_line(aes(x = Year, y = Ranking, color = Journal, group = Journal), size = 2) + \r\n  geom_point(aes(x = Year, y = Ranking, color = Journal), shape = 21, fill = \"white\", size = 4, stroke = 2) +\r\n  scale_y_reverse() +  # the highest-ranking journal is on the top\r\n  scale_color_manual(values = col_pal) +  # use the customized color palette\r\n  theme_classic()\r\n\r\n\r\n\r\nSeems that Methods in Ecology and\r\nEvolution has been the leading journal of the five in recent\r\nyears!\r\nThis figure looks fine, but we can make it shine. Let’s spice it\r\nup!\r\nThere are a few things we can do to modify the chart:\r\n (1)\r\nAdd a title, a subtitle, and a caption  (2) Remove\r\nthe legend and annotate the items directly in the plot panel\r\n (3)\r\nChange the background color\r\n\r\n\r\n# install.packages(\"ggtext\")  # install the package if you haven't\r\nlibrary(ggtext)  # for the function \"element_markdown()\"\r\n\r\n# A color palette for the journals\r\ncol_pal <- set_names(c(\"#0e96d4\", \"#7581bd\", \"#48a749\", \"#e38d26\", \"#de2127\"), nm = BES_journals)\r\n\r\n# The journal labels on the left\r\nJournal_label <- c(\"<span style = 'color: #de2127'>Methods in<br>Ecology and Evolution<\/span>\",\r\n                   \"<span style = 'color: #48a749'>Journal of<br>Applied Ecology\",\r\n                   \"<span style = 'color: #0e96d4'>Journal of Ecology<\/span>\",\r\n                   \"<span style = 'color: #7581bd'>Journal of<br>Animal Ecology<\/span>\",\r\n                   \"<span style = 'color: #e38d26'>Functional Ecology<\/span>\")\r\n\r\n# The fancy bump chart\r\nggplot(BES_journals_data) + \r\n  geom_line(aes(x = Year, y = Ranking, color = Journal, group = Journal), size = 2) + \r\n  geom_point(aes(x = Year, y = Ranking, color = Journal), shape = 21, fill = \"white\", size = 4, stroke = 2) +\r\n  geom_text(data = data.frame(x = 11.5, y = 1:5), aes(x = x, y = y, label = y)) +\r\n  scale_y_reverse(labels = Journal_label) +  # add the journal labels\r\n  scale_color_manual(values = col_pal) + \r\n  labs(title = \"<img src='https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2022-08-01-post-18-bump-charts-with-ggplot/BES_logo_tp.png' width = '100'/>\",  # add the BES logo\r\n       subtitle = \"Journal rankings based on their impact factors each year\",\r\n       caption = \"Data source: Journal Citation Reports\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\",\r\n        plot.margin = margin(5, 5, 5, 5),\r\n        plot.background = element_rect(fill = \"#b6e3d4\", color = NA),\r\n        plot.title = element_markdown(margin = margin(b = 0, unit = \"mm\"), hjust = -0.1),\r\n        plot.subtitle = element_text(margin = margin(t = -10, b = 10, unit = \"mm\"), hjust = 0.35, face = \"bold\", size = 13),\r\n        plot.caption = element_text(margin = margin(t = 5, unit = \"mm\"), face = \"italic\", color = \"grey60\"),\r\n        axis.text.x = element_text(margin = margin(t = 3, unit = \"mm\"), size = 10),\r\n        axis.text.y = element_markdown(margin = margin(r = -5, unit = \"mm\"), color = NULL, size = 11))\r\n\r\n\r\n\r\n\r\n\r\n\r\nHere I used the function element_markdown() from the\r\npackage ggtext\r\nto embed a logo in the plot title via the HTML <img>\r\ntag and to label the journals via the HTML <span>\r\ntag. The package has many nice features for text manipulations in\r\nggplots using HTML and CSS syntax. I won’t go into the details here, but\r\ndo check out my previous post\r\non this topic if interested!\r\nA modified bump chart\r\nwith smooth curves\r\nInstead of connecting the dots with straight line segments like what\r\nwe did in the above figure, we can use smooth curves. This is actually\r\nsuper easy: just replace geom_line() with\r\ngeom_bump()!\r\n\r\n\r\n# install.packages(\"ggbump\")  # install the package if you haven't\r\nlibrary(ggbump)\r\nlibrary(ggtext)\r\n\r\ncol_pal <- set_names(c(\"#0e96d4\", \"#7581bd\", \"#48a749\", \"#e38d26\", \"#de2127\"), nm = BES_journals)\r\n\r\nJournal_label <- c(\"<span style = 'color: #de2127'>Methods in<br>Ecology and Evolution<\/span>\",\r\n                   \"<span style = 'color: #48a749'>Journal of<br>Applied Ecology\",\r\n                   \"<span style = 'color: #0e96d4'>Journal of Ecology<\/span>\",\r\n                   \"<span style = 'color: #7581bd'>Journal of<br>Animal Ecology<\/span>\",\r\n                   \"<span style = 'color: #e38d26'>Functional Ecology<\/span>\")\r\n\r\n# The modified bump chart using \"geom_bump()\"\r\nggplot(BES_journals_data) + \r\n  geom_bump(aes(x = Year, y = Ranking, color = Journal, group = Journal), size = 2) + \r\n  geom_point(aes(x = Year, y = Ranking, color = Journal), shape = 21, fill = \"white\", size = 4, stroke = 2) +\r\n  geom_text(data = data.frame(x = 11.5, y = 1:5), aes(x = x, y = y, label = y)) +\r\n  scale_y_reverse(labels = Journal_label) +\r\n  scale_color_manual(values = col_pal) +\r\n  labs(title = \"<img src='https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2022-08-01-post-18-bump-charts-with-ggplot/BES_logo_tp.png' width = '100'/>\",\r\n       subtitle = \"Journal rankings based on their impact factors each year\",\r\n       caption = \"Data source: Journal Citation Reports\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\",\r\n        plot.margin = margin(5, 5, 5, 5),\r\n        plot.background = element_rect(fill = \"#b6e3d4\", color = NA),\r\n        plot.title = element_markdown(margin = margin(b = 0, unit = \"mm\"), hjust = -0.1),\r\n        plot.subtitle = element_text(margin = margin(t = -10, b = 10, unit = \"mm\"), hjust = 0.35, face = \"bold\", size = 13),\r\n        plot.caption = element_text(margin = margin(t = 5, unit = \"mm\"), face = \"italic\", color = \"grey60\"),\r\n        axis.text.x = element_text(margin = margin(t = 3, unit = \"mm\"), size = 10),\r\n        axis.text.y = element_markdown(margin = margin(r = -5, unit = \"mm\"), color = NULL, size = 11))\r\n\r\n\r\n\r\n\r\n\r\n\r\nLooks pretty cool (a bit like subway maps)!\r\nAdvanced topic - Ribbon bump\r\nchart\r\nFor the purpose of science communication, the bump charts we’ve\r\ncreated above are pretty much enough. But as a ggplot geek, it’s always\r\nfun to challenge myself a bit and go a step further to try out something\r\ncool. This is the motive for this advanced topic! Also, a shout-out to\r\nthe author of the Tweet\r\nI mentioned at the beginning of the post. The idea was largely inspired\r\nby the chart he made and much of the code below is modified from his\r\nGitHub repository.\r\nCreating a ribbon bump chart is not an easy task and requires some\r\ndata manipulations. I’ll break down the process into four steps and\r\nexplain what I’m doing in each step. I think this would make it easier\r\nto understand the underlying principles and hopefully you’ll be able to\r\nbuild your own chart in the future.\r\nSo the four steps are:  (1) Create a\r\nstacked barplot of journals’ impact factors over year  (2) Compute\r\nthe curves that connect the upper/lower ends of the bars for each\r\njournal  (3) Add\r\nribbons to the stacked barplot  (4) Polish\r\nthe appearance of the chart\r\nLet’s kick off our plotting journey. Enjoy!\r\nStep\r\n1. Create a stacked barplot of journals’ impact factors over year\r\nTo create a stacked barplot of the journals’ IFs, we need to\r\ndetermine the upper and lower ends of the bars. We’ll do this by first\r\narranging the journals in a descending order based on their rankings\r\neach year (so the lowest-ranking journal will be on the top of the\r\ndataframe) and then calculating the cumulative sums of the journals’\r\nIFs, which will be the upper ends of the bars. For the lower ends,\r\nthey’ll be the cumulative sums minus the journals’ own IFs.\r\nIt’s noteworthy that here we won’t use the conventional geom layer\r\ngeom_bar() to create the barplot, but\r\ngeom_rect() instead. The main reason for using\r\ngeom_rect() rather than geom_bar() is that\r\ngeom_rect() allows us to order the bars differently for\r\neach year, whereas geom_bar() will place the bars in the\r\nsame order across years. Since the journal rankings varied across years,\r\nwe should use the former.\r\n\r\n\r\n# Calculate the cumulative sums of the journals' IFs \r\nBES_journals_data_bars <- BES_journals_data %>% \r\n  arrange(Year, desc(Ranking)) %>% \r\n  group_by(Year) %>% \r\n  mutate(y_upper = cumsum(IF),\r\n         y_lower = cumsum(IF) - IF) %>% \r\n  ungroup()\r\n\r\n# A color palette for the journals\r\ncol_pal <- set_names(c(\"#0e96d4\", \"#7581bd\", \"#48a749\", \"#e38d26\", \"#de2127\"), nm = BES_journals)\r\n\r\n# Create a stacked barplot of the journals' IFs each year\r\nribbon_bumpchart_bars <- ggplot(BES_journals_data_bars) + \r\n  geom_rect(aes(xmin = as.numeric(Year) - 0.05, xmax = as.numeric(Year) + 0.05,\r\n                ymin = y_lower, ymax = y_upper, fill = Journal), color = \"white\") +\r\n  scale_fill_manual(values = col_pal) +\r\n  theme_classic()\r\n\r\nribbon_bumpchart_bars\r\n\r\n\r\n\r\nStep\r\n2. Compute the curves that connect the upper/lower ends of the bars for\r\neach journal\r\nNow comes the core part of the process: computing the curves that\r\nconnect the upper/lower ends of the bars for each journal. These\r\nupper/lower curves form the boundaries of the ribbons that we’ll be\r\nadding to the plot later. We’ll split the original dataframe into\r\nindividual subsets by journal and do the computation separately for each\r\nof them.\r\nFirst, for each subset, we’ll create four new columns:\r\nx_from, x_to, y_from,\r\nand y_to. x_from is the current year\r\nplus the bar width (which is 0.05); x_to is the next\r\nyear minus bar width; y_from is the upper/lower ends of\r\nthe bars in the current year; y_to is the upper/lower\r\nends of the bars next year. Together, these four columns serve as the x-\r\nand y-coordinates of the two points (x_from,\r\ny_from) and (x_to,\r\ny_to), between which a smooth connecting curve will be\r\nderived.\r\nNote that in the below code chunk, the y_to for the\r\nyear 2022 was set to NA because there is no next bar to go,\r\nand the row for that year was later removed. Also, I subtracted 0.1 from\r\nthe upper end and added 0.1 to the lower end to create a margin between\r\nribbons so that the ribbons will not go shoulder to shoulder when we\r\nplot them later.\r\nNext, we’ll use the function sigmoid() from the package\r\nggbump to compute a smooth sigmoid curve between the two\r\npoints (x_from, y_from) and\r\n(x_to, y_to). The smoothness of the\r\ncurve can be adjusted via the arguments n and\r\nsmooth (play around with different values to see how the\r\nribbons change!).\r\nFinally, we’ll merge the results (the x- and y-coordinates of the\r\npoints forming the smooth curves) of each subset into a single\r\ndataframe, which contains all the information we need for plotting the\r\nribbons.\r\n\r\n\r\nlibrary(ggbump)  # for the function \"sigmoid()\"\r\n\r\n# Compute the upper/lower curves connecting the bars\r\nBES_journals_data_ribbons <- BES_journals_data_bars %>% \r\n  split(., .$Journal) %>% \r\n  map(., function(data){\r\n    \r\n    # the upper curve\r\n    upper_curve <- data %>% \r\n      select(Journal, Year, y_upper) %>% \r\n      mutate(x_from = as.numeric(Year) + 0.05,\r\n             x_to = as.numeric(Year) + 1 - 0.05,\r\n             y_from = y_upper - 0.1,  # 0.1 sets the margin between adjacent ribbons\r\n             y_to = c(y_upper[-1], NA) - 0.1) %>% \r\n      filter(Year != \"2021\") %>% \r\n      rowwise() %>% \r\n      mutate(curve = list(sigmoid(x_from, x_to, y_from, y_to, n = 100, smooth = 8))) %>% \r\n      unnest() %>% \r\n      select(Journal, x, y_upper = y)\r\n    \r\n    # the lower curve    \r\n    lower_curve <- data %>%\r\n      select(Journal, Year, y_lower) %>% \r\n      mutate(x_from = as.numeric(Year) + 0.05,\r\n             x_to = as.numeric(Year) + 1 - 0.05,\r\n             y_from = y_lower + 0.1,\r\n             y_to = c(y_lower[-1], NA) + 0.1) %>% \r\n      filter(Year != \"2021\") %>% \r\n      rowwise() %>% \r\n      mutate(curve = list(sigmoid(x_from, x_to, y_from, y_to, n = 100, smooth = 8))) %>% \r\n      unnest() %>% \r\n      select(Journal, x, y_lower = y)\r\n    \r\n    # put the two dataframes together\r\n    curve <- left_join(upper_curve, lower_curve[, -1], by = \"x\")\r\n  }) %>% bind_rows()  # merge the results\r\n\r\ndatatable(BES_journals_data_ribbons, options = list(pageLength = 5))\r\n\r\n\r\n\r\nStep 3. Add ribbons\r\nto the stacked barplot\r\nReady to draw the ribbons! We’ll use geom_ribbon() and\r\nspecify the upper (ymax =) and lower (y_min =)\r\nboundary. The ribbons were adjusted to be slightly transparent so that\r\nwhen two ribbons cross each other, the one beneath can still be\r\nseen.\r\nWe’ll also use the function move_layers() from the\r\npackage gginnards to pull the bars (which were drawn on the\r\ngeom_rect() layer) to the top. Otherwise, the bars will be\r\ncompletely covered by the ribbons!\r\n\r\n\r\n# Add the ribbons to the barplot \r\nribbon_bumpchart <- ribbon_bumpchart_bars + \r\n  geom_ribbon(data = BES_journals_data_ribbons, \r\n              aes(x = x, ymax = y_upper, ymin = y_lower, fill = Journal), alpha = 0.75)\r\n\r\n# Move the bars to the top  \r\nlibrary(gginnards)\r\n\r\nribbon_bumpchart <- move_layers(ribbon_bumpchart, \"GeomRect\", position = \"top\")\r\nribbon_bumpchart\r\n\r\n\r\n\r\nStep 4. Polish the\r\nappearance of the chart\r\nHere we are at our final step: polishing the appearance of the chart!\r\nAgain, we’ll add a logo title, a subtitle, and a caption to it. We’ll\r\nalso label the years along the x-axis as well as the journal names on\r\nthe left of the ribbons.\r\n\r\n\r\n# Journal labels\r\nJournal_label <- c(\"<span style = 'color: #de2127'>Methods in<br>Ecology and Evolution<\/span>\",\r\n                   \"<span style = 'color: #48a749'>Journal of<br>Applied Ecology\",\r\n                   \"<span style = 'color: #0e96d4'>Journal of Ecology<\/span>\",\r\n                   \"<span style = 'color: #7581bd'>Journal of<br>Animal Ecology<\/span>\",\r\n                   \"<span style = 'color: #e38d26'>Functional Ecology<\/span>\")\r\n\r\n# Journal label positions\r\nJournal_label_position <- filter(BES_journals_data_bars, Year == 2011)$y_upper - filter(BES_journals_data_bars, Year == 2011)$IF/2\r\n\r\n# Modify the appearance of the chart\r\nribbon_bumpchart <- ribbon_bumpchart +\r\n  scale_x_continuous(breaks = c(2011:2021)) + \r\n  scale_y_continuous(breaks = Journal_label_position, labels = rev(Journal_label)) +\r\n  labs(title = \"<img src='https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2022-08-01-post-18-bump-charts-with-ggplot/BES_logo_tp.png' width = '100'/>\",\r\n       subtitle = \"Journal rankings based on their impact factors each year\",\r\n       caption = \"Data source: Journal Citation Reports\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\",\r\n        plot.margin = margin(5, 5, 5, 5),\r\n        plot.background = element_rect(fill = \"#b6e3d4\", color = NA),\r\n        plot.title = element_markdown(margin = margin(b = -5, unit = \"mm\"), hjust = -0.1),\r\n        plot.subtitle = element_text(margin = margin(t = -5, b = -10, unit = \"mm\"), hjust = 0.35, face = \"bold\", size = 13),\r\n        plot.caption = element_text(margin = margin(t = 5, unit = \"mm\"), face = \"italic\", color = \"grey60\"),\r\n        axis.text.x = element_text(margin = margin(t = 1, unit = \"mm\"), size = 10),\r\n        axis.text.y = element_markdown(margin = margin(r = -5, unit = \"mm\"), color = NULL, size = 11))\r\n\r\nribbon_bumpchart\r\n\r\n\r\n\r\n\r\n\r\n\r\nAfter a long trek through the code, we’ve now reached the destination\r\nof our plotting journey. Hooray!\r\nSummary\r\nTo recap what we did in this post, we first created a basic bump\r\ncharts from scratch using geom_line() and\r\ngeom_point(). Next, we used geom_bump() to\r\ncreate a modified bump chart with smooth curves connecting the points.\r\nLastly, we went on an adventure and created a ribbon bump chart step by\r\nstep, including some data manipulations to get the data we need for\r\nplotting. After doing this post, I found bump charts quite handy and I\r\nthink I should use them more often for communication. I believe you\r\nthink so too!\r\nHope you learn something useful from this post and don’t forget to\r\nleave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-01-post-18-bump-charts-with-ggplot/../../homepage_images/Post18.png",
    "last_modified": "2022-08-11T07:03:53-07:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 960
  },
  {
    "path": "posts/2022-07-02-post-17-ggplot-legend-tips-series-no6-working-on-continuous-legends-with-scalexx-functions/",
    "title": "Post #17. ggplot Legend Tips Series No.6: Working on continuous legends with scale_XX functions",
    "description": "In this post, you will learn how to modify the appearance of continuous legends in ggplots using `scale_XX` family of functions.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-07-03",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nBackground\r\nThis is the part II of the previous\r\npost where I introduced how one can adjust the discrete legends in\r\nggplots using the scale_XX family of functions. In this\r\npost, I’m going to talk about adjusting continuous legends, again using\r\nthe scale_XX functions.\r\nAn example with\r\nscale_fill_gradient()\r\nLet’s start with an example plot of eruption time vs. waiting time of\r\nthe old faithful geyser using the faithful\r\ndataset. In the below code chunk, the function geom_hex()\r\ndivides the plot panel into a grid of hexagons, counts the number of\r\noriginal data points in each hexagon, and maps the counts to the “fill”\r\naesthetic. This is a useful way to avoid overlapping points (i.e.,\r\noverplotting), especially when the dataset is huge.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(faithful, aes(x = eruptions, y = waiting)) + \r\n  geom_hex(aes(fill = ..count..)) +  # hexagon bins \r\n  labs(x = \"Eruption time (min)\", y = \"Waiting time (min)\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nNow we can try to adjust the legend bar using the arguments in\r\nscale_fill_gradient(). Three main things to change are:\r\n (1)\r\nLegend range, controlled by the argument limits\r\n (2)\r\nLegend tick positions, controlled by the argument breaks\r\n  (3) Legend\r\ntick labels, controlled by the argument labels \r\n\r\n\r\nggplot(faithful, aes(x = eruptions, y = waiting)) + \r\n  geom_hex(aes(fill = ..count..)) +\r\n  scale_fill_gradient(name = \"Number of \\n eruptions\",\r\n                      limits = c(0, 6),  # legend range\r\n                      breaks = c(1, 2, 3, 4, 5),  # legend tick positions\r\n                      labels = format(c(1, 2, 3, 4, 5), nsmall = 1)) +  # legend tick labels\r\n  labs(x = \"Eruption time (min)\", y = \"Waiting time (min)\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nWe can also cut the legend bar into several bins by using the\r\nargument guide = guide_colorsteps():\r\n\r\n\r\nggplot(faithful, aes(x = eruptions, y = waiting)) + \r\n  geom_hex(aes(fill = ..count..)) +\r\n  scale_fill_gradient(name = \"Number of \\n eruptions\",\r\n                      limits = c(0, 6),  \r\n                      breaks = c(1, 2, 3, 4, 5),  \r\n                      labels = format(c(1, 2, 3, 4, 5), nsmall = 1),\r\n                      guide = guide_colorsteps()) +  # cut the legend bar into bins\r\n  labs(x = \"Eruption time (min)\", y = \"Waiting time (min)\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nSummary\r\nIn this post, we’ve seen how to adjust a continuous legend via the\r\narguments in scale_fill_gradient(): limits for\r\nsetting the range of the legend bar, breaks for drawing the\r\nlegend ticks, and labels for adding the tick labels. We can\r\nalso convert the continuous legend bar into a discrete one by specifying\r\nguide = guide_colorsteps().\r\nHope you learn something useful from this simple post and don’t\r\nforget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-07-02-post-17-ggplot-legend-tips-series-no6-working-on-continuous-legends-with-scalexx-functions/../../homepage_images/Post17.png",
    "last_modified": "2022-07-04T07:16:46-07:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 672
  },
  {
    "path": "posts/2022-06-09-post-16-ggplot-legend-tips-series-no5-working-on-discrete-legends-with-scalexx-functions/",
    "title": "Post #16. ggplot Legend Tips Series No.5: Working on discrete legends with scale_XX functions",
    "description": "In this post, you will learn how to modify the appearance of discrete legends in ggplots using `scale_XX` family of functions.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-06-09",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nBackground\r\nWelcome to the fifth post of ggplot Legend Tips\r\nSeries! This post is a continuation of a previous\r\npost, where I introduced how to modify the appearance of discrete\r\nlegends in ggplots with guides(), such as legend label\r\nfont, legend key size, and legend direction and position (give it a read\r\nif you’re interested!).\r\nToday, we will explore another way to modify discrete legends: using\r\nscale_XX family of functions (e.g.,\r\nscale_color_manual() and\r\nscale_shape_manual()). There are three handy adjustments\r\nyou can do with these scale functions:\r\n\r\n(1) Change legend name and labels  (2)\r\nChange the order of legend keys  (3)\r\nSelectively display certain legend keys\r\nWithout further ado, let’s jump right in!\r\nAn example with\r\nscale_color_brewer()\r\nWe will use the ChickWeight\r\ndataset for our example plots. The dataset contains the body weights of\r\nchicks fed with four different protein diets recorded over a course of\r\n20 days.\r\nLet’s compute the average weight of chicks in each diet treatment and\r\nplot the growth curve over time. We’ll map diet treatment to the “color”\r\naesthetic and use scale_color_brewer() to set the colors\r\nfor the legend.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Average chick weight over time in each diet treatment\r\nChickWeight_avg <- ChickWeight %>% \r\n  group_by(Diet, Time) %>% \r\n  summarise(weight = mean(weight))\r\n\r\n### Growth curve of the chicks\r\nP <- ggplot(ChickWeight_avg) + \r\n  geom_line(aes(x = Time, y = weight, color = Diet)) + \r\n  geom_point(aes(x = Time, y = weight, color = Diet)) +  \r\n  labs(x = \"Day\", y = \"Weight (g)\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP\r\n\r\n\r\n\r\n\r\n(1) Change legend name and\r\nlabels\r\nChanging legend name and labels is perhaps the most common thing\r\nggplot users would do for their legends. This is super straightforward:\r\nsimply specify the argument name = for the new legend name\r\nand pass a vector of labels to argument labels = in\r\nscale_color_brewer(). Easy-peasy!!!\r\n\r\n\r\nP + scale_color_brewer(palette = \"Set1\", \r\n                       name = \"Diet Treatment\",  # new legend name\r\n                       labels = c(\"Red diet\", \"Blue diet\", \"Green diet\", \"Purple diet\"))  # new legend labels\r\n\r\n\r\n\r\n\r\n(2) Change the order of legend\r\nkeys\r\nThe second thing we can do is reordering the legend keys. As you can\r\nsee, the chicks fed with “Green” diet grew the best, followed by those\r\nfed with “Purple” and “Blue” diet, and those fed with “Red” diet grew\r\nthe worst. So can we change the order of legend keys to reflect this\r\nranking?\r\nOf course we can! The main argument for this is break =,\r\nwhich takes a vector of levels in the legend variable (in this example\r\n1, 2, 3, and 4 in the factor Diet). The order of the levels\r\npassed to the argument will determine the order of key items displayed\r\nin the legend.\r\n\r\n\r\nP + scale_color_brewer(palette = \"Set1\", \r\n                       name = \"Diet Treatment\", \r\n                       breaks = c(3, 4, 2, 1),  # new order of the legend keys\r\n                       labels = c(\"Green diet\", \"Purple diet\", \"Blue diet\", \"Red diet\"))\r\n\r\n\r\n\r\n\r\n(3) Selectively display\r\ncertain legend keys\r\nSuppose we want to show only the best (“Green”) and the worst diet\r\n(“Red”) in the legend and hide the other two intermediate ones. We can\r\ndo this by passing the selected levels (here 1 and 3) to the\r\nbreak = argument in the desired order (3 first then 1):\r\n\r\n\r\nP + scale_color_brewer(palette = \"Set1\", \r\n                       name = \"Diet Treatment\", \r\n                       breaks = c(3, 1),  # select the best and the worst diet\r\n                       labels = c(\"Green diet (best)\", \"Red diet (worst)\"))\r\n\r\n\r\n\r\n\r\n\r\nIt is worth noting that there is a second way to selectively display\r\ncertain legend keys, via the argument limits =. However,\r\nthe argument will affect the main plot as well; the levels not specified\r\nin limits = will not be drawn in the plot! In fact, this is\r\nbasically the same as dropping the levels in the factor, and so the\r\naesthetic mapping will change accordingly. See an example below:\r\n\r\n\r\nP + scale_color_brewer(palette = \"Set1\", \r\n                       name = \"Diet Treatment\", \r\n                       limits = c(3, 1),  # select the best and the worst diet\r\n                       labels = c(\"Best diet\", \"Worst diet\"))  # the best and the worst diet are not in green and red now! \r\n\r\n\r\n\r\n\r\n\r\nAs you can see, only the curves for the best and the worst diet are\r\nshown in the plot, and the colors of these two curves have also changed\r\nbecause the number of levels is no longer 4 but 2.\r\nSo depending on the purpose of your figure, you might want to use\r\nbreaks = or limits = to select certain legend\r\nkeys of interest. But just keep in mind that the aesthetic mapping may\r\ndiffer between the two methods!\r\nSummary\r\nIn this post, we looked at how to modify a discrete legend via the\r\narguments in scale_color_brewer(): names = and\r\nlabels = for legend name and labels, as well as\r\nbreaks = and limits = for legend keys. The\r\nsame principle applies to other discrete legend types too, for instance,\r\nlinetype and shape.\r\nHope you learn something useful and don’t forget to leave your\r\ncomments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-09-post-16-ggplot-legend-tips-series-no5-working-on-discrete-legends-with-scalexx-functions/../../homepage_images/Post16.png",
    "last_modified": "2022-07-02T21:44:40-07:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 672
  },
  {
    "path": "posts/2022-05-12-post-15-manipulating-axis-scales-for-individual-facets/",
    "title": "Post #15. Manipulating the axes for individual facets with `tidytext` and `ggh4x`",
    "description": "Bothered by the hassle of manipulating the axes for individual facets? This is the post for you!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-05-12",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nJust realized the blog is one year old: it’s now entering the 1st instar! It has definitely grown a lot since it hatched. Keep developing!\r\nBackground\r\nFaceting is arguably one of the most fantastic features of ggplots—it can quickly split the data into subsets by the given categorical variables and visualize these subsets in a grid of panels (facets). However, fine-tuning individual facets can be quite daunting. For example, I’ve been trying to reorder the items along the x-axis within each facet (i.e., different item orders for different facets), or to adjust the y-axis range and tick marks of some specific facets. These tasks don’t sound complicated on the surface, but there is actually no built-in ggplot function/argument to do so.\r\nAfter doing some research online, I found two extension packages: tidytext and ggh4x, that have functions to deal with the these issues. I feel that many ggplot users might have encountered similar problems before, and this is indeed the motivator for me to write something on them. So in this post, I’ll share with you the two nice packages and hope they will come in handy for your own ggplots in the future!\r\n1. Reorder items along x-axis for indiviudual facets\r\nLet’s kick things off by creating a faceted plot using the diamonds dataset, which contains the attributes and prices of over 50,000 diamonds.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(diamonds, aes(x = color, y = price)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut) + \r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13)\r\n\r\n\r\n\r\n\r\nThe above plot shows the means and 95% confidence intervals of the price of diamonds in different colors grouped by cut.\r\nNow, we can reorder the points in an ascending fashion for individual facets, using the function reorder_within() and scale_x_reordered() from the package tidytext.\r\nIn reorder_within(x, by, within, fun), the argument x is the factor you would like to reorder, by is the continuous variable based on which x is reordered, within is the faceting variable, and fun is the function to compute a statistics on the by variable that determines the ordering of levels in x. Ok, that’s quite wordy. An example will make things clear:\r\n\r\n\r\n# install.packages(\"tidytext\")  # install the package if you haven't\r\nlibrary(tidytext)\r\n\r\nggplot(diamonds, aes(x = reorder_within(x = color, by = price, within = cut, fun = mean), y = price)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free_x\") +  # need to set scales = \"free_x\" to allow for varying x-axes for individual facets  \r\n  scale_x_reordered() +  # specify \"limits = rev\" in the function to get descending points\r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13)\r\n\r\n\r\n\r\n\r\nReordered. Nice!\r\nSay we want to adjust the item order for just the facet “Fair”. We can do so using the function facetted_pos_scales() from the package ggh4x:\r\n\r\n\r\n# install.packages(\"ggh4x\")  # install the package if you haven't\r\nlibrary(ggh4x)\r\n\r\n# reordered color levels for \"fair\" diamonds\r\nreordered_levels_fair <- fct_reorder(.f = filter(diamonds, cut == \"Fair\")$color, \r\n                                     .x = filter(diamonds, cut == \"Fair\")$price, \r\n                                     .fun = mean) %>% levels()\r\n\r\nggplot(diamonds, aes(x = color, y = price)) +\r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free_x\") + \r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13) + \r\n  facetted_pos_scales(x = list(cut == \"Fair\" ~ scale_x_discrete(limits = reordered_levels_fair)))  \r\n\r\n\r\n\r\n# x = list(...) means x-axis; cut == \"Fair\" identifies the facet \"Fair\"; ~ scale_x_discrete(limits = ) gives the new item order for that facet   \r\n\r\n\r\n\r\n\r\n2. Adjust y-axis scales for individual facets\r\nThere is an argument scales = in facet_wrap() that allows you to have varying axes for individual facets. You’ve already seen the use of scales = \"free_x\" in the previous plots, and the same goes for y-axis:\r\n\r\n\r\nggplot(diamonds, aes(x = color, y = price)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free_y\") + \r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13)\r\n\r\n\r\n\r\n\r\nNow the y-axes are determined by the range of the data within each facet. However, what if you want to truly customize the axes, say changing the positions and labels of the tick marks? Again, facetted_pos_scales() can do the trick!\r\nLet’s add a few tick marks to the “Fair” and “Premium” panel and cut a few for the “Very Good” and “Ideal” panel so that each panel has five tick marks:\r\n\r\n\r\nlibrary(ggh4x)\r\n\r\nggplot(diamonds, aes(x = color, y = price)) +\r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free_y\") +  # need to set 'scales = \"free_y\"'\r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13) + \r\n  # a list of panels to be modified\r\n  facetted_pos_scales(y = list(cut == \"Fair\" ~ scale_y_continuous(breaks = c(3500, 4000, 4500, 5000, 5500)),\r\n                               cut == \"Premium\" ~ scale_y_continuous(breaks = c(3500, 4200, 4900, 5600, 6300)),\r\n                               cut == \"Very Good\" ~ scale_y_continuous(breaks = c(3000, 3600, 4200, 4800, 5400)),\r\n                               cut == \"Ideal\" ~ scale_y_continuous(breaks = c(2400, 3100, 3800, 4500, 5200))))\r\n\r\n\r\n\r\n\r\nFinally, we can combine both reordering and rescaling to create some cool visual effects:\r\n\r\n\r\nlibrary(tidytext)\r\nlibrary(ggh4x)\r\n\r\nggplot(diamonds, aes(x = reorder_within(x = color, by = price, within = cut, fun = mean), y = price)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free\", nrow = 1) +  \r\n  scale_x_reordered() + \r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13) +\r\n  facetted_pos_scales(y = list(cut == \"Fair\" ~ scale_y_continuous(limits = c(3800, 12000), breaks = c(3500)), \r\n                               cut == \"Good\" ~ scale_y_continuous(limits = c(1500, 11500), breaks = c(3875)),\r\n                               cut == \"Very Good\" ~ scale_y_continuous(limits = c(-1000, 10000), breaks = c(4250)),\r\n                               cut == \"Premium\" ~ scale_y_continuous(limits = c(-5000, 9000), breaks = c(4625)),\r\n                               cut == \"Ideal\" ~ scale_y_continuous(limits = c(-8500, 4700), breaks = c(5000))))\r\n\r\n\r\n\r\n\r\nOf course this plot is definitely NOT appropriate for data communication; it’s so deceiving and misleading! Just for pure fun and also to demonstrate how versatile the two packages can be!!!\r\nSummary\r\nTo summarize what we’ve talked about, we learned (1) how to reorder the items along the x-axis for individual facets (all at once) using reorder_within() and scale_x_reordered() from the tidytext package, or for specific facet(s) using facetted_pos_scales() from the ggh4x package, and (2) how to adjust axis scales for individual facets using facetted_pos_scales() from the ggh4x package. Having these two skills under your belt will certainly help you go a long way on your ggplot journey!\r\nThat’s it for now and hope the topic in this post would be helpful for you sometime in the future. And as always, don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-05-12-post-15-manipulating-axis-scales-for-individual-facets/../../homepage_images/Post15.png",
    "last_modified": "2022-05-16T07:31:40-07:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 768
  },
  {
    "path": "posts/2022-04-24-post-14-multiple-color-scales-in-one-ggplot/",
    "title": "Post #14. Multiple color scales in one ggplot",
    "description": "Using different color scales for multiple geom layers in one ggplot with `ggnewscale` and `relayer`",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-04-24",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nThe problem\r\nLet’s kick things off with an example:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(data = iris) + \r\n  geom_point(aes(x = Species, y = Sepal.Length, color = Sepal.Length), position = position_jitter(width = 0.1)) + \r\n  geom_boxplot(aes(x = Species, y = Sepal.Length), width = 0.5, outlier.color = NA, fill = NA) + \r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_viridis_c(name = \"Sepal length\")\r\n\r\n\r\n\r\n\r\n Here, we make a boxplot of the sepal length for the three species and add the original data points, which are mapped to a continuous color scale.\r\nNow, what if we also want to use different colors for the boxes? Let’s try it out:\r\n\r\n\r\nggplot(data = iris) + \r\n  geom_point(aes(x = Species, y = Sepal.Length, color = Sepal.Length), position = position_jitter(width = 0.1)) + \r\n  geom_boxplot(aes(x = Species, y = Sepal.Length, color = Species), width = 0.5, outlier.color = NA, fill = NA) +  # map species to color\r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_viridis_c(name = \"Sepal length\") + \r\n  scale_color_brewer(name = \"Species\", palette = \"Set1\")  # color scale for species\r\n\r\n\r\nScale for 'colour' is already present. Adding another scale for\r\n'colour', which will replace the existing scale.\r\nError: Continuous value supplied to discrete scale\r\n\r\n Eek, it throws an error!!! The message says “Continuous value supplied to discrete scale”, meaning that we cannot use another color scale for the plot (the discrete one for species) when there is already one (the continuous one for sepal length). What can we do?\r\nThe solution\r\nThankfully, there are two extension packages designed to solve this problem: ggnewscale and relayer. I’ll walk through them in the following sections.\r\n(1) ggnewscale\r\nLooking for a quick fix? ggnewscale is the go-to: The main function new_scale_color() is super straightforward and easy to use. Simply insert the function before the second color scale (in this case scale_color_brewer()). This will “decouple” the first scale from the second one so that the two scales will not interfere with each other. Indeed, you can apply the principle to three or more color scales!\r\nBy the way, note that new_scale_color() only works for scale, not geom! So if you put both geom_point() and geom_boxplot() before the function, the error will still occur (you can try this out yourself!).\r\n\r\n\r\n# install.packages(\"ggnewscale\")  # install the package if you haven't\r\nlibrary(ggnewscale)\r\n\r\nggplot(iris) + \r\n  geom_point(aes(x = Species, y = Sepal.Length, color = Sepal.Length), position = position_jitter(width = 0.1)) + \r\n  scale_color_viridis_c(name = \"Sepal length\") + \r\n  new_scale_color() +\r\n  geom_boxplot(aes(x = Species, y = Sepal.Length, color = Species), width = 0.5, outlier.color = NA, fill = NA) + \r\n  scale_color_brewer(palette = \"Set1\") + \r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14)\r\n\r\n\r\n\r\n\r\n(2) relayer\r\nThe second way to handle the problem is to use the function rename_geom_aes() in the package relayer. The basic idea of the function is to assign different “names” to the same aesthetic (e.g., color) as if they were different aesthetics so that these “pseudo-aesthetics” will be treated independently and not interfere with each other.\r\nConfused? Let’s break it down in the following example!\r\n\r\n\r\n# devtools::install_github(\"clauswilke/relayer\")  # install the package if you haven't\r\nlibrary(relayer)\r\n\r\nggplot(iris) +\r\n  \r\n  # the first color aesthetic mapping \r\n  # note that you need to use \"colour\" instead of \"color\" for the function to work!\r\n  geom_point(aes(x = Species, y = Sepal.Length, colour = Sepal.Length), position = position_jitter(width = 0.1)) +\r\n  \r\n  # use the new name \"colour_for_species\" for the second color aesthetic mapping\r\n  # specify that \"colour_for_species\" corresponds to the color aesthetic in rename_geom_aes()\r\n  (geom_boxplot(aes(x = Species, y = Sepal.Length, colour_for_species = Species), width = 0.5, outlier.color = NA, fill = NA) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"colour_for_species\"))) + \r\n  \r\n  # the color scale for the first color aesthetic mapping (\"colour\")\r\n  scale_color_viridis_c(aesthetics = \"colour\", name = \"Sepal length\") + \r\n  \r\n  # the color scale for the second color aesthetic mapping (\"colour_for_species\")\r\n  scale_color_brewer(aesthetics = \"colour_for_species\", palette = \"Set1\", name = \"Species\") +\r\n  \r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14)\r\n\r\n\r\n\r\n\r\n There are a few more cool things we can do with the relayer package. For example, we can color the points by both sepal length and species (i.e., three sets of color palettes for the points).\r\n\r\n\r\n# install.packages(\"RColorBrewer\")  # install the package if you haven't\r\nlibrary(RColorBrewer)  \r\npal_species <- brewer.pal(3, \"Set1\")  # the point colors for the three species\r\n\r\nggplot(iris) +\r\n  \r\n  # specify \"group = species\" to use different colors for each species\r\n  # use the new names (col1, col2, and col3) for the color aesthetic mappings\r\n  # specify the color mappings for the corresponding species in aes() \r\n  (geom_point(aes(x = Species, y = Sepal.Length, col1 = Sepal.Length, col2 = Sepal.Length, col3 = Sepal.Length, group = Species), position = position_jitter(width = 0.1)) %>% \r\n  rename_geom_aes(new_aes = c(\"colour\" = \"col1\", \"colour\" = \"col2\", \"colour\" = \"col3\"), aes(colour = case_when(group == 1 ~ col1, group == 2 ~ col2, group == 3 ~ col3)))) +\r\n  \r\n  # geom layer for the boxplot\r\n  (geom_boxplot(aes(x = Species, y = Sepal.Length, col4 = Species), width = 0.5, outlier.color = NA, fill = NA) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col4\"))) + \r\n  \r\n  # color scales for the points (three scales, each for one species)\r\n  scale_color_gradient(aesthetics = \"col1\", low = \"white\", high = pal_species[1], name = \"setosa\", guide = guide_legend(order = 1, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  scale_color_gradient(aesthetics = \"col2\", low = \"white\", high = pal_species[2], name = \"versicolor\", guide = guide_legend(order = 2, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  scale_color_gradient(aesthetics = \"col3\", low = \"white\", high = pal_species[3], name = \"virginica\", guide = guide_legend(order = 3, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  \r\n  # color scale for the boxplot\r\n  scale_color_brewer(aesthetics = \"col4\", palette = \"Set1\", name = \"Species\", guide = guide_legend(order = 4, direction = \"vertical\")) + \r\n\r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14) + \r\n  theme(legend.title.align = 0.5,\r\n        legend.spacing.y = unit(0.05, \"in\"))\r\n\r\n\r\n\r\n\r\n In the example above, the three point legends are jointly determined by the sepal length of the three species, and so they all have the same range. This works fine here, but may not work if the three species had quite different sepal lengths (imagine one species has its sepal ten times longer than that of the other two species, then in that case the legend range will be greatly distorted!)\r\nSo is it possible to have individual range for each legend (i.e., the range of each legend is determined only by the sepal length of the corresponding species)? Of course!\r\n\r\n\r\nggplot() +\r\n  \r\n  # draw three separate geom layers for the points so that their color aesthetic mappings are independent of each other\r\n  (geom_point(data = filter(iris, Species == \"setosa\"), aes(x = Species, y = Sepal.Length, col1 = Sepal.Width), position = position_jitter(width = 0.1)) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col1\"))) +\r\n  (geom_point(data = filter(iris, Species == \"versicolor\"), aes(x = Species, y = Sepal.Length, col2 = Sepal.Width), position = position_jitter(width = 0.1)) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col2\"))) +\r\n  (geom_point(data = filter(iris, Species == \"virginica\"), aes(x = Species, y = Sepal.Length, col3 = Sepal.Width), position = position_jitter(width = 0.1)) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col3\"))) +\r\n  \r\n  # geom layer for the boxplot\r\n  (geom_boxplot(data = iris, aes(x = Species, y = Sepal.Length, col4 = Species), width = 0.5, outlier.color = NA, fill = NA) %>%\r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col4\"))) +\r\n  \r\n  # color scales for the points (three scales, each for one species)\r\n  scale_color_gradient(aesthetics = \"col1\", low = \"white\", high = pal_species[1], name = \"setosa\", guide = guide_legend(order = 1, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  scale_color_gradient(aesthetics = \"col2\", low = \"white\", high = pal_species[2], name = \"versicolor\", guide = guide_legend(order = 2, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  scale_color_gradient(aesthetics = \"col3\", low = \"white\", high = pal_species[3], name = \"virginica\", guide = guide_legend(order = 3, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  \r\n  # color scale for the boxplot\r\n  scale_color_brewer(aesthetics = \"col4\", palette = \"Set1\", name = \"Species\", guide = guide_legend(order = 4, direction = \"vertical\")) +\r\n  \r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14) + \r\n  theme(legend.title.align = 0.5,\r\n        legend.spacing.y = unit(0.05, \"in\"))\r\n\r\n\r\n\r\n\r\n The main difference from the previous example is that, instead of drawing all the points and specifying all the color mappings in one geom layer, now we do them separately in three geom layers, each for one species so that the three legends will be determined independently for each layer.\r\n *NOTE*\r\nIt seems that currently the relayer package only works for discrete legends. Therefore, if the mapped variable is continuous (like Sepal.Length), you have to force a continuous color scale (like scale_color_gradient()) to be a discrete one using the argument guide = guide_legend().\r\nSummary\r\nTo recap, we learned two packages that allow us to use different color scales for multiple geom layers: ggnewscale is the most convenient for simple purposes; relayer is slightly more complicated yet also more versatile.\r\nIn this post, I use color aesthetic as an example (which I think is the most common situation you will be encountering). But the same principle applies to other aesthetics as well: fill, shape, linetype, etc. (although the authors of the packages do warm that “It’s very experimental, so use at your own risk!”).\r\nThat’s it for now and as always, don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-04-24-post-14-multiple-color-scales-in-one-ggplot/../../homepage_images/Post14.png",
    "last_modified": "2022-04-29T07:40:51-07:00",
    "input_file": {},
    "preview_width": 1056,
    "preview_height": 672
  },
  {
    "path": "posts/2022-03-02-post-13-ggplot-legend-tips-series-no4-merging-ggplot-legends/",
    "title": "Post #13. ggplot Legend Tips Series No.4: Merging ggplot legends",
    "description": "Come and learn two handy tips to merge two ggplot legends into one!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-03-02",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nThe problem\r\nSometimes in ggplots, we get two legends that represent the same variable yet are drawn separately, and we would like to combine the two legends into one. This is the problem we are going to look into in the post.\r\nHere, we will be using the CO2 dataset for our example plots. Let’s first create a boxplot of the CO2 uptake rates of plant individuals under two chilling treatments. The boxes are colored by the site from which the plants originated (the column Type):\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nP1 <- ggplot() + \r\n  geom_boxplot(data = CO2, aes(x = Treatment, y = uptake, color = Type), width = 0.5, outlier.color = NA) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP1\r\n\r\n\r\n\r\n\r\nNow suppose that we want to show the mean uptake rates too. We can compute the means for each Type and Treatment combination and add them to the boxes using another geom layer geom_point(). Also, since the column name Type doesn’t sound intuitive, we’ll change it to Site:\r\n\r\n\r\n### Mean CO2 uptake rates by Type and Treatment\r\nCO2_mean <- CO2 %>% group_by(Treatment, Type) %>% \r\n  summarise(uptake_mean = mean(uptake)) %>%\r\n  rename(Site = Type)\r\n\r\n### Add the means (different point colors and shapes for the two sites)\r\nP2 <- P1 + geom_point(data = CO2_mean, aes(x = Treatment, y = uptake_mean, color = Site, shape = Site), size = 2.5, position = position_dodge(width = 0.5))\r\n\r\nP2\r\n\r\n\r\n\r\n\r\nHmm, the two legends (one mapped to “shape” and the other to “color” aesthetic) are not looking good. They shouldn’t have been separated! How can we put them together?\r\nThe solutions\r\nIt’s quite simple actually. There are two ways to fix the problem:\r\n (1) Reset the legend title  (2) Modify the legend keys\r\nWe’ll take a look at them now.\r\n(1) Reset the legend title\r\nThe first way to combine the two legends is to set the same legend title for them, which can be done by specifying the argument name = in the scale_XX_YY() functions. By doing so, ggplot will know that the two legends are indeed the same one and merge them together.\r\n\r\n\r\nP2 + scale_color_brewer(name = \"Site\", palette = \"Set1\") +\r\n  scale_shape_manual(name = \"Site\", values = c(16, 17))\r\n\r\n\r\n\r\n\r\nTip 2. Modify the legend keys\r\nThe second way is more of a manual merging. The idea is that, we can modify the keys of one legend (in this example the boxes) by adding the keys of the other legend (in this example the points) and then hide the useless legend (in this example the legend for the points).\r\nTo do so, use guides(): simply pass a list of additional legend keys to the argument override.aes for the legend you want to modify and specify \"none\" to hide the useless legend:\r\n\r\n\r\nP2 + guides(color = guide_legend(title = \"Site\", override.aes = list(shape = c(16, 17))),\r\n            shape = \"none\")\r\n\r\n\r\n\r\n\r\nSlightly more tedious than the first way, but still quite easy to do!\r\nSummary\r\nTo recap the two ways to merge ggplot legends, we can (1) reset the legend title, or (2) modify the legend keys. Here I only showed you how to do it for two legends, but the principle applies to multiple legends as well. In fact, you can even “selectively” merge certain legends and leave others alone!\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-03-02-post-13-ggplot-legend-tips-series-no4-merging-ggplot-legends/../../homepage_images/Post13.png",
    "last_modified": "2022-03-07T06:57:44-08:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2022-02-05-post-12-ggplot-legend-tips-series-no3-three-ways-to-turn-off-ggplot-legends/",
    "title": "Post #12. ggplot Legend Tips Series No.3: Three ways to turn off the legends in ggplots",
    "description": "Come and learn three handy tips to turn off the legends in ggplots!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-02-05",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nIntroduction\r\nWhen we map a variable to an aesthetic (e.g., color), ggplot will automatically create a legend for it, which is quite convenient. However, sometimes we may want to hide the legend (maybe the information there is redundant to the plot itself). This is actually pretty easy, and in this post I will show you three ways to do so, each for different purposes and with different effects:\r\n (1) Hide the legend for a geom layer  (2) Hide the legend for an aesthetic mapping  (3) Hide all the legends in the figure\r\nLet’s make an example figure first and we’ll walk through the three methods one by one.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nP <- ggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = Treatment, shape = Type), position = position_jitter(width = 0.05)) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP\r\n\r\n\r\n\r\n\r\n(1) Hide the legend for a geom layer\r\nSuppose that we want to remove all the points and keep only the boxes in the legend. We can do so by specifying show.legend = F in the corresponding geom layer (in this case geom_point()):\r\n\r\n\r\nggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = Treatment, shape = Type), position = position_jitter(width = 0.05), show.legend = F) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\n\r\n\r\n\r\nAs you can see, all the points in the legend (including the ones in the boxes) are now gone and only the boxes are left.\r\n(2) Hide the legend for an aesthetic mapping\r\nLooks like the legend for “color” aesthetic in the original figure is a bit redundant: we’ve already known from the main plot that red represents “nonchilled” and blue represents “chilled”. On the other hand, we need the legend for “shape” aesthetic to show the site information (Quebec vs. Mississippi), which is not present in the plot. So is it possible to remove the legend for color but keep the one for shape? Of course it is! Just specify \"none\" for the aesthetic you want to remove (here color) in guides():\r\n\r\n\r\nP + guides(color = \"none\")\r\n\r\n\r\n\r\n\r\nWe’ve removed the legend for color and kept the shape. Great!\r\n(3) Hide all the legends in the figure\r\nThe last method to hide the legend is to specify legend.position = \"none\" in theme() (which literally means no place for the legend). This will remove all the legends in the figure:\r\n\r\n\r\nP + theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nSummary\r\nTo recap, we’ve learned three ways to turn off ggplot legends: (1) by geom layer, (2) by aesthetic mapping, and (3) all legends together. For figures with a single geom layer and aesthetic mapping, all three methods will give the same results. For figures with more complex legends, they will generate different effects and it would be helpful to think about what the legend should look like and use the above principles to customize your legend.\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-02-05-post-12-ggplot-legend-tips-series-no3-three-ways-to-turn-off-ggplot-legends/../../homepage_images/Post12.png",
    "last_modified": "2022-02-06T06:47:12-08:00",
    "input_file": {},
    "preview_width": 768,
    "preview_height": 576
  },
  {
    "path": "posts/2022-02-01-post-11-ggplot-legend-tips-series-no2-working-on-continuous-legends-with-guides/",
    "title": "Post #11. ggplot Legend Tips Series No.2: Working on continuous legends with guides()",
    "description": "In this post, you will learn how to tweak the appearance of continuous legends in ggplots with `guides()`.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-02-01",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nIn this post, we will be working on continuous legends in ggplots with guides(). This is a continuation of the previous post on discrete legends. Check it out here if you haven’t!\r\nContinuous legends\r\nAs mentioned in the previous post, there are two main types of legends in ggplots: discrete and continuous. The former corresponds to the aesthetics mapped to categorical variables (e.g., gender and eye color), whereas the latter corresponds to the aesthetics mapped to continuous variables (e.g., tree height and population density).\r\nInstead of using built-in datasets as before, this time we will create a dataset ourselves by drawing random numbers from normal distributions (with various means but a fixed standard deviation of 1) for x- and y-coordinates, and then we’ll visualize the 2D density distribution in a contour plot.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Random numbers from normal distributions\r\nset.seed(123)\r\nx_mean <- c(-2, 2.4, 1)\r\ny_mean <- c(-1.3, -1, 2)\r\nrand_df <- data.frame(x = unlist(map(x_mean, function(x){rnorm(n = 200, mean = x, sd = 1)})),\r\n                      y = unlist(map(y_mean, function(x){rnorm(n = 200, mean = x, sd = 1)})))\r\n\r\n### Contour plot\r\nP <- ggplot(rand_df) +\r\n  stat_density_2d(aes(x = x, y = y, fill = ..level..), geom = \"polygon\") + \r\n  theme_classic(base_size = 14) +\r\n  coord_fixed(ratio = 1) + \r\n  scale_fill_gradientn(colors = terrain.colors(10))\r\n\r\nP\r\n\r\n\r\n\r\n\r\nHere, the 2D kernel density estimate ..level.., an internal variable computed for the supplied data by stat_density_2d(), was mapped to the “fill” aesthetic as a continuous variable, and the contours were drawn using geom = \"polygon\".\r\nThe guide_colorbar() function\r\nThe actual function in guides() that controls the continuous legends is guide_colorbar(). In this example, we mapped the variable “..level..” to fill, so we will pass fill = guide_colorbar() into guides() and specify the arguments.\r\nThere are several things we can modify in the legend:\r\n (1) Legend title  (2) Legend labels  (3) Legend bar  (4) Legend layout\r\n(1) Legend title\r\nWe can modify the name, position (relative to the legend labels and bar), and text appearance of the title. We can also adjust its horizontal and vertical alignment.\r\n\r\n\r\nP + guides(fill = guide_colorbar(title = \"Density\",  # name\r\n                                 title.position = \"top\",  # position\r\n                                 title.theme = element_text(size = 15, color = \"blue\", face = \"bold\"),  # text appearance\r\n                                 title.hjust = 0.5,  # horizontal alignment\r\n                                 title.vjust = 3))  # vertical alignment\r\n\r\n\r\n\r\n\r\n(2) Legend labels\r\nSimilarly, we can modify the position (relative to the legend bar) and text appearance of the labels as well as adjust the horizontal and vertical alignment. If we want to hide the labels, specify label = F.\r\n\r\n\r\nP + guides(fill = guide_colorbar(label = T,  # show the labels\r\n                                 label.position = \"left\",  # position\r\n                                 label.theme = element_text(size = 12, color = \"brown\", face = \"italic\"),  # text appearance\r\n                                 label.hjust = 0,  # horizontal alignment\r\n                                 label.vjust = 0.5))  # vertical alignment\r\n\r\n\r\n\r\n\r\n(3) Legend bar\r\nWe can change the width and height of the legend bar to make the color gradient more discernible. We can also modify the appearance of bar frame and bar ticks.\r\n\r\n\r\nP + guides(fill = guide_colorbar(barwidth = unit(0.2, \"inches\"),  # bar width\r\n                                 barheight = unit(2, \"inches\"),  # bar height\r\n                                 frame.colour = \"black\",  # bar frame color\r\n                                 frame.linewidth = 2,  # bar frame width\r\n                                 frame.linetype = \"solid\",  # bar frame linetype\r\n                                 ticks = T,  # show the ticks on the bar\r\n                                 ticks.linewidth = 2,  # tick width\r\n                                 ticks.colour = \"red\",  # tick color\r\n                                 draw.ulim = T,  # show the tick at the upper limit\r\n                                 draw.llim = T  # show the tick at the lower limit\r\n                                 ))\r\n\r\n\r\n\r\n\r\n(4) Legend layout\r\nWe can display the legend either horizontally or vertically and flip the bar if needed.\r\n\r\n\r\nP + guides(fill = guide_colorbar(direction = \"horizontal\",  # direction of the legend\r\n                                 reverse = T))  # flip the bar\r\n\r\n\r\n\r\n\r\nSummary\r\nIn this post, we’ve learned how to modify the appearance and layout of legend bar in continuous ggplot legends using the function guides(). Play around with the arguments a bit and I believe you will be able to make a nice legend(s) for your figure!\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-02-01-post-11-ggplot-legend-tips-series-no2-working-on-continuous-legends-with-guides/../../homepage_images/Post11.png",
    "last_modified": "2022-02-04T08:06:26-08:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2022-01-28-post-10-ggplot-legend-tips-series-no1-working-on-discrete-scale-legends-with-guides/",
    "title": "Post #10. ggplot Legend Tips Series No.1: Working on discrete legends with guides()",
    "description": "In this post, you will learn how to tweak the appearance of discrete legends in ggplots with `guides()`.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-01-28",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nWelcome to the first post of 2022—also my 10th ggGallery post! A tiny but meaningful milestone reached!\r\nBackground\r\nLegends are arguably one of the greatest advantages of ggplots over the R base graphics; they are so versatile that you can basically create anything you want. Though, it often takes quite a while to wrap your head around lots of argument details. Also, there are several “players” controlling the legends in ggplots—scale, guide, and theme, adding further complications to the already-complicated system.\r\nInspired by the problems I’ve personally encountered throughout my ggplot learning journey and the questions my friends have asked me about, I’ve decided to launch a blog post series “Legend Tips”, where I dive into the relevant functions/arguments and show how you can make use them to enhance your ggplot legends, as well as provide some handy tips for dealing with frequently-encountered legend issues. I feel that legends would be a great topic to write about, both for myself and for those geeks who use/love ggplots so much as I do!\r\nWe’ll kick this series off by working on discrete legends using the function guides(). Keep reading!\r\nDiscrete legends\r\nThere are two main types of legends in ggplots: discrete and continuous. Discrete legends correspond to the aesthetics mapped to categorical variables (factors), for example, gender and eye color; continuous legends correspond to the aesthetics mapped to continuous variables, for example, tree height and population density. These two legend types can live together in the same figure. They do have many commonalities, but still differ in some detail specifications.\r\nIn this post, we will be using the CO2 dataset, which contains the CO2 uptake rates of 12 grass plant individuals (Echinochloa crus-galli) from two sites Quebec and Mississippi (each 6) measured at several CO2 concentrations. Additionally, half of the plant individuals from each site were chilled overnight before measurement.\r\nLet’s first take a look at the CO2 uptake rates under the two treatments (nonchilled vs. chilled):\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Boxplot of CO2 uptake rates by treatment\r\nP <- ggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = Treatment), position = position_jitter(width = 0.05)) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP\r\n\r\n\r\n\r\n\r\nSeems that nonchilled individuals have higher CO2 uptake rates than chilled ones by visual inspection. Well, this is not the focus of this post. Let’s get to the main topic and see how we can modify the legend using guides().\r\nThe guide_legend() function\r\nThe actual function in guides() that controls the discrete legends is guide_legend(). In this example, we mapped the factor “Treatment” to color, so we will pass color = guide_legend() into guides() and specify the arguments in guide_legend().\r\nThere are several things we can modify in the legend:\r\n (1) Legend title  (2) Legend labels  (3) Legend keys  (4) Legend layout\r\nAdditionally, we can (5) change the default aesthetic mappings and (6) make specific adjustments for multiple legends.\r\n(1) Legend title\r\nWe can modify the name, position (relative to the legend labels and keys), and text appearance of the title. We can also adjust its horizontal and vertical alignment.\r\n\r\n\r\nP + guides(color = guide_legend(title = \"Treatment\",  # name\r\n                                title.position = \"top\",  # position\r\n                                title.theme = element_text(size = 15, color = \"darkgreen\", face = \"bold.italic\"),  # text appearance\r\n                                title.hjust = 0.5,  # horizontal alignment\r\n                                title.vjust = 2))  # vertical alignment\r\n\r\n\r\n\r\n\r\n(2) Legend labels\r\nSimilar to what we’ve done for the title, we can modify the position (relative to the legend keys) and text appearance of the labels as well as adjust the horizontal and vertical alignment. If we want to hide the labels, specify label = F.\r\n\r\n\r\nP + guides(color = guide_legend(label = T,  # show the labels\r\n                                label.position = \"top\",  # position\r\n                                label.theme = element_text(size = 12, color = \"brown\", face = \"italic\"),  # text appearance\r\n                                label.hjust = 0.5,  # horizontal alignment\r\n                                label.vjust = 0.5))  # vertical alignment\r\n\r\n\r\n\r\n\r\n(3) Legend keys\r\nWe can change the width and height of the legend keys. This is especially handy for adjusting the length (width) of line segments.\r\n\r\n\r\nP + guides(color = guide_legend(keywidth = unit(0.25, \"inches\"),\r\n                                keyheight = unit(0.5, \"inches\")))\r\n\r\n\r\n\r\n\r\n(4) Legend layout\r\nWe can display the legend either horizontally or vertically, with legend items separated into several rows and columns. We can also reverse the order of the items.\r\n\r\n\r\nP + guides(color = guide_legend(direction = \"horizontal\",  # direction of the legend\r\n                                nrow = 1,  # number of rows\r\n                                ncol = 2,  # number of columns\r\n                                byrow = T,  # arrange the legend items row by row \r\n                                reverse = T))  # reverse the legend items\r\n\r\n\r\n\r\n\r\n(5) Change default mappings\r\nSuppose that we want to change the default aesthetic mappings, for example, the color of boxes, the shape of the points, and the size of the legend keys. We can do this by passing a list of new aesthetics to the argument override.aes:\r\n\r\n\r\nP + guides(color = guide_legend(override.aes = list(color = c(\"purple\", \"green\"),\r\n                                                    shape = 17,\r\n                                                    size = 1)))\r\n\r\n\r\n\r\n\r\n(6) Multiple legends\r\nRecall that the plant individuals come from two sites Quebec and Mississippi (variable “Type” in the dataset). We can map it to the “shape” aesthetic:\r\n\r\n\r\n### Different shapes for the two sites\r\nP_multi_legend <- ggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = Treatment, shape = Type), position = position_jitter(width = 0.05)) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP_multi_legend\r\n\r\n\r\n\r\n\r\nNo we have two legends in the figure; time to make some changes for them!\r\nHere, we apply guide_legend() individually to color and shape aesthetic and specify the respective arguments. Also, we use an additional argument order to tell ggplot the order in which the legends should be placed.\r\n\r\n\r\nP_multi_legend + guides(color = guide_legend(title.position = \"top\",\r\n                                             title.hjust = 0.5,\r\n                                             label.position = \"top\",\r\n                                             keywidth = unit(0.7, \"inches\"),\r\n                                             keyheight = unit(0.8, \"inches\"),\r\n                                             direction = \"horizontal\",\r\n                                             order = 1),\r\n                        shape = guide_legend(title = \"Site\",\r\n                                             title.hjust = 0.5,\r\n                                             label.position = \"left\",\r\n                                             label.hjust = 0.5,\r\n                                             label.vjsut = 0.5,\r\n                                             keywidth = unit(0.5, \"inches\"),\r\n                                             reverse = T,\r\n                                             override.aes = list(size = 3),\r\n                                             order = 2)\r\n                        )\r\n\r\n\r\n\r\n\r\nThe changes don’t really make sense to me. Of course, it’s just a toy example showing the principles so that you can apply them next time to real-life situations.\r\nWell that’s pretty much for now. But before we finish, it is worth mentioning that many of the arguments in guides() actually overlap with those in another legend function theme() (which will be the topic in another post of this series). So what’s the difference between these two functions? Which one should you use?\r\nSo the main difference is that, the arguments in guides() only affect the legends corresponding to the specified aesthetics, whereas the arguments in theme() will affect all the legends in the figure together. So if you have only one legend, using either function would give the same results. However, if you have multiple legends and you want to make different adjustments for each of them, then guides() is the go-to.\r\nSummary\r\nIn this post, we’ve learned how to modify the appearance and layout of legend items in discrete ggplot legends using the function guides(). We can even customize the legend keys by overriding the default aesthetic mappings. Try playing around with the arguments a bit and I believe you will be able to make a nice legend(s) for your figure!\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-01-28-post-10-ggplot-legend-tips-series-no1-working-on-discrete-scale-legends-with-guides/../../homepage_images/Post10.png",
    "last_modified": "2022-02-04T08:06:26-08:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-12-20-post-9-arrange-multiple-ggplots/",
    "title": "Post #9. Arrange multiple ggplots on one graphic device",
    "description": "Come and learn two methods to arrange multiple ggplots on one graphic device.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-12-20",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nFeel excited to re-blog after taking a one-and-a-half months break. Quite shocked at my rusty writing skills. I think I really need to brush up a bit! This time, I will just do a simple post as a warm-up.\r\nIntroduction\r\nSometimes we have a set of related plots and we would like to arrange them as a single graph. Instead of doing this manually (e.g., using MS PowerPoint), we can actually do it in R. This not only streamlines the figure generation process, but also makes it fully reproducible so that others can get the exact figure as yours with your code.\r\nIn this post, I will show you two methods for laying out multiple ggplots: (1) using the function ggarrange() in the package ggpubr, and (2) using the function draw_plot() and its families in the package cowplot. Let’s jump right in!\r\nMethod 1. Using ggarrange() in the package ggpubr\r\nggarrange() is a convenient function for arranging multiple ggplots on a same graphic device. It also allows the users to make some adjustments, for example, adding panel labels and aligning the plots by axis. Moreover, the package offers a function for adding text annotations to the figure. We’ll go through these features one by one in the following.\r\nTo begin with, let’s create some plots using the famous iris data set:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### 1. A scatterplot of Sepal.Length vs. Sepal.Width\r\nP1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point() + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14)\r\n\r\n### 2. Density plot of Sepal.Length\r\nP2 <- ggplot(iris, aes(x = Sepal.Length, color = Species)) + \r\n  geom_density(aes(y = ..scaled..)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2))\r\n\r\n### 3. Density plot of Sepal.Width\r\nP3 <- ggplot(iris, aes(x = Sepal.Width, color = Species)) + \r\n  geom_density(aes(y = ..scaled..)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2)) +\r\n  coord_flip()\r\n  \r\nP1\r\nP2\r\nP3\r\n\r\n\r\n\r\n\r\n1. Basic layout\r\nNow, say, we would like to place the density plots at the top (for Sepal.Length) and right (for Sepal.Width) of the scatterplot to show their distributions. We can do this by passing the above ggplot objects (P1, P2 and P3) into ggarrange() and specify the layout designs (the numbers of rows and columns along with their widths and heights).\r\n\r\n\r\nlibrary(ggpubr)\r\n\r\nP_arrg_1 <- ggarrange(P2 + labs(x = \"\", y = \"\"),  # remove the axis labels\r\n                      NULL,  # you can add an empty plot using \"NULL\" to create a white space in the graphic device\r\n                      P1, \r\n                      P3 + labs(x = \"\", y = \"\"), \r\n                      nrow = 2,  # split the graphic device into two rows\r\n                      ncol = 2,  # split the graphic device into two columns\r\n                      widths = c(0.65, 0.35),  # the widths of the two columns\r\n                      heights = c(0.35, 0.65),  # the heights of the two rows\r\n                      common.legend = T)  # use the same legend for all plots\r\n\r\nP_arrg_1\r\n\r\n\r\n\r\n\r\n2. Panel labels\r\nAfter getting our basic layout done, we can then add panel labels to the plots by specifying their x and y positions for each individual plots using values in the range of 0 to 1 (e.g., (x, y) = (0, 0) means bottom-left corner of the plot; values outside this range are also allowed and it will draw the labels outside the plot area).\r\n\r\n\r\nP_arrg_2 <- ggarrange(P2 + labs(x = \"\", y = \"\"),  \r\n                      NULL,\r\n                      P1, \r\n                      P3 + labs(x = \"\", y = \"\"), \r\n                      nrow = 2, \r\n                      ncol = 2,\r\n                      widths = c(0.65, 0.35),  \r\n                      heights = c(0.35, 0.65),  \r\n                      common.legend = T,\r\n                      labels = c(\"(a)\", \"\", \"(b)\", \"(c)\"),  # the panel labels for each plot (also an empty string for the \"NULL\" plot)\r\n                      label.x = c(0, 0, 0, 0),  # the x positions of the labels\r\n                      label.y = c(1.1, 1.1, 1.1, 1.1))  # the y positions of the labels\r\n\r\nP_arrg_2\r\n\r\n\r\n\r\n\r\n3. Text annotations\r\nSometimes we might want to add some text annotations to the figure. ggpubr provides a handy function annotate_figure() for this: simply create a grob object using text_grob() (in which you can specify the x and y positions of the text as well as its horizontal and vertical adjustments) and pass it to annotate_figure()\r\n\r\n\r\nP_arrg_3 <- annotate_figure(P_arrg_2,\r\n                            top = text_grob(\"Visualizing Iris Data\", \r\n                                            color = \"blue\", \r\n                                            face = \"bold.italic\", \r\n                                            size = 14, \r\n                                            x = 0.825, \r\n                                            y = 1, \r\n                                            vjust = 10))\r\n\r\nP_arrg_3\r\n\r\n\r\n\r\n\r\n4. Plot alignment\r\nAnother nice functionality of ggarrange() is that it can automatically align the plot panels by axis (vertically and/or horizontally). This is particularly useful when the plots have different margin sizes (e.g., due to different label lengths). Sounds a bit abstract right? Let’s take a look at an example:\r\n\r\n\r\n### A scatterplot of Sepal.Length vs. Sepal.Width\r\nP4 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point(show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14)\r\n\r\n### Density plot of Sepal.Length\r\nP5 <- ggplot(iris, aes(x = Sepal.Length, color = Species)) + \r\n  geom_density(aes(y = ..scaled..), show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") +\r\n  labs(x = NULL, y = NULL) +\r\n  theme_classic(base_size = 14) \r\n\r\n### The y-axes of the two plots are not aligned by default\r\nggarrange(P5, \r\n          P4,\r\n          nrow = 2,\r\n          heights = c(0.3, 0.7))\r\n\r\n\r\n\r\n\r\n\r\n\r\n### The y-axes of the two plots are now vertically aligned\r\nggarrange(P5, \r\n          P4,\r\n          nrow = 2,\r\n          heights = c(0.3, 0.7),\r\n          align = \"v\")\r\n\r\n\r\n\r\n\r\n\r\nMethod 2. Using draw_plot() in the package cowplot\r\nThe package cowplot provides a family of functions for adding plots/images/text to the graphic device. We will see how to make use of them shortly. Again, let’s first create some example plots:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### 1. A scatterplot of Sepal.Length vs. Sepal.Width\r\nP1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point(show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14)\r\n\r\n### 2. Density plot of Sepal.Length\r\nP2 <- ggplot(iris, aes(x = Sepal.Length, color = Species)) + \r\n  geom_density(aes(y = ..scaled..)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2))\r\n\r\n### 3. Density plot of Sepal.Width\r\nP3 <- ggplot(iris, aes(x = Sepal.Width, color = Species)) + \r\n  geom_density(aes(y = ..scaled..), show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2)) +\r\n  coord_flip()\r\n  \r\nP1\r\nP2\r\nP3\r\n\r\n\r\n\r\n\r\n1. Basic layout\r\nThe first method ggarrange works by “cutting” the graphic device into grids of various widths and heights and placing the corresponding plots into those grids.\r\nHere, the second method draw_plot(), is a bit different though. Basically, we will first create a drawing canvas (using the function ggdraw()), which has the x- and y-coordinates of 0 to 1. Next, we use draw_plot() to add the plots to this canvas by specifying their x and y positions using values in the range of 0 to 1 (again, (x, y) = (0, 0) corresponds to the bottom-left corner of the plot) as well as the widths and heights.\r\n\r\n\r\nlibrary(cowplot)\r\n\r\nggdraw() + \r\n  draw_plot(P2 + labs(x = \"\", y = \"\"), x = 0, y = 0.65, width = 0.925, height = 0.3) + \r\n  draw_plot(P1, x = 0, y = 0, width = 0.65, height = 0.65) +\r\n  draw_plot(P3 + labs(x = \"\", y = \"\"), x = 0.65, y = 0, width = 0.3, height = 0.65)\r\n\r\n\r\n\r\n\r\n2. Panel labels\r\nWe can add panel labels to the figure using the function draw_text(), with the same principle as draw_plot():\r\n\r\n\r\nggdraw() + \r\n  draw_plot(P2 + labs(x = \"\", y = \"\"), x = 0, y = 0.65, width = 0.925, height = 0.3) + \r\n  draw_plot(P1, x = 0, y = 0, width = 0.65, height = 0.65) +\r\n  draw_plot(P3 + labs(x = \"\", y = \"\"), x = 0.65, y = 0, width = 0.3, height = 0.65) + \r\n  draw_text(c(\"(a)\", \"(b)\", \"(c)\"), x = c(0.075, 0.075, 0.725), y = c(0.975, 0.675, 0.675)) + \r\n  draw_text(\"Visualizing Iris Data\", x = 0.5, y = 0.975, color = \"blue\", size = 14, fontface = \"italic\") \r\n\r\n\r\n\r\n\r\n3. Add external images\r\nAnother cool thing when working with cowplot is that you can add external images to the graphic device. Use draw_image() to do this (note that you need to have the package magick installed beforehand for this function to work):\r\n\r\n\r\n# install.packages(\"magick\")\r\nggdraw() + \r\n  draw_plot(P2 + labs(x = \"\", y = \"\"), x = 0, y = 0.65, width = 0.925, height = 0.3) + \r\n  draw_plot(P1, x = 0, y = 0, width = 0.65, height = 0.65) +\r\n  draw_plot(P3 + labs(x = \"\", y = \"\"), x = 0.65, y = 0, width = 0.3, height = 0.65) + \r\n  draw_text(c(\"(a)\", \"(b)\", \"(c)\"), x = c(0.075, 0.075, 0.725), y = c(0.975, 0.675, 0.675)) + \r\n  draw_text(\"Visualizing Iris Data\", x = 0.5, y = 0.975, color = \"blue\", size = 14, fontface = \"italic\") +\r\n  draw_image(\"https://archive.ics.uci.edu/ml/assets/MLimages/Large53.jpg\", x = 0.75, y = 0.9, width = 0.1, height = 0.1)\r\n\r\n\r\n\r\n\r\n4. Insets and legends\r\nWe can even do more tricks in the figure, for instance, adding inset plots. Additionally, the package has a function called get_legend(), which allows one to extract the legend from a plot (as a grob object) for further use. See the example below to get an idea of how they work:\r\n\r\n\r\n### 1. A scatterplot of Sepal.Length vs. Sepal.Width\r\nP1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point(show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_continuous(limits = c(3, NA)) + \r\n  scale_y_continuous(limits = c(1, NA))\r\n\r\n### 2. Density plot of Sepal.Length\r\nP2 <- ggplot(iris, aes(x = Sepal.Length, color = Species)) + \r\n  geom_density(aes(y = ..scaled..), show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_continuous(limits = c(3, NA)) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2))\r\n\r\n### 3. Density plot of Sepal.Width\r\nP3 <- ggplot(iris, aes(x = Sepal.Width, color = Species)) + \r\n  geom_density(aes(y = ..scaled..), show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_continuous(limits = c(1, NA)) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2)) +\r\n  coord_flip()\r\n\r\n### 4. Extract the legend from the scatterplot\r\nP1_legned <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point() + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_continuous(limits = c(3, NA)) + \r\n  scale_y_continuous(limits = c(1, NA))\r\n\r\nP_legend <- get_legend(P1_legned)\r\n\r\n### 5. Inset boxplots \r\nP5 <- ggplot(iris, aes(x = Species, y = Sepal.Length, color = Species)) + \r\n  geom_boxplot(show.legend = F, outlier.shape = NA) + \r\n  scale_y_continuous(limits = c(3, NA)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  coord_flip() + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_discrete(labels = c(\"1\", \"2\", \"3\")) + \r\n  theme(axis.title = element_text(color = \"transparent\"),\r\n        axis.text = element_text(color = \"transparent\"),\r\n        axis.line = element_line(color = \"transparent\"),\r\n        axis.ticks = element_line(color = \"transparent\"),\r\n        panel.background = element_blank(),\r\n        plot.background = element_blank())\r\n  \r\nP6 <- ggplot(iris, aes(x = Species, y = Sepal.Width, color = Species)) + \r\n  geom_boxplot(show.legend = F, outlier.shape = NA) + \r\n  scale_y_continuous(limits = c(1, NA)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") +\r\n  theme_classic(base_size = 14) + \r\n  scale_x_discrete(labels = c(\"1\", \"2\", \"3\")) + \r\n  theme(axis.title = element_text(color = \"transparent\"),\r\n        axis.text = element_text(color = \"transparent\"),\r\n        axis.line = element_line(color = \"transparent\"),\r\n        axis.ticks = element_line(color = \"transparent\"),\r\n        panel.background = element_blank(),\r\n        plot.background = element_blank())\r\n\r\n### Put everything together\r\nggdraw() + \r\n  draw_plot(P2 + labs(x = \"\", y = \"\"), x = -0.025, y = 0.65, width = 0.7, height = 0.3) + \r\n  draw_plot(P1, x = 0, y = 0, width = 0.65, height = 0.65) +\r\n  draw_plot(P3 + labs(x = \"\", y = \"\"), x = 0.65, y = 0, width = 0.3, height = 0.65) + \r\n  draw_text(c(\"(a)\", \"(b)\", \"(c)\"), x = c(0.075, 0.075, 0.725), y = c(0.975, 0.675, 0.675)) + \r\n  draw_text(\"Visualizing Iris Data\", x = 0.5, y = 0.975, color = \"blue\", size = 14, fontface = \"italic\") +\r\n  draw_grob(P_legend, x = 0.75, y = 0.75, width = 0.1, height = 0.1) + \r\n  draw_image(\"https://archive.ics.uci.edu/ml/assets/MLimages/Large53.jpg\", x = 0.75, y = 0.85, width = 0.1, height = 0.1) + \r\n  draw_plot(P5, x = 0, y = 0.025, width = 0.65, height = 0.2) + \r\n  draw_plot(P6, x = 0.025, y = 0, width = 0.2, height = 0.65)\r\n\r\n\r\n\r\n\r\nNote that you might need to experiment a bit so that the inset boxplots align with the axes of the main panel. A tip here is to use exactly the same axis settings (labels, ticks, ranges, font size, etc.) for the main panel and the insets as well as the same x and y positions in draw_plot() (so basically the insets will overlay the main panel). After making sure that the main panel and the insets are nicely aligned, you can remove those unnecessary theme elements from the inset plot and then re-draw them on the main panel.\r\nSummary\r\nTo recap, we’ve walked through two methods to arrange multiple ggplots on one graphic device. The first one, ggarrange() in the package ggpubr, is straightforward and easy-to-use. Just pass the individual plots into the function, tell it your layout designs, and you’re done. The package also offers a function for adding text annotations to the figure. So if you simply just want to combine several ggplots together without complex layout, this is perhaps the go-to method and will save you lots of time.\r\nThe second method, draw_plot() and its family functions in the package cowplot, create a drawing canvas that allows you to put any plots/text/images at any places on it. You can also create plot insets as well as extract the legend from the plot to customize its position. This method provides much greater flexibility in terms of plot layout, but at a cost that it might take some time to experiment a bit so that the objects are at the exact positions you want with the desired sizes. This second method is better-suited for complex plot layout, or if you really want to tweak the plot positions to your heart’s content.\r\nWhatever method you use, the most important thing is to think about what your final figure should look like. Maybe sketch it out on a paper first. After getting sort of an idea, you can then proceed to preparing the individual plots, determining their positions and sizes, doing some decorations like adding panel labels and text annotations, and finally fine-tuning the objects before printing it out.\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-12-20-post-9-arrange-multiple-ggplots/../../homepage_images/Post9.png",
    "last_modified": "2021-12-23T05:31:35-08:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "posts/2021-10-01-post-8-pokemon-phylogeny-with-ggdendro/",
    "title": "Post #8. Pokemon phylogeny with ggdendro",
    "description": "Create a Pokemon phylogenetic tree in ggplot with the extension package ggdendro.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-10-01",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nDifferent from previous posts, this time we are going to have a fun one: Pokemon phylogeny in ggplot! Sounds exciting? Let’s go!\r\nBackground\r\nPokemon is arguably one of the most popular computer games around the world. Not only does it inspire our imagination and creativity, but it also reflects our understanding and passion for nature. In fact, Pokemon was one of my favorite games back in my childhood days: I really enjoyed the sheer joy and excitement of collecting, training, and battling.\r\nPokemon represents a fantasy world teeming with a high diversity of amazing creatures distributed over diverse landscapes. There are currently 900ish Pokemon species as of 2021, belonging to 18 different types/functional groups. They roam around the oceans, wander through the mountains, soar in the sky, dwell under the ground, and even live with humans in the urban areas!\r\nEach Pokemon species is associated with a set of stats pertaining to their ability and performance, including HP (Hit Point), Attack, Defense, Special Attack, Special defense, and Speed. The values of these stats may vary among species of different types, and so it would be quite interesting to do some cluster analysis to explore the relationships among Pokemon types in terms of their stats.\r\nIn this post, we are going to construct the phylogeny of Pokemon types based on their stats and visualize the results using a dendrogram in ggplot. Hopefully, we will gain some novel insights into the Pokemon evolutionary history. Without further ado, let’s get started!\r\nGet the data\r\nThe first and most important thing is to get our Pokemon stats data at hand. We will scrape the data from the Pokemon Database and tidy them a bit.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(rvest)\r\n\r\n# Read the webpage contents\r\nPokemon_html <- read_html(\"https://pokemondb.net/pokedex/all\")\r\n\r\n# Extract and tidy the stats table\r\nPokemon_df <- Pokemon_html %>% \r\n  html_element(\"#pokedex\") %>% \r\n  html_table() %>%\r\n  select(-1, -4) %>%\r\n  mutate(Type = str_extract(Type, pattern = \"[:upper:]{1}[:lower:]*\"))\r\n\r\nhead(Pokemon_df)\r\n\r\n\r\n# A tibble: 6 x 8\r\n  Name            Type     HP Attack Defense `Sp. Atk` `Sp. Def` Speed\r\n  <chr>           <chr> <int>  <int>   <int>     <int>     <int> <int>\r\n1 Bulbasaur       Grass    45     49      49        65        65    45\r\n2 Ivysaur         Grass    60     62      63        80        80    60\r\n3 Venusaur        Grass    80     82      83       100       100    80\r\n4 VenusaurMega V~ Grass    80    100     123       122       120    80\r\n5 Charmander      Fire     39     52      43        60        50    65\r\n6 Charmeleon      Fire     58     64      58        80        65    80\r\n\r\nHierarchical cluster analysis\r\nNow we have the data ready, our next step is to perform hierarchical cluster analysis on the stats data to reveal the relationships among Pokemon types. Since the stats are measured in different units, we will first standardize them and compute the mean (of the standardized values) for each stat by Pokemon type. After that, we will create a dissimilarity matrix of the stats means based on Euclidean distance and use hclust() to do the hierarchical cluster analysis using the complete linkage method.\r\n\r\n\r\n# Standardize the stats and compute the stats means by type\r\nPokemon_df_HC <- Pokemon_df %>% \r\n  mutate(across(HP:Speed, ~scale(.x))) %>%\r\n  group_by(Type) %>% \r\n  summarise(across(HP:Speed, ~mean(.x)))\r\n\r\n# Hierarchical cluster analysis  \r\nPokemon_clust <- Pokemon_df_HC[, -1] %>% \r\n  dist(., method = \"euclidean\") %>%\r\n  hclust(., method = \"complete\")\r\n\r\nPokemon_clust$labels <- Pokemon_df_HC$Type\r\n\r\n\r\n\r\nCreate the dendrogram\r\nSo far so good. Time to get down to our main topic today: creating the dendrogram! There are two main extension packages for visualizing tree-like objects in ggplot: ggdendro and ggtree. ggdendro is an easy-to-use package with simple user-friendly functions, allowing for quick and basic visualization of cluster data. On the other hand, ggtree is a more comprehensive and versatile package geared towards sophisticated visualization and annotation of phylogenetic trees. It has a lot of nice features to offer, but requires more time and effort to really get the hang of the details.\r\nTo keep things simple, we will use ggdendro to visualize our cluster results. The function dendro_data() in the package extracts the line segments and labels from the cluster objects and returns the data as a list of data frames. These data frames can then be used for plotting as well as customizing the appearance of the dendrogram, for example, changing the colors of the terminal branches and setting the labels of the terminal nodes.\r\n\r\n\r\nlibrary(ggdendro)\r\n\r\n# Extract the cluster data\r\nPokemon_dendro <- Pokemon_clust %>% \r\n  as.dendrogram() %>%\r\n  dendro_data(., type = \"rectangle\")\r\n\r\n# Extract the terminal branches\r\nPokemon_dendro_tb <- segment(Pokemon_dendro) %>%\r\n                 filter(yend == 0) %>%\r\n                 left_join(label(Pokemon_dendro)[, c(1, 3)], by = \"x\")\r\n\r\n# The color palette for the Pokemon types\r\ntype_cols_pal <- c(\"Normal\" = \"#A8A77A\", \r\n  \"Fire\" = \"#EE8130\", \r\n  \"Water\" = \"#6390F0\", \r\n  \"Electric\" = \"#F7D02C\",\r\n  \"Grass\" = \"#7AC74C\",\r\n  \"Ice\" = \"#96D9D6\",\r\n  \"Fighting\" = \"#C22E28\",\r\n  \"Poison\" = \"#A33EA1\",\r\n  \"Ground\" = \"#E2BF65\",\r\n  \"Flying\" = \"#A98FF3\",\r\n  \"Psychic\" = \"#F95587\",\r\n  \"Bug\" = \"#A6B91A\",\r\n  \"Rock\" = \"#B6A136\",\r\n  \"Ghost\" = \"#735797\",\r\n  \"Dragon\" = \"#6F35FC\",\r\n  \"Dark\" = \"#705746\",\r\n  \"Steel\" = \"#B7B7CE\",\r\n  \"Fairy\" =  \"#D685AD\")\r\n\r\n# Create the dendrogram\r\nPokemon_dg <- ggplot() +\r\n  geom_segment(data = segment(Pokemon_dendro), \r\n               aes(x = x, y = y, xend = xend, yend = yend)) +\r\n  geom_segment(data = Pokemon_dendro_tb, \r\n               aes(x = x, y = y, xend = xend, yend = yend, color = label),\r\n               show.legend = F) +\r\n  geom_point(data = label(Pokemon_dendro), \r\n             aes(x = x, y = y, label = label, colour = label, hjust = 0), \r\n             size = 3, show.legend = F) +\r\n  geom_text(data = label(Pokemon_dendro), \r\n            aes(x = x, y = y-0.1, label = label, colour = label, hjust = 0), \r\n            size = 3, show.legend = F) + \r\n  coord_flip(clip = \"off\") +  # Make the tree horizontal\r\n  scale_y_reverse(expand = c(0.12, 0)) +  # Place the tree root on the left\r\n  scale_color_manual(values = type_cols_pal) + \r\n  theme_void()\r\n  \r\nPokemon_dg\r\n\r\n\r\n\r\n\r\nAdd Pokemon images\r\nThe above dendrogram looks pretty neat, but we can further spice it up a bit! Guess what ingredients we are going to add to the plot? Yes, The Pokemon images!\r\nWe will retrieve the Pokemon images representative of each type from the Pokemon Database and add them to the terminal nodes using the extension package ggtext. I have done a post on how to use ggtext before. Check it out here if interested!\r\n\r\n\r\nlibrary(ggtext)\r\n\r\n# HTML <img> tags\r\nPokemon_images <- c(\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/dragonite.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/venusaur.png' height = '13' width = '15'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/blastoise.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/articuno.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/arbok.png' height = '17' width = '19'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/clefable.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/gengar.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/alakazam.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/umbreon.png' height = '18' width = '20'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/cramorant.png' height = '18' width = '20'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/pikachu.png' height = '25' width = '27'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/charizard.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/steelix.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/butterfree.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/persian.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/hitmonchan.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/dugtrio.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/onix.png' height = '15' width = '17'/>\")\r\n\r\n# Add the images to the dendrogram\r\nPokemon_dg + \r\n  scale_x_continuous(breaks = c(1:8, 9.1, 10, 11.2, 12:18), labels = Pokemon_images, position = \"top\") +\r\n  theme(axis.text.y.right = element_markdown(vjust = 0.6)) \r\n\r\n\r\n\r\n\r\nQuite a few interesting points from the dendrogram:\r\nOverall, there seem to be two major groups of Pokemon types: Rock ~ Steel and Fire ~ Dragon.\r\nRock, Ground, and Fighting form a monophyletic group: These types are characterized by ground-dwelling species.\r\nFire and Electric are closely related to each other, so are Ice and Water: This makes much sense as fire and electric are both related to heat and energy, and ice and water are just the same substance of different phases.\r\nFairy and Ghost are paired together: Both of them consist of elusive and enigmatic species. In fact, they are pretty much two sides of the same coin—one represents “bright/positive” and the other represents “dark/negative”.\r\nSurprisingly, Grass and Bug are quite distant from each other despite their (presumably) strong trophic connections: This is perhaps because one is a primary producer and the other is a consumer, thus having distinct stat properties.\r\nSummary\r\nTo recap what we have done, we first got the Pokemon stats data from the website and tidied them. Next, we standardized the stats data and performed hierarchical cluster analysis on the mean stats of Pokemon types. Finally, we visualized the cluster results in ggplot using the package ggdendro and added some Pokemon images to the terminal nodes of the dendorgram using the package ggtext.\r\nAt this point, you might have seen that we used quite a few different methods and techniques throughout the process before arriving at our final product. In fact, this is the essence of data science workflow: starting with data collection and import, followed by data tidying and transformation, then data modeling and visualization, and finally data communication, which is just the post you are reading right now!\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-10-01-post-8-pokemon-phylogeny-with-ggdendro/../../homepage_images/Post8.png",
    "last_modified": "2021-09-30T19:55:03-07:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 960
  },
  {
    "path": "posts/2021-09-11-post-7-customize-the-axis-scales-for-individual-facets/",
    "title": "Post #7. Customize the axis scales for individual ggplot facets",
    "description": "Come and learn how to customize the axis scales (axis limits, tick breaks, and tick labels) for individual ggplot facets!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-09-11",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nWelcome to my new post! I have been a bit busy lately and I feel so excited to come back to my blog.\r\nIn this post, I will share with you some useful tips for adjusting the axis scales for individual panels when you’re using ggplot facets. I have been dealing with this problem several times before (and I guess you too!), and so I think this would be a great topic to write about. Keep reading and you will surely get something out of it!\r\nThe problem\r\nFacets are quite useful for displaying data by category/level/class. However, sometimes you might have facets in different units, and this might cause some problems for the appearances of the panels (e.g., the panels with large absolute axis range may “distort” the ones with small absolute range). Although you can set scales = \"free_XXX\" to allow the axes to vary by panel, it might not be as satisfying as you think, and this would require further adjustments of the individual facet panels.\r\nWe will be using the airquality dataset as our example data. This dataset contains the daily measurements of four environmental variables, including ozone concentration, solar radiance, temperature, and wind speed, in New York from May to September 1973.\r\nFirst, let’s visualize these four variables at once using facets:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Convert the original dataframe to long format\r\nair_df <- airquality %>% pivot_longer(cols = 1:4, \r\n                                      names_to = \"Env_vars\", \r\n                                      values_to = \"Values\")\r\n\r\n# Plot   \r\nP_air <- ggplot(air_df, aes(x = Day, y = Values, color = as.factor(Month), group = Month)) + \r\n  geom_point() + \r\n  geom_line() +\r\n  labs(x = \"Day of month\", y = NULL) +\r\n  scale_color_brewer(palette = \"Set1\", \r\n                     labels = c(\"May\", \"June\", \"July\", \"August\", \"September\")) +\r\n  facet_wrap(~Env_vars, \r\n             nrow = 2, \r\n             scales = \"free_y\",\r\n             strip.position = \"left\", \r\n             labeller = as_labeller(c(Temp = \"Temperature (°F)\", \r\n                                      Solar.R = \"Solar radiace (lang)\",\r\n                                      Wind = \"Wind (mph)\",\r\n                                      Ozone = \"Ozone (ppb)\"))) + \r\n  theme(strip.background = element_blank(),\r\n        strip.placement = \"outside\",\r\n        legend.position = \"top\",\r\n        legend.title = element_blank())\r\n\r\nP_air\r\n\r\n\r\n\r\n\r\nHmm, the y-axes of the panels look fine, but what if we want to do something further (e.g., change the axis ranges or tick breaks)? Can we modify the axis scales for the individual facets to our heart’s content? Of course we can. Continue reading!\r\nThe solutions\r\nCustomizing the axis scales in ggplot facets is definitely not an easy task, and sometimes it requires a lot of trial and error. There are two ways you can do for it:\r\n Method 1. Manual fix: adjusting the axis scales step by step  Method 2. Quick fix: setting the axis scales using extension package\r\nI’ll go through them in more detail in the following section.\r\nMethod 1. Manual fix\r\nThe basic idea of this method is to identify the individual facets and apply specific scale arguments to each of them. This method includes three main steps: (1) Adjust the limits, (2) Adjust the breaks, and (3) Adjust the labels.\r\nStep (1) - Adjust the limits\r\nWe first start by extracting the current axis limits of each facet panel:\r\n\r\n\r\n# Get a vector of the levels of the facet variable \r\nvar_names <- air_df$Env_vars %>% unique() %>% sort()\r\n\r\n# Extract the limits of each facet panel \r\nfacet_lims <- map(1:4, function(x){\r\n  lims <- ggplot_build(P_air)$layout$panel_scales_y[[x]]$range$range\r\n  set_names(lims, c(\"Lower\", \"Upper\"))\r\n  }) %>%\r\n  `names<-`(var_names) %>%\r\n  bind_rows(.id = \"Facet\")\r\n\r\nfacet_lims\r\n\r\n\r\n# A tibble: 4 x 3\r\n  Facet   Lower Upper\r\n  <chr>   <dbl> <dbl>\r\n1 Ozone     1   168  \r\n2 Solar.R   7   334  \r\n3 Temp     56    97  \r\n4 Wind      1.7  20.7\r\n\r\n\r\nNext, we will create a function using a series of if else statements to “gradually” identify the individual facet panels based on their current limits, and then set the new limits for each of them. This function will later be passed to the breaks = argument in scale_y_continuous() to draw new limits. (I know this is somewhat abstract; see the below code to get a better idea of how this works!)\r\nAlso note that in the if else statements, you can pick any number you like in the logical condition parts, as long as it can distinguish among the facets. For example, you can use max(x) < 50 or max(x) < 30 to identify the “Wind” panel. Though, I would suggest using the midpoint between the upper limits of the two “closest” panels to avoid potential errors (e.g., max(x) < 50 would be better than max(x) < 30 for distinguishing between “Wind” and “Temp” panel).\r\n\r\n\r\nlimits_fun <- function(x) {\r\n  if (max(x) < 50) {  # This will identify the current \"Wind\" panel\r\n    c(0, 30)  # New limits for the \"Wind\" panel\r\n  } else if (max(x) < 150) {  # This will identify the current \"Temp\" panel\r\n    c(40, 120)  # New limits for the \"Temp\" panel\r\n  } else if (max(x) < 250) {  # This will identify the current \"Ozone\" panel\r\n    c(0, 200)  # New limits for the \"Ozone\" panel\r\n  } else {  # This will identify the current \"Solar.R\" panel (the \"leftover\" panel)\r\n    c(0, 350)  # New limits for the \"Solar.R\" panel\r\n  }\r\n}\r\n\r\nP_air + scale_y_continuous(limits = limits_fun)\r\n\r\n\r\n\r\n\r\nWe have changed the axis limits, and now we will proceed to our second step: change the breaks.\r\nStep 2. Change the breaks\r\nSimilar to what we’ve done in the first step, we will create another function, again using a series of if else statements, to “gradually” identify the individual facet panels based on their current tick breaks, and then set the new breaks for each of them.\r\n\r\n\r\nbreaks_fun <- function(x) {\r\n  if (max(x) < 50) {\r\n    seq(0, 30, 5)  # New tick breaks for the \"Wind\" panel\r\n  } else if (max(x) < 150) {\r\n    seq(40, 120, 20)  # New tick breaks for the \"Temp\" panel\r\n  } else if (max(x) < 250) {\r\n    seq(0, 200, 40)  # New tick breaks for the \"Ozone\" panel\r\n  } else {\r\n    seq(0, 350, 50)  # New tick breaks for the \"Solar.R\" panel\r\n  }\r\n}\r\n\r\nP_air + scale_y_continuous(limits = limits_fun,\r\n                           breaks = breaks_fun)\r\n\r\n\r\n\r\n\r\nStep 3. Change the labels\r\nThis step is optional; if you’ve already set the new breaks, then the tick labels should automatically get set too. However, in some cases, you might want change the labels, and you can do it using the same principle as you used in the first two steps. Just make sure the numbers of labels you supply to each facet should match the numbers of tick breaks in that facet. (Here I’ll show you how to set new tick labels but just for demonstration purpose, and so the tick labels might not make any sense!)\r\n\r\n\r\nlabels_fun <- function(x) {\r\n  if (max(x) < 50) {\r\n    letters[1:7]  # New tick labels for the \"Wind\" panel\r\n  } else if (max(x) < 150) {\r\n    letters[8:12]  # New tick labels for the \"Temp\" panel\r\n  } else if (max(x) < 250) {\r\n    letters[13:18]  # New tick labels for the \"Ozone\" panel\r\n  } else {\r\n    letters[19:26]  # New tick labels for the \"Solar.R\" panel\r\n  }\r\n}\r\n\r\nP_air + scale_y_continuous(limits = limits_fun,\r\n                           breaks = breaks_fun,\r\n                           labels = labels_fun)\r\n\r\n\r\n\r\n\r\nThis “manual” method is a bit tedious to be honest, but it does let you know how ggplot deals with the axis scales under the hood. However, who on earth would have the extra time to do this kind of manual adjustments? This is when the second method comes in handy!\r\n(2) Quick fix\r\nThe package ggh4x has many nice functions for working with facets (you can install it from GitHub). Among these, the function facetted_pos_scales() allows users to directly set the scale arguments for each individual facets by name.\r\n\r\n\r\n# devtools::install_github(\"teunbrand/ggh4x\")\r\nlibrary(ggh4x)\r\n\r\nP_air + facetted_pos_scales(\r\n  y = list(Env_vars == \"Ozone\" ~ scale_y_continuous(limits = c(0, 200), \r\n                                                    breaks = seq(0, 200, 40),\r\n                                                    labels = letters[13:18]),\r\n           Env_vars == \"Solar.R\" ~ scale_y_continuous(limits = c(0, 350),\r\n                                                      breaks = seq(0, 350, 50),\r\n                                                      labels = letters[19:26]),\r\n           Env_vars == \"Temp\" ~ scale_y_continuous(limits = c(40, 120), \r\n                                                   breaks = seq(40, 120, 20),\r\n                                                   labels = letters[8:12]),\r\n           Env_vars == \"Wind\" ~ scale_y_continuous(limits = c(0, 30), \r\n                                                   breaks = seq(0, 30, 5),\r\n                                                   labels = letters[1:7]))\r\n      )\r\n\r\n\r\n\r\n\r\nDone! Exact output. Easy-peasy!\r\nSummary\r\nIn this post, we have walked through two ways to customize the axis scales for individual ggplot facets. Facets are really useful, but sometimes they’re also difficult to work with, and it really takes time to get your head around. Fortunately, there are many extension packages designed to make ggplots more user-friendly and versatile, and people in the R community have also been discussing all kinds of ggplot-related issues. Simply search on the net and you’ll find the solutions to your problems out there!\r\nHope this post helps and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-09-11-post-7-customize-the-axis-scales-for-individual-facets/../../homepage_images/Post7.png",
    "last_modified": "2021-09-14T18:34:15-07:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 768
  },
  {
    "path": "posts/2021-08-02-post-6-play-good-music-for-your-data-violin-plots-with-ggplot/",
    "title": "Post #6. Play good music for your data - violin plots with ggplot",
    "description": "Visualize data distributions using violin plots with ggplot.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-08-02",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nIntroduction\r\nData exploration is the very first step for any data analysis project, allowing us to grasp an idea of what our data look like before proceeding to further analyses. We can use some simple summary statistics (e.g., mean, SD, the five-number summary 1) to do so. Alternatively, we can plot the data to really show their “true colors” and potentially uncover some interesting/weird patterns (to see is to believe right?!). This is especially handy for large datasets where it is difficult to inspect each data point.\r\nThere are quite a few types of graphs we can use to visualize the distribution of (continuous) data. In this post, I will show you some commonly-used graphs, first the basic ones (strip plot, box plot, and point-range plot), and then to our focus—the violin plot.\r\nSome basic visualizations for data distributions\r\nWe will be using the crabs dataset from the MASS package as our example data. This dataset contains five morphological measurements (frontal lobe size, rear width, carapace length, carapace width, and body depth) of 50 purple rock crab (Leptograpsus variegatus) individuals for each of the two color forms (blue and orange) and sexes (male and female). An interesting question here is whether the carapace width, an important indicator for individuals’ growth and development, differ between sexes for the two color forms. Before conducting formal statistical tests, it would be great to first visualize the carapace width by color form and sex so that we can get an idea of what the data look like.\r\nLet’s begin with some basic and most-commonly used graphs:\r\n (1) Strip plot  (2) Box plot  (3) Point-range plot\r\n(1) Strip plot\r\nA strip plot is no more than drawing the raw data points along the axis to show their distribution and range. In fact, it is simply a special version of scatterplot where one dimension (usually x-axis) is fixed to one or a few positions.\r\n\r\n\r\nlibrary(MASS)  # For the \"crabs\" dataset\r\nlibrary(tidyverse)\r\n\r\ncrabs_df <- crabs %>%\r\n  select(sp, sex, CW) %>%\r\n  transmute(color = case_when(sp == \"B\" ~ \"Blue\",\r\n                              sp == \"O\" ~ \"Orange\"),\r\n            sex = case_when(sex == \"M\" ~ \"Male\",\r\n                            sex == \"F\" ~ \"Female\"),\r\n            carapace_width = CW)\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_point(position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.7)) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nHere I use position_jitterdodge() to dodge the points for the two sexes within each color form so that they won’t overlap with each other at the same x-axis position, and also to jitter the points (i.e., adding some random noise) within each sex to prevent overplotting (points lying on top of each other).\r\nAs you can see, blue males tend have a wider carapace than blue females, whereas orange males and females seem to have similar carapace widths.\r\n(2) Box plot\r\nA common alternative to strip plot is the box plot, where the data are displayed as a box and two whiskers based on the five-number summary (remember this term in the “Introduction”?).\r\n\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_boxplot(position = position_dodge(width = 0.7), width = 0.5) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nWe can see that the median carapace width of blue males is larger than that of the blue females, while the opposite is true for the orange form.\r\n(3) Point-range plot\r\nYet another alternative to strip plot is the point-range plot, where the data are displayed as a mean and some measure of uncertainty (e.g., SD, SE, and confidence interval).\r\n\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = \"mean_se\", position = position_dodge(width = 0.5)) +  # The bars represent SE \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nApparently, blue males are on average wider than blue females and vice versa for the orange form.\r\n\r\nViolin plot\r\nNow let’s get down to our main topic—the violin plot. A violin plot displays the kernel density estimates of the data as two symmetrical probability curves, forming a violin-like area and hence the name.\r\nA violin plot provides more information than a box plot or a point-range plot does, as it shows the full distribution of the data rather than just a few summary statistics. In particular, when the data distribution is bi-modal or multi-modal (i.e., more than one peak), a violin plot can show the positions of the peaks as well as their relative magnitudes, which are otherwise not revealed by a box plot or a point-range plot.\r\nThere is a trade-off though. Depending on the data, the probability curves can actually be quite curly and you might want to dispose of the “malformed” violin if that’s the case.\r\nTo make a violin plot with ggplot, simply use the ggplot2 built-in function geom_violin():\r\n\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), width = 0.5) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nThis violin plot looks a bit plain. We can modify some arguments in geom_violin() to make it more appealing. For example, we can turn off the trim argument to allow for full density curves beyond the data range, add lines inside the violins to denote the quartiles, and fill the empty violins with some colors to make them more “concrete”.\r\n\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.5,\r\n              size = 1,  # Thicker lines\r\n              trim = F,  # Don't trim off the tails of density curves beyond data range\r\n              scale = \"area\",  # All violins have the same area size \r\n              draw_quantiles = c(0.25, 0.5, 0.75),  # Add quartiles to the violins\r\n              fill = alpha(\"grey\", 0.3)) +  # Fill the violins\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nAn important aspect of a violin plot is the density curves, determined by two factors: bandwidth and kernel (this is a bit mathy; see this post for details if interested). Bandwidth is the easier (and also straightforward) one to adjust. It is a real positive number and controls the smoothness of the density estimates: a smaller value gives a “spikier” curve, whereas a larger value results in a “smoother” look.\r\n\r\n\r\nmap(c(0.5, 1, 2, 5), function(bw_values){  # Pass a set of bandwidth values to the ggplot\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.5,\r\n              size = 1,  \r\n              trim = F,\r\n              scale = \"area\",\r\n              draw_quantiles = c(0.25, 0.5, 0.75),\r\n              fill = alpha(\"grey\", 0.3),\r\n              bw = bw_values) +  # Control the bandwidth\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = paste0(\"Bandwidth = \", bw_values)) + \r\n  guides(color = \"none\") +\r\n  theme_classic(base_size = 12) + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n})\r\n\r\n\r\n\r\n\r\nDepending on the nature of the data, you might want to try out a few bandwidth values and see which one best captures the data distribution. Or, you can just do nothing and let ggplot pick a default one for you!\r\n\r\nVariants of violin plots\r\nLet’s now go a bit further and take a look at some cool variants of violin plots.\r\n(1) Overlay other plot types\r\nWe can add strip plots, box plots, or point-range plots to the violin plots to show more information about the data.\r\n\r\n\r\n### Violin plot + strip plot\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.7,\r\n              size = 1,\r\n              trim = F,\r\n              scale = \"area\") +\r\n  geom_point(position = position_jitterdodge(jitter.width = 0.05, dodge.width = 0.7), show.legend = FALSE) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n### Violin plot + box plot\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.7,\r\n              size = 1,\r\n              trim = F,\r\n              scale = \"area\") +\r\n  geom_boxplot(position = position_dodge(width = 0.7), width = 0.2, show.legend = FALSE) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n### Violin plot + point-range plot\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.7,\r\n              size = 1,\r\n              trim = F,\r\n              scale = \"area\") +\r\n  stat_summary(geom = \"pointrange\", \r\n               fun = mean, \r\n               fun.min = function(x) mean(x) - sd(x),  # The bars represent SD\r\n               fun.max = function(x) mean(x) + sd(x),\r\n               position = position_dodge(width = 0.7), show.legend = FALSE) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\n(2) Hybrid violin plot\r\nWhen there are two groups (violins) within each x-axis category (e.g., “male” and “female” in this example), we can halve the two violins and combine them into one hybrid violin for a better comparison.\r\nThere is no direct function or argument to create a hybrid violin plot, and so we would need to code it a bit: first compute the kernel density estimates manually, then do some data manipulations, and finally map the processed data to the plot. I have wrapped these steps into a function called geom_hybrid_violin(). See the comments in the below code chuck for what the functions actually does under the hood!\r\nBy the way, there is also a function called geom_split_violin() on stackoverflow. It is basically an extended geom of the original geom_violin(), built using the ggproto system (quite an advanced topic; saved for future posts!). You can simply copy and paste the code into your R session and it is ready for use.\r\n\r\n\r\n### Create the function \"geom_hybrid_violin()\"\r\ngeom_hybrid_violin <- function(data,  # A dataset you would like to visualize\r\n                               x_var,  # An unquoted name of the (categorical) variable for the x-axis \r\n                               hybrid_var, # An unquoted name of the (binary) variable of which the two levels are to be compared with each other\r\n                               y_var,  # An unquoted name of the (continuous) variable of which the distribution is to be visualized \r\n                               bandwidth = NULL,  # A real positive number specifying the bandwidth for kernel density estimates\r\n                               width_adj = 1,  # A real positive number multiplied with the density estimates to adjust the width of the violins (1 means no adjustment)\r\n                               x_lab,  # A quoted string as x-axis label\r\n                               y_lab){  # A quoted string as y-axis label\r\n  \r\n  # Step 1. Quote the arguments\r\n  x_var <- enquo(x_var)\r\n  hybrid_var <- enquo(hybrid_var)\r\n  y_var <- enquo(y_var)\r\n  \r\n  # Step 2. Convert the x_var and hybrid_var into factors\r\n  # The \"!!\" (pronounced \"bang bang\") symbol is to unquote the variables so that they can be evaluated in a non-standard way \r\n  data_fct <- data %>% mutate(!!x_var := as.factor(!!x_var),\r\n                              !!hybrid_var := as.factor(!!hybrid_var))\r\n  \r\n  # Step 3. Get the levels of the x_var and hybrid_var\r\n  x_var_levels <- select(data_fct, !!x_var) %>% pull() %>% levels()\r\n  hybrid_var_levels <- select(data_fct, !!hybrid_var) %>% pull() %>% levels()\r\n  \r\n  # Step 4. Compute kernel density estimates by x_vars and hybrid_var\r\n  dens_df <- data_fct %>% \r\n    group_by(!!x_var, !!hybrid_var) %>%\r\n    summarize(prob_raw = ifelse(is.null(bandwidth), list(density(!!y_var)$y), list(density(!!y_var, bw = bandwidth)$y)),\r\n              y = ifelse(is.null(bandwidth), list(density(!!y_var)$x), list(density(!!y_var, bw = bandwidth)$x))) %>%\r\n    unnest(cols = c(prob_raw, y)) %>%\r\n    mutate(prob_adj = prob_raw*width_adj,  # Multiply the original density estimates by a constant to adjust the violin width\r\n           prob_flip = ifelse(!!hybrid_var == hybrid_var_levels[1], prob_adj*-1, prob_adj),  # Flip the curve of the density estimates for the level on the right-hand side\r\n           prob_final = prob_flip + as.numeric(!!x_var))  # Spread out the density estimates for each level of x_var according to the order in which they appear along the x-axis\r\n\r\n  # Step 5. Plot the data using geom_polygon\r\n  p <- ggplot(data = dens_df, aes(x = prob_final, y = y, \r\n                                  color = !!hybrid_var, \r\n                                  fill = after_scale(alpha(color, 0.8)), \r\n                                  group = interaction(!!x_var, !!hybrid_var))) +\r\n    geom_polygon() + \r\n    scale_color_brewer(palette = \"Set1\") +\r\n    scale_fill_brewer(palette = \"Set1\") +\r\n    scale_x_continuous(limits = c(0.5, length(x_var_levels)+0.5), breaks = 1:length(x_var_levels), labels = x_var_levels) +  # Specify the positions along the x-axis at which the violins are displayed\r\n    labs(x = x_lab, y = y_lab) + \r\n    theme_classic() + \r\n    theme(legend.title = element_text(hjust = 0.5))\r\n\r\nreturn(p)\r\n  \r\n}\r\n\r\n### Pass the data to the function and specify the arguments\r\ngeom_hybrid_violin(data = crabs_df, \r\n                   x_var = color, \r\n                   hybrid_var = sex, \r\n                   y_var = carapace_width,\r\n                   bandwidth = 2,\r\n                   width_adj = 3,\r\n                   x_lab = \"Color form\",\r\n                   y_lab = \"Carapace width (mm)\")\r\n\r\n\r\n\r\n\r\n(3) Wilkinson dot plot and beeswarm plot\r\nInstead of showing the data distribution as curves and areas, we can use dots to represent the density estimates. This kind of plot is called a “Wilkinson dot plot” or a “beeswarm plot” (it does look like a swarm of bees!). In fact, it is a modified strip plot and you can think of it as the “discrete” version of the violin plot.\r\nThere are two ways for creating a Wilkinson dot plot or a beeswarm plot: one is using the ggplot2 built-in function geom_dotplot(), and the other is the geom_beeswarm() or geom_quasirandom() from the extension package ggbeeswarm.\r\n\r\n\r\n### geom_dotplot()\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex, fill = sex)) + \r\n  geom_dotplot(binaxis = \"y\", stackdir = \"center\", position = position_dodge(width = 0.8), dotsize = 0.7) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  scale_fill_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = \"geom_dotplot()\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n### geom_beeswarm()\r\n# install.packages(\"ggbeeswarm\")\r\nlibrary(ggbeeswarm)\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex, fill = sex)) + \r\n  geom_beeswarm(cex = 2.5, dodge.width = 0.8, size = 2) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = \"geom_beeswarm()\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n### geom_quasirandom() with bandwidth = 0.1\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex, fill = sex)) + \r\n  geom_quasirandom(bandwidth = 0.1, nbins = 100, cex = 2, dodge.width = 0.8, method = \"smiley\") +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = \"geom_quasirandom() \\n (bandwidth = 0.1)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n### geom_quasirandom() with bandwidth = 2\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex, fill = sex)) + \r\n  geom_quasirandom(bandwidth = 2, nbins = 100, cex = 2, dodge.width = 0.8, method = \"smiley\") +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = \"geom_quasirandom() \\n (bandwidth = 2)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n\r\n\r\n\r\nSimilar to geom_violin(), you can specify the bandwidth in geom_quasirandom() to adjust the “smoothness” of the swarm.\r\nSummary\r\nIn this post, we have seen some basic graph types as well as the violin plot and its extensions for visualizing data distributions. Violin plots can be quite useful for conveying the message in the data; however, they are much less popular in scientific communication (compared with strip plots or box plots). Believe it or not, I didn’t even hear of “violin plot” until I started learning ggplots!\r\nYou can make a plain violin plot more informative by combining other graph types to display different aspects of the data. Just don’t overdo it as the information can be too rich and perhaps obscured. Experiment a bit and find the right balance. Your data will appreciate you if you play a beautiful piece of music for them!\r\nThat’s it for this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\nThe five-number summary is set of descriptive statistics consisting of the minimum value, the lower quartile (Q1), the median (Q2), the upper quartile (Q3), and the maximum value.↩︎\r\n",
    "preview": "posts/2021-08-02-post-6-play-good-music-for-your-data-violin-plots-with-ggplot/../../homepage_images/Post6.png",
    "last_modified": "2021-08-11T06:57:41-07:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-07-10-post-5-awesome-text-display-with-ggtext/",
    "title": "Post #5. Awesome text displays with ggtext",
    "description": "Enhance text displays in your ggplots with the extension package ggtext!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-07-10",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nOverview\r\nText is one of the fundamental elements in a graph. A well-designed text display can make your plot look pleasant and more informative. ggplot2 provides many functions and arguments for text manipulation (appearance, layout, annotation, etc.), which are already more than enough most of the time. But if you want to do something further, the extension package ggtext has more to offer. This package has several added functionalities currently not implemented in ggplot2, the most important being that it supports the use of Markdown/HTML/CSS, which offers greater flexibility in text rendering. So in this post, I will be showing you some of these cool features. Ready? Let’s get started!\r\nDate preparation\r\nWe will be using the data from the International Biology Olympiad website. IBO is arguably the largest annual biology event for high school students. Each year, a member country will host the competition, and students around the world will gather to participate in this great event. Since the very first IBO held in 1990 in the Czech Republic, more countries have joined as members, and it would be interesting to see how the numbers of participating students changed over the past three decades.\r\nTo do so, we will first scrap the data from the website using the package rvest, and then do some data manipulation for later plotting use. Since web-scraping is not the main focus of this post, I will not go into the details. If interested, you can visit the package’s website for more information. There are also plenty of learning resources out there on the internet.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(rvest)\r\n\r\n# The website url\r\nIBO_url <- \"https://www.ibo-info.org/en/contest/past-ibos.html\"\r\n\r\n# Read the html and select elements using css selectors\r\nIBO_html <- read_html(IBO_url) %>%\r\n  html_elements(\"div.item__content\") %>%\r\n  html_text2()\r\n\r\n# Extract the information from the html text\r\nYear <- IBO_html %>% str_extract(\"[:digit:]{4}(?=:)\")\r\n\r\nCountry <- IBO_html %>% str_extract(\"(?<=,\\\\s)[:alpha:]+[:blank:]*[:alpha:]*\") %>%\r\n  replace_na(\"Japan\")\r\n\r\nStudents <- IBO_html %>% str_extract(\"[:digit:]*(?=\\\\s*students)\")\r\n\r\n# Put all information in a dataframe  \r\nIBO_data <- tibble(Year, Country, Students) %>%\r\n  mutate(Year = as.numeric(Year),\r\n         Students = as.numeric(Students)) %>%\r\n  filter(Year %in% 1990:2020)  # Use data only from 1990 to 2020\r\n\r\n\r\n\r\n\r\nThe basic plot\r\nNow we have our dataset at hand. It’s time to visualize it using a simple line chart:\r\n\r\n\r\nggplot(IBO_data, aes(x = Year, y = Students)) + \r\n  geom_point() + \r\n  geom_line() + \r\n  labs(y = \"Number of participants\") +\r\n  theme_classic() \r\n\r\n\r\n\r\n\r\nAs you can see, the number of participants had generally increased over time, but there was a sharp drop in 2020 due to the COVID-19 global pandemic, which might have caused some countries to withdraw from the event.\r\nMake it texty\r\nThe above line chart looks fine, though a bit plain. So now we will make use of ggtext to add some flavor to it. I will split the line chart into two panels (one from 1990 to 2005 and the other from 2006 to 2020) using facets for two reasons: (1) to avoid crowding and overlapping, and (2) to demonstrate how we can modify the facet strips.\r\n\r\n\r\nlibrary(ggtext)\r\nlibrary(extrafont) # Fonts for plotting\r\n\r\n# Import and register the system fonts\r\n# font_import()  # Please run this line to import the fonts; only need to do it once\r\nloadfonts(quiet = T)  # Need to load the system fonts in every R session\r\n\r\n# Create a new column for the two time periods\r\nIBO_data <- IBO_data %>% \r\n  mutate(Time_period = ifelse(Year <= 2005, \"1990 to 2005\", \"2006 to 2020\"))\r\n\r\n# Plain faceted line chart\r\nIBO_plot <- ggplot(IBO_data, aes(x = Year, y = Students)) + \r\n  geom_point() + \r\n  geom_line() + \r\n  facet_wrap(~Time_period, scales = \"free\", nrow = 2, strip.position = \"right\") +\r\n  scale_x_continuous(breaks = 1990:2020) + \r\n  theme_classic()\r\n\r\nIBO_plot \r\n\r\n\r\n\r\n\r\nThere are three main things we can do with ggtext:\r\n (1) Modify text outside the plot area  (2) Modify text inside the plot area  (3) Add external images to the plot\r\nI will go through the details in the following sections.\r\n(1) Modify text outside the plot area\r\nFirst, we will begin by modifying the text outside the plot area — title, axis labels, axis ticks, captions, facet strips, etc.\r\nTitle\r\n\r\n\r\n# Title\r\nIBO_plot <- IBO_plot + \r\n  labs(title = \"<span style = 'font-size: 18pt'><i>**I**nternational **B**iology **O**lympiad<i/><\/span><br>Numbers of participants over past three decades\") + \r\n  theme(plot.title = element_textbox_simple(size = 10,\r\n                                            family = \"Century Gothic\",\r\n                                            color = \"#007575\",\r\n                                            fill = \"#e0f2f2\",\r\n                                            halign = 0.5,\r\n                                            lineheight = 1.5,\r\n                                            padding = margin(5, 1, 5, 1), \r\n                                            margin = margin(0, 0, 5, 0)))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nAxis labels\r\n\r\n\r\n# Axis labels\r\nIBO_plot <- IBO_plot + \r\n  labs(x = \"\", y = \"Number of participants<br><span style = 'font-size: 9pt;'>(**Note:** different y-axis scales in the two panels)<\/span>\") + \r\n  theme(axis.title.y = element_textbox_simple(size = 14,\r\n                                              family = \"Arial\",\r\n                                              color = \"#045a8d\",\r\n                                              fill = \"#fff080\",\r\n                                              halign = 0.5,\r\n                                              orientation = \"left-rotated\",\r\n                                              r = unit(5, \"pt\"),\r\n                                              padding = margin(4, 4, 4, 4),\r\n                                              margin = margin(0, 0, 8, 0),\r\n                                              minwidth = unit(2, \"in\"),\r\n                                              maxwidth = unit(5, \"in\")))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nAxis ticks\r\n\r\n\r\n# Axis ticks\r\nbreaks_fun <- function(x) {  # A function to specify the axis tick positions for the two panels\r\n  if (min(x) < 50) {\r\n    seq(0, 200, 50)\r\n  } else {\r\n    seq(150, 300, 50)\r\n  }\r\n}\r\n\r\nlabels_fun <- function(x) {  # A function to specify the axis tick labels for the two panels\r\n  if (min(x) < 50) {\r\n    c(\"<span style = 'font-size: 12pt; color: red;'>0<\/span>\", seq(50, 150, 50), \"<span style = 'font-size: 12pt; color: red;'>200<\/span>\")\r\n  } else {\r\n    c(\"<span style = 'font-size: 12pt; color: red;'>150<\/span>\", seq(200, 250, 50), \"<span style = 'font-size: 12pt; color: red;'>300<\/span>\")\r\n  }\r\n}\r\n\r\nIBO_plot <- IBO_plot + \r\n  scale_y_continuous(expand = c(0, 40),  # For adjusting the y-axis range \r\n                     breaks = breaks_fun,\r\n                     labels = labels_fun) +\r\n  theme(axis.text.y = element_markdown())\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nCaption\r\n\r\n\r\n# Caption\r\nIBO_plot <- IBO_plot + \r\n  labs(caption = \"<i><span style = 'font-size: 9pt;'>Data source: https:&#47;&#47;www&#46;ibo-info.org/en/contest/past-ibos.html<\/span><br>Retrieved July, 2021<i/>\") + \r\n  theme(plot.caption = element_markdown(size = 8,\r\n                                        family = \"serif\",\r\n                                        color = \"grey50\",\r\n                                        lineheight = 1.5))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nFacet strips\r\n\r\n\r\n# Facet strips\r\nIBO_plot <- IBO_plot + \r\n  theme(strip.background = element_blank(),\r\n        strip.text.y = element_textbox_simple(size = 12,\r\n                                              family = \"Comic Sans MS\",\r\n                                              color = \"white\", \r\n                                              fill = \"#810f7c\", \r\n                                              halign = 0.5,\r\n                                              orientation = \"right-rotated\",\r\n                                              r = unit(8, \"pt\"),\r\n                                              padding = margin(1, 1, 1, 1),\r\n                                              margin = margin(3, 3, 3, 3)))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nThe key functions here are element_textbox_simple() and element_markdown(). Basically they do the same job; the main difference is that the former allows for more control over the appearance of the text box, whereas the latter focuses on modifying the text itself. So if you are working with text only, you can simply use element_markdown().\r\nThere are many things you can modify for the text. For example, the font size, font family, font color, font position and alignment, and line spacing. As for the text box, you can change the border color, fill color, size, corner radius (for rounded box), and so on. Take a look at the documentations of the two functions to see what other arguments there are!\r\nThe usage of element_textbox_simple() and element_markdown() are pretty much similar to their ggplot2 counterpart element_text(). When you want to modify a specific part of the plot (e.g., title), just call these functions to the corresponding arguments (e.g., plot.title =) in the theme().\r\nAlso, you might have seen that I use quite a bit of the Markdown/HTML/CSS syntaxes. Remember in the beginning, I mentioned that ggtext can render text written in Markdown/HTML/CSS languages. With these, you can easily do some advanced text manipulation, for instance, modifying the appearance of a specific letter/word in a sentence (like what I did for the title).\r\n(2) Modify text inside the plot area\r\nAfter getting the text outside the plot area done, we can proceed to the text inside the plot area. Specifically, I will add country labels to the points and modify their appearances a bit.\r\nHere I use the function geom_richtext() to map the country labels to the points. This function is quite similar to ggplot2’s geom_text() or geom_label(), but it has an additional feature: the text/box can be rotated by any angles.\r\n\r\n\r\n# Add country labels to the points\r\nIBO_plot <- IBO_plot +\r\n  geom_richtext(aes(label = Country), \r\n                size = 2,\r\n                color = colorRampPalette(c(\"#a50f15\", \"#e66101\"))(nrow( IBO_data)),\r\n                fill = \"transparent\",\r\n                angle = 45,\r\n                hjust = 0.1,\r\n                vjust = -0.1,\r\n                label.r = unit(4, \"pt\"),\r\n                label.padding = unit(c(1, 5, 1, 5), \"pt\"))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\n(3) Add external images to the plot\r\nNow we are finished with our text manipulation. Most of the time, we will end it here and be happy to go. However, there is one extra thing we can do to make the plot fancier — adding external images to the plot! Of course you can do this manually later (perhaps in PowerPoint), but isn’t it great to complete all the work at once in R? This will streamline the process and make it fully reproducible! So let’s do it!\r\nThe principle of adding images is the use of HTML <img> tag, which has a basic syntax structure <img scr = 'path_to_image'/>. If you are not familiar with HTML, don’t panic. Simply copy and paste the code in the example below and replace the image path with yours (can be a website url or a local directory). The additional height and width attribute in the <img> tag allow for controlling the size of the images.\r\nYou can add images to two places of a figure: axis ticks and plot panel.\r\nAdd images to the axis ticks\r\nTo add images to the axis ticks, you need to specify in scale_x|y_XXX() the tick positions at which the images should be placed on the axis (breaks =), along with the HTML <img> tags as labels (labels =). After that, call element_markdown() to the corresponding theme element (in this example axis.text.x =) in theme(). The images will then be displayed along the axis.\r\n\r\n\r\n# Download the zip file of the logos from my GitHub repository\r\n# The file will be saved in your current directory\r\ndownload.file(url = \"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2021-07-10-post-5-awesome-text-display-with-ggtext/IBO_logos.zip\", destfile = \"./IBO_logos.zip\")\r\n\r\n# Unzip the file\r\nunzip(zipfile = \"./IBO_logos.zip\")\r\n\r\n# HTML <img> tags\r\nIBO_logo <- paste0(\"<img src = './IBO_logos/\", 1990:2020, \".png' height = '15' width = '15' /><br>\", 1990:2020)\r\n\r\n# Add the logos to the x-axis ticks\r\nIBO_plot <- IBO_plot +\r\n  scale_x_continuous(breaks = 1990:2020, labels = IBO_logo) +\r\n  theme(axis.text.x = element_markdown(color = \"black\", size = 7))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nAdd images to the plot panel\r\nTo add images to the plot panel, simply create a dataframe containing the x and y positions as well as a column containing the HTML <img> tags, and use geom_richtext(aes(label = )) to map the image tags to the plot. The images will then be displayed at the designated positions.\r\n\r\n\r\n# Add the main logo to the upper panel\r\nIBO_logo_df <- data.frame(x = 1992, \r\n                          y = 200,\r\n                          Time_period = \"1990 to 2005\",\r\n                          logo = paste0(\"<img src = './IBO_logos/main.png' width = '100' />\"))\r\n\r\nIBO_plot <- IBO_plot +\r\n  geom_richtext(data = IBO_logo_df, \r\n                aes(x = x, y = y, label = logo), \r\n                colour = \"transparent\")\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nTo give you a better idea of how the final figure is generated, I have organized the code chunk pieces throughout the post into a full code chunk below. You can simply copy and paste it into your R session, swap your own data and modify the arguments as you wish!\r\n\r\n\r\n# Library\r\nlibrary(tidyverse)\r\nlibrary(rvest)\r\nlibrary(ggtext)\r\nlibrary(extrafont)\r\n\r\n# Import and register the system fonts\r\n# font_import()  # Please run this line to import the fonts; only need to do it once\r\nloadfonts(quiet = T)  # Need to load the system fonts in every R session\r\n\r\n# The IBO website url\r\nIBO_url <- \"https://www.ibo-info.org/en/contest/past-ibos.html\"\r\n\r\n# Read and extract the website contents into a dataframe\r\nIBO_html <- read_html(IBO_url) %>%\r\n  html_elements(\"div.item__content\") %>%\r\n  html_text2()\r\n\r\nYear <- IBO_html %>% str_extract(\"[:digit:]{4}(?=:)\")\r\nCountry <- IBO_html %>% str_extract(\"(?<=,\\\\s)[:alpha:]+[:blank:]*[:alpha:]*\") %>% replace_na(\"Japan\")\r\nStudents <- IBO_html %>% str_extract(\"[:digit:]*(?=\\\\s*students)\")\r\n\r\nIBO_data <- tibble(Year, Country, Students) %>%\r\n  mutate(Year = as.numeric(Year),\r\n         Students = as.numeric(Students)) %>%\r\n  filter(Year %in% 1990:2020) %>%\r\n  mutate(Time_period = ifelse(Year <= 2005, \"1990 to 2005\", \"2006 to 2020\"))\r\n\r\n# Functions for setting breaks and labels for each of the two facet panels\r\nbreaks_fun <- function(x) {\r\n  if (min(x) < 50) {\r\n    seq(0, 200, 50)\r\n  } else {\r\n    seq(150, 300, 50)\r\n  }\r\n}\r\n\r\nlabels_fun <- function(x) {\r\n  if (min(x) < 50) {\r\n    c(\"<span style = 'font-size: 12pt; color: red;'>0<\/span>\", seq(50, 150, 50), \"<span style = 'font-size: 12pt; color: red;'>200<\/span>\")\r\n  } else {\r\n    c(\"<span style = 'font-size: 12pt; color: red;'>150<\/span>\", seq(200, 250, 50), \"<span style = 'font-size: 12pt; color: red;'>300<\/span>\")\r\n  }\r\n}\r\n\r\n# Download the IBO logos\r\ndownload.file(url = \"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2021-07-10-post-5-awesome-text-display-with-ggtext/IBO_logos.zip\", destfile = \"./IBO_logos.zip\")\r\nunzip(zipfile = \"./IBO_logos.zip\")\r\n\r\n# A vector of HTML <img> tags as x-axis tick logos\r\nIBO_logo <- paste0(\"<img src = './IBO_logos/\", 1990:2020, \".png' height = '15' width = '15' /><br>\", 1990:2020)\r\n\r\n# A dataframe for the main logo\r\nIBO_logo_df <- data.frame(x = 1992, \r\n                          y = 200,\r\n                          Time_period = \"1990 to 2005\",\r\n                          logo = paste0(\"<img src = './IBO_logos/main.png' width = '100' />\"))\r\n\r\n# Plot\r\nggplot(IBO_data, aes(x = Year, y = Students)) +\r\n  \r\n  # Country labels\r\n  geom_richtext(aes(label = Country), \r\n                size = 2,\r\n                color = colorRampPalette(c(\"#a50f15\", \"#e66101\"))(nrow( IBO_data)),\r\n                fill = \"transparent\",\r\n                angle = 45,\r\n                hjust = 0.1,\r\n                vjust = -0.1,\r\n                label.r = unit(4, \"pt\"),\r\n                label.padding = unit(c(1, 5, 1, 5), \"pt\")) +\r\n  \r\n  # Main logo in the upper panel\r\n  geom_richtext(data = IBO_logo_df, \r\n                aes(x = x, y = y, label = logo), \r\n                colour = \"transparent\") +\r\n  \r\n  # Points\r\n  geom_point() + \r\n  \r\n  # Lines\r\n  geom_line() + \r\n  \r\n  # Facets\r\n  facet_wrap(~Time_period, scales = \"free\", nrow = 2, strip.position = \"right\") +\r\n  \r\n  # x-axis tick logos\r\n  scale_x_continuous(breaks = 1990:2020, labels = IBO_logo) +\r\n  \r\n  # y-axis tick labels\r\n  scale_y_continuous(expand = c(0, 40),\r\n                     breaks = breaks_fun,\r\n                     labels = labels_fun) +\r\n  \r\n  # Built-in theme\r\n  theme_classic() + \r\n  \r\n  # Specify title, y-axis label, caption, and facet strips using Markdown/HTML/CSS language\r\n  labs(title = \"<span style = 'font-size: 18pt'><i>**I**nternational **B**iology **O**lympiad<i/><\/span><br>Numbers of participants over past three decades\",\r\n       x = \"\", \r\n       y = \"Number of participants<br><span style = 'font-size: 9pt;'>(**Note:** different y-axis scales in the two panels)<\/span>\",\r\n       caption = \"<i><span style = 'font-size: 9pt;'>Data source: https:&#47;&#47;www&#46;ibo-info.org/en/contest/past-ibos.html<\/span><br>Retrieved July, 2021<i/>\") + \r\n  \r\n  theme(# Title\r\n        plot.title = element_textbox_simple(size = 10,\r\n                                            family = \"Century Gothic\",\r\n                                            color = \"#007575\",\r\n                                            fill = \"#e0f2f2\",\r\n                                            halign = 0.5,\r\n                                            lineheight = 1.5,\r\n                                            padding = margin(5, 1, 5, 1), \r\n                                            margin = margin(0, 0, 5, 0)),\r\n        # y-axis label\r\n        axis.title.y = element_textbox_simple(size = 14,\r\n                                              family = \"Arial\",\r\n                                              color = \"#045a8d\",\r\n                                              fill = \"#fff080\",\r\n                                              halign = 0.5,\r\n                                              orientation = \"left-rotated\",\r\n                                              r = unit(5, \"pt\"),\r\n                                              padding = margin(4, 4, 4, 4),\r\n                                              margin = margin(0, 0, 8, 0),\r\n                                              minwidth = unit(2, \"in\"),\r\n                                              maxwidth = unit(5, \"in\")),\r\n        \r\n        # x-axis tick logos\r\n        axis.text.x = element_markdown(color = \"black\", size = 7),\r\n        \r\n        # y-axis tick labels\r\n        axis.text.y = element_markdown(),\r\n        \r\n        # Caption\r\n        plot.caption = element_markdown(size = 8,\r\n                                        family = \"serif\",\r\n                                        color = \"grey50\",\r\n                                        lineheight = 1.5),\r\n        \r\n        # Facet strips\r\n        strip.background = element_blank(),\r\n        strip.text.y = element_textbox_simple(size = 12,\r\n                                              family = \"Comic Sans MS\",\r\n                                              color = \"white\", \r\n                                              fill = \"#810f7c\", \r\n                                              halign = 0.5,\r\n                                              orientation = \"right-rotated\",\r\n                                              r = unit(8, \"pt\"),\r\n                                              padding = margin(1, 1, 1, 1),\r\n                                              margin = margin(3, 3, 3, 3)))\r\n\r\n\r\n\r\nSummary\r\nA quick recap of what we have done throughout the post. First, we modified the plot title, axis labels, axis ticks, caption, and facet strips using two theme() elements element_textbox_simple() and element_markdown(). Second, we added some country labels to the points using the geom layer geom_richtext() and customized the labels a bit. Third, we used element_markdown() to add external images to the x-axis, and geom_richtext() to add another image to the plot panel.\r\nHonestly, I feel that the final figure in this post does not look so satisfying. I tried to show the things you can do with ggtext as many as possible, making the figure kind of “over-texty”. It is just for demonstration purpose though. When working with your own figure, you might want to think a bit about how to better design it. Maybe spend some time exploring the package website to learn more. Also, I highly recommend having a basic understanding of Markdown/HTML/CSS, which will allow you to fully leverage the strength of ggtext!\r\nOh, one last thing forget to say: I was one of the participants in the 2014 IBO in Bali, Indonesia. It’s been seven years. Time flies! In fact, this is one of the main reasons why I chose IBO data as the example dataset. The other is that the website has many logos, which serves well the purpose of this post.\r\nThat’s it for this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-07-10-post-5-awesome-text-display-with-ggtext/../../homepage_images/Post5.png",
    "last_modified": "2021-08-12T20:23:01-07:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "posts/2021-06-26-post-4-consistent-colors-of-the-same-factor-levels-across-figures/",
    "title": "Post #4. Consistent colors of the same factor levels across figures",
    "description": "In this post, I will show you a simple trick to keep the colors of the same factor levels consistent across different ggplot figures.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-06-26",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nThe problem\r\nSuppose that we want to visualize the relationship (i.e., a scatterplot) between engine displacement (displ) and highway miles per gallon (hwy) of cars in the mpg dataset. And for some reason, we would like to create separate figures for each of the three drive train types (drv) rather than having a single figure with three panels (i.e., facets). Also, the data points in the figures will be colored by car type (class).\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Four-wheel drive\r\nplot_drv4 <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"4\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  stat_smooth(method = \"lm\", se = F) + \r\n  lims(x = c(1, 7), y = c(10, 30)) +\r\n  labs(title = \"Four-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Front-wheel drive\r\nplot_drvf <- mpg %>% \r\n  mutate(class = factor(class)) %>%  \r\n  filter(drv == \"f\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(1, 6), y = c(10, 45)) +\r\n  labs(title = \"Front-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Rear wheel drive\r\nplot_drvr <- mpg %>%   \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"r\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  stat_smooth(method = \"lm\", se = F) + \r\n  lims(x = c(3, 7.5), y = c(10, 30)) +\r\n  labs(title = \"Rear-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\nplot_drv4\r\nplot_drvf\r\nplot_drvr\r\n\r\n\r\n\r\n\r\nHave you spotted something weird? Yup, the colors of the levels in class are not consistent across the three figures (e.g., salmon red represents “compact” in the first two figures but “2seater” in the third; “subcompact” has three different colors in the three figures!) This problem arises because some factor levels are shared across (two or all three) figures while the others are missing, and by default ggplot will only color the levels appearing in the data and omit the rest.\r\nThe partial solution\r\nSo how can you fix this problem? Well, there is a workaround: since ggplot by default omits the unused levels, we can ask ggplot not to do so by specifying drop = F in scale_color_XXX():\r\n\r\n\r\n# Four-wheel drive\r\nplot_drv4_undropped <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"4\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_discrete(drop = F) +  # Not to drop the unused levels\r\n  stat_smooth(method = \"lm\", se = F) + \r\n  lims(x = c(1, 7), y = c(10, 30)) +\r\n  labs(title = \"Four-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Front-wheel drive\r\nplot_drvf_undropped <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"f\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_discrete(drop = F) +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(1, 6), y = c(10, 45)) +\r\n  labs(title = \"Front-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Rear wheel drive\r\nplot_drvr_undropped <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"r\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_discrete(drop = F) +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(3, 7.5), y = c(10, 30)) +\r\n  labs(title = \"Rear-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\nplot_drv4_undropped\r\nplot_drvf_undropped\r\nplot_drvr_undropped\r\n\r\n\r\n\r\n\r\nNow, as you can see, each level in class is associated with a specific color across all three figures. However, another problem comes (I bet you already know what it is): the unused levels are shown in the legends even though they do not appear in the plots (e.g., there is no “2seater” car with four-wheel drive, but “2seater” still shows up in the legend). Depending on the nature of your figure and your purpose, if the legends are not necessary, you can simply hide them while having consistent colors across the figures. But what if you want to keep the legends? Keep reading!\r\nThe ultimate solution\r\nSo what is the ultimate solution to this problem? Three steps:\r\nFirst, create a named vector with colors (can be either hex color codes, color names, or a mixture of them) as the vector elements and factor levels as their names. Note that all levels of the factor across the figures should appear as the vector names, which means the length of the vector should be the same as the number of factor levels. This named vector will be the palette for the next step.\r\nNext, use scale_color_manual(values = name_of_palette) to manually set the colors of the factor levels based on the palette.\r\nFinally, identify the subset of factor levels appearing in the data you are using for that specific figure and specify them using the argument limits = in scale_color_manual().\r\nOkay, to see is to believe. Here is a demo:\r\n\r\n\r\nlibrary(RColorBrewer)\r\n\r\n# Create a named vector as the palette\r\nclass <- unique(mpg$class)  # All factor levels across figures\r\ncolors <- brewer.pal(length(class), \"Set1\")  # Colors\r\nmy_palette <- set_names(colors, class)  # Named vector\r\n\r\n# Four-wheel drive\r\nclass_drv4 <- mpg %>%\r\n  filter(drv == \"4\") %>% \r\n  .$class %>%\r\n  unique()  # Subset of levels in \"class\" for four-wheel drive cars\r\n\r\nplot_drv4_manual <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"4\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_manual(values = my_palette, limits = class_drv4) +  # Manually set the colors of the factor levels based on the palette and also specify the levels present in the data \r\n  stat_smooth(method = \"lm\", se = F) + \r\n  lims(x = c(1, 7), y = c(10, 30)) +\r\n  labs(title = \"Four-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Front-wheel drive\r\nclass_drvf <- mpg %>% \r\n  filter(drv == \"f\") %>% \r\n  .$class %>%\r\n  unique()\r\n  \r\nplot_drvf_manual <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"f\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_manual(values = my_palette, limits = class_drvf) +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(1, 6), y = c(10, 45)) +\r\n  labs(title = \"Front-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Rear wheel drive\r\nclass_drvr <- mpg %>% \r\n  filter(drv == \"r\") %>% \r\n  .$class %>%\r\n  unique()\r\n\r\nplot_drvr_manual <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"r\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_manual(values = my_palette, limits = class_drvr) +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(3, 7.5), y = c(10, 30)) +\r\n  labs(title = \"Rear-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\nplot_drv4_manual\r\nplot_drvf_manual\r\nplot_drvr_manual\r\n\r\n\r\n\r\n\r\nNow, not only are the colors of the factor levels consistent across the figures, but also the legends are properly displaying the levels appearing in the plots. Problem solved!\r\nAn advantage of this approach is that it offers great flexibility for users to select the colors they would like for each factor level. Of course, you have to spend a bit of time creating the palette yourself instead of just lazily asking ggplot to automatically color the levels for you. But think in the other way round: you get 100% control of the colors! Doesn’t that sound good?\r\nLast but not least, in this example I used the built-in color palette “Set1” from the package RColorBrewer, which provides different types of palettes coming in a variety of colors. And if you want to build your own palette from scratch, definitely check out the website ColorBrewer. There are tons of options to customize the colors to your heart’s content.\r\nThat’s it for this post and don’t forget to leave your comments and suggestions below if you have any. Also, do let me know if you find another (perhaps even simpler) way to do the same job!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-06-26-post-4-consistent-colors-of-the-same-factor-levels-across-figures/../../homepage_images/Post4.png",
    "last_modified": "2021-09-11T21:00:16-07:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-06-18-post-3-pie-charts-with-ggplot/",
    "title": "Post #3. Pie charts with ggplot",
    "description": "Want to know how to create effective pie charts with ggplot? Dig in to learn more!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-06-18",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nBackground\r\nPie charts are arguably one of the most fundamental graphs in the world. They are primarily used for presenting categorical variables with numerical values (values that can be converted to proportions). These charts are so simple and straightforward that almost everyone can grasp the information at first glance without thinking, thus quite useful for data exploration and communication (yet some have argued not to use them, especially in scientific publications. See this article for more details). That said, an ill-designed pie chart could still ruin your good data. So in this “cook” post, we will be looking at some ways to enhance your pie chart and make it more “attractive” and “effective”!\r\nBasic pie charts with ggplot\r\nTo create a pie chart with ggplot, simply make a stacked barplot and add the function coord_polar(theta = \"y\"):\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Data preparation: cars with different numbers of cylinders\r\nn_cyl <- mtcars %>%\r\n  group_by(cyl) %>%\r\n  summarise(N = n()) %>%\r\n  mutate(cyl = as.factor(cyl))\r\n\r\n# Basic pie chart  \r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  coord_polar(theta = \"y\")\r\n\r\n\r\n\r\n\r\nYou can also change the direction in which the categories/levels are ordered by specifying direction = -1 in coord_polar():\r\n\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  coord_polar(theta = \"y\", direction = -1)  # Counter-clockwise\r\n\r\n\r\n\r\n\r\nSo what does theta = \"y\" do? Basically, this argument tells ggplot to map the y-axis to a polar coordinate system. The stacks in the barplot are bent into a circle, with the arc length of each slice proportional to the original heights of the stacks. Remember, pie charts are just circular stacked barplots!\r\nMore tweaks\r\nRecipe 1: clean up the pie\r\nThe above pie chart does not look satisfying. The axis tick marks and labels, grid lines, and the grey background are kind of extra, so let’s remove them. We will also add a title to the plot.\r\n\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  coord_polar(theta = \"y\", direction = -1) +\r\n  scale_fill_discrete(name = NULL) +  # Remove legend title\r\n  labs(title = \"Number of Cylinders\") +  # Add plot title\r\n  theme_void() +  # Empty theme\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n\r\n\r\n\r\nRecipe 2: label the pie\r\nSometimes you may want to directly label the slices rather than having a separate legend. Here is a trick: change the y axis tick labels to the names of the slices. We will compute the midpoints of the arcs (which are the positions at which the tick labels will be placed) and specify the label names in scale_y_continuous().\r\nBy the way, because the last factor level (in this example “cyl 8”) is at the bottom of the barplot and will go first in the pie chart, we need to reverse the order of the factor levels in our original dataframe to match the order of the stacks (slices) in the plot.\r\n\r\n\r\n# Compute the midpoints of the arcs\r\nlabel_pos <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%  # Reverse the order of the factor levels\r\n  mutate(pos = cumsum(N) - N/2)\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = label_pos$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) +  # Add some white space to the labels to prevent overlapping \r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12))\r\n\r\n\r\n\r\n\r\nRecipe 3: annotate the pie\r\nAdditionally, you might want to annotate the slices, say for example, the proportions. We will create a new dataframe and use geom_text() to map the labels to the slices. The x positions are just an arbitrary “x” (same as the one in geom_bar()); the y positions are the midpoints of the arcs.\r\n\r\n\r\n# A dataframe for mapping the labels to the slices\r\nlabel_pos2 <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%\r\n  mutate(pos = cumsum(N) - N/2,\r\n         prop = paste(100*round(N/sum(N), 2), \"%\"))\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  geom_text(data = label_pos2, aes(x = \"x\", y = pos, label = prop)) +\r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = label_pos2$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) + \r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders \\n (n = 32)\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12)) \r\n\r\n\r\n\r\n\r\nAn even simpler alternative is to map the labels to the stacks using geom_text() and center-align their vertical positions by specifying the argument position_stack(vjust = 0.5):\r\n\r\n\r\nn_cyl2 <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%\r\n  mutate(pos = cumsum(N) - N/2,\r\n         prop = paste(100*round(N/sum(N), 2), \"%\"))\r\n\r\nggplot(n_cyl2, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  geom_text(aes(label = prop), position = position_stack(vjust = 0.5)) +  # Center-align the vertical positions of the labels on each stack\r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = n_cyl2$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) + \r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders \\n (n = 32)\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12)) \r\n\r\n\r\n\r\n\r\nLooks way better than the previous ones, doesn’t it?\r\nDifferent varieties of pies\r\nNow that we have already learned how to bake a basic pie, let’s take a look at some other pie varieties:\r\n1. Exploded pie chart:\r\nIn an exploded pie chart, the slices are split apart from each other. You can “cut” the slices by adding thick white borders around them (personally I feel that this is more visually appealing than the original “unexploded” one).\r\n\r\n\r\nlabel_pos2 <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%\r\n  mutate(cumsum = cumsum(N),\r\n         mid = N/2,\r\n         pos = cumsum - mid,\r\n         prop = paste(100*round(N/sum(N), 2), \"%\"))\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\", color = \"white\", size = 5) +  # Add white borders around the slices\r\n  geom_text(data = label_pos2, aes(x = \"x\", y = pos, label = prop)) +\r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = label_pos$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) +\r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders \\n (n = 32)\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12))  \r\n\r\n\r\n\r\n\r\n2. Doughnut chart:\r\nHave you ever seen a pie chart with its center hollowed out? This is called a “Doughnut chart” (yes, from a “pie” to a “doughnut”)! There is no direct function or argument to create a doughnut chart in ggplot, and so we will use a small trick here: add an arbitrary “empty” level to the x-axis before the one we have. This works because there is nothing to be bent into a circle for that empty level, thus leaving a white area and forming a hollow there. We can use scale_x_discrete(limits = c(\"x_empty\", \"x\")) to add an arbitrary level “x_empty” to the x-axis.\r\n\r\n\r\nlabel_pos <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%\r\n  mutate(cumsum = cumsum(N),\r\n         mid = N/2,\r\n         pos = cumsum - mid)\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\", width = 0.7) +\r\n  scale_x_discrete(limits = c(\"x_empty\", \"x\")) +\r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = label_pos$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) + \r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12))\r\n\r\n\r\n\r\n\r\nNotes:\r\nIn this example, I call the empty level “x_empty”. You can use whatever name you want; just make sure it is not the same as your original one.\r\nThe empty level should be added BEFORE the original level (limits = c(\"x_empty\", \"x\")), not after (limits = c(\"x\", \"x_empty\")). Otherwise, the white area will be left outside the pie instead of inside it.\r\nThe “thickness” of the doughnut can be controlled by the argument width = in geom_bar().\r\n3. Bull’s eye chart:\r\nWhat happens if you call theta = \"x\" instead of theta = \"y\" in coord_polar()? This will give you a chart with concentric circles, also known as “Bull’s eye chart”. Be careful though, this kind of chart could be a bit misleading, as the areas of the circles/rings are not proportional to the original values.\r\n\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\", width = 1) + \r\n  coord_polar(theta = \"x\", direction = -1, clip = \"off\") +\r\n  scale_fill_discrete(name = NULL) +  \r\n  labs(title = \"Number of Cylinders\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n\r\n\r\n\r\nSummary\r\nAt this point, you should have got the hang of creating pie charts with ggplot. As you can see, this type of graph is best for visualizing categorical variables with numerical values. However, it becomes less effective when there are too many categories (slices). In general, the number of categories should be less than 7 to achieve a better visual effect (though it really depends on the nature of your data). Also, when you are comparing the slices across multiple pies, it can sometimes be visually deceptive since the angle of the slice represents the “proportion” rather than the original “absolute value”. In these cases, a regular barplot or a boxplot would be a better alternative.\r\nHope you learn something and will be able to make a “tasty” pie chart yourself. And as always, don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-06-18-post-3-pie-charts-with-ggplot/../../homepage_images/Post3.png",
    "last_modified": "2021-07-12T02:54:04-07:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-05-26-guest-post-1-communicating-the-essence-of-your-data/",
    "title": "Guest Post #1. Communicating the ESSENCE of your data",
    "description": "Visualizing multi-dimensional and dynamic data can be challenging. In this post, I will show how you can better communicate these features with interactive plots and animations.",
    "author": [
      {
        "name": "William Ou",
        "url": {}
      }
    ],
    "date": "2021-05-26",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nFrom the host: Here comes the first guest post by William Ou! In this post, he will show you how to “attractively” visualize the data using interactive plots and animations. This is a rather long post, but fear not, I promise you will find it interesting, and most importantly, your data visualization skills will LEVEL UP!\r\nThe challenge\r\nArguably the biggest challenge in data visualization is the fact that we live in a multi-dimensional and dynamic 1 world. Our 3D perception of the universe is an obvious case in support of the multi-dimensions part (all we need is more than 1-dimension!). You might argue that some things are in fact static though. But! If you look closely enough, everything in the physical world is dynamic, constantly moving and fluctuating in space and time. The screen on your computer may look “static” but it’s actually constantly emitting light. Even the wall in your room is made up of particles that are constantly moving. Yet, despite the ubiquity of multi-dimensionality and dynamical behaviors, a large amount of the information we acquire today comes in the standard 2D and static format: the book or Wikipedia page you’re reading, you’re Facebook feed, magazines etc.. Although there are ways of representing dynamic and multi-dimension features in 2D static mediums, doing so often distorts the original information and can hinder the “essence” of the message that one wishes to convey. In many cases, deciphering distorted information requires practice and prior knowledge which renders the information accessible to only a few selected individuals. To demonstrate my point, consider the 2 ways of visualizing the Palmer Penguins dataset below:\r\nApproach 1: Dimension reduction (PCA)\r\n\r\n\r\n\r\nApproach 2: 3D interactive plots\r\n\r\n\r\n\r\nIf you’ve learned PCA before, you might have no problem interpreting Approach 1. But if you haven’t, you might be wondering: What the **** is a PC1/PC2? What are the units of the axes? Why are there arrows pointing at different directions? What does a single point even represent? Most importantly, where did my penguins go!? Because the focus of this post is not about statistics, I won’t go into the details of explaining what a PCA is. What I do want to point out though, is how we can visualize data in a more accessible manner.\r\nNow, Approach 2 may also look like a handful. However, if you take a deep breath and carefully examine the plot, anyone would be able to interpret it, even without any background (assuming that they can read English, of course)! Upon closer inspection, you’ll see that each point in the figure is made up of 4 variables: 1. Bill length (mm), 2. Bill depth (mm), 3. Flipper length (mm), and 4. Body size (g). All these variables characterize an individual penguin (a penguin is multi-dimensional!). The 4 variables are represented by 3 axes and a color gradient. The reason why we do not have a 4th axis is because our brain is not programmed to think that way, so the 4th variable is represented as a color gradient instead. An important thing to note is that, these points on the plot show exactly what the data says. Nothing is distorted and its as raw as it can be. One cool feature of this plot is that it is interactive. Although our screen is 2D, we can get a better “feel” of the dimensionality by rotating the axes around. Rotating works by dragging the plot around with your cursor. By doing so, we’ll see that at certain angles, the points look like a big “cloud” while at other angles you can see a clear separation between clusters of points. Try playing around with the plot, explore its features, and see if you can find other ways of visualizing your data.\r\nDynamic variables\r\nNow let’s take a look at some ways to visualize dynamic variables, variables that change over time. Gapminder is a foundation founded by Hans Rosling that aims to highlight common misconceptions about global trends with data. The gapminder package in R provides a subset of its dataset. Let’s look at how life expectancy and GDP of each country changes over time (year).\r\nApproach 1: Static representation with arrows\r\n\r\n\r\n\r\nApproach 2: Animate to reveal each time step sequentially\r\n\r\n\r\n\r\nFor the dynamics example, the two figures above are actually identical. The only difference is that the animation shows how the state variable (in this case, life expectancy) develops over time by revealing each data sequentially as time progresses. Animations are particularly helpful for visualizing time-series data with multiple variables because things can get cluttered really fast when lines are drawn to represent the passage of time. Although the animated version also shows a lot of cluttering towards the end, it doesn’t necessarily impede understanding because the viewer already has a sense of where each point came from.\r\nThe gapminder dataset is the perfect example that demonstrates the power of good data visualization! If you haven’t already, I strongly encourage you to check out the seminal TED talk and this BBC trailer by Hans Rosling, the OG of descriptive and exploratory data analysis.\r\nNow for some coding\r\nLet’s go over some simple examples to see how you can make your own interactive plot with plotly and animation with gganimate. Both of these packages have really good documentation and you can find out more about them on their websites: plotly and gganimate\r\nI. Making your first interactive 3D plot with plotly\r\nWe’ll use the mtcars dataset here as an example. Make sure to have the plotly package installed on your computer.\r\nThe plotly package is built to be compatible with tidyverse with both sharing very similar syntax. Just as ggplot() is to ggplot2, the main engine of plotly plots is the function plot_ly(). Again, very similar to ggplot2, we supply the plot_ly() function with our data frame and the variables we would like to plot.\r\nWe’ll start by loading the package(s) first, and tweak the dataset a little bit prior to plotting. Here, we will treat # of cylinders as a factor instead of a integer value for visualization purposes.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(plotly)\r\n\r\nmtcars_new <-  mtcars %>%\r\n  mutate(cyl = as.factor(cyl))\r\n\r\n\r\n\r\nAgain, very similar to ggplot(), we supply the plot_ly() function with the data that we want to plot and specify the axes which would be x, y, and z since we have a 3rd dimension. Note the small differences in how the variables are defined here. In plot_ly() the variables are defined with the “~” (tilde), which is like what you would normally do when defining a linear model (e.g. lm(y ~ x1 + x2)). In addition, we’ll also specify a 4th variable/dimension as the color of the points.\r\n\r\n\r\nmt_plotly <- plot_ly(data = mtcars_new, x = ~wt, y = ~hp, z = ~qsec,\r\n        color = ~cyl)\r\nmt_plotly\r\n\r\n\r\n\r\n\r\nAnd there you have it! Pretty straightforward, right? But if you’re picky, you might not be satisfied with this and want to tweak it some more. So let’s try to edit the axis labels, since they’re all abbreviated and have no units. Through the following code, you’ll start seeing more tidyverse/ggplot2 style elements of the plot_ly syntax, see if you can spot them!\r\n\r\n\r\nmt_plotly %>%\r\n    layout(title = 'Motor Trend Car Road Tests',\r\n         scene = list(xaxis = list(title = 'Weight (1000lbs)'),\r\n                      yaxis = list(title = 'Horsepower (hp)'),\r\n                      zaxis = list(title = 'Quarter mile time (s)')),\r\n         annotations = list( # This section is hard-coded \r\n           x = 1.13,\r\n           y = 1.05,\r\n           text = '# of Cylcinders',\r\n           showarrow = FALSE))\r\n\r\n\r\n\r\n\r\nYes, plot_ly functions are pipeable! The piping here is analogous to “+” in ggplot2 syntax. The layout() is also much like the theme() in ggplot2. I will admit though, plot_ly takes time to get used to. The arguments that functions take are sometimes not as straightforward, for example, when does it need to be a list() and when does it not? Moreover, the legend title for the color scheme is hard-coded because there is no argument for specifying legend titles at the moment (at least to my knowledge).\r\nSo, in summary, I think plot_ly offers a neat way of visualizing complex data. The interactive aspect can also help make data more accessible and can be a handy pedagogical tool. However, if you’re trying to make a figure to publish in a scientific journal, this is probably an overkill.\r\nII. Making your first animation with gganimate\r\nBecause gganimate is a part of the tidverse/ggplot2 ecosystem, it should be very straightforward if you are already with familiar with either of them. The general schema of making an animation with gganimate is to:\r\nCreate a ggplot object with ALL your points plotted out.\r\nDecide how you would like the points to be animated by specifying how you would like the data to be shown over time. In the case of time-series, the “time” variable will be the index of your animation.\r\nChoose an appropriate transition function from gganimate, input your index variable (e.g. time), and simply overlay (“+”) this call to your ggplot object just as you would with adding geom_point(), geom_line(), theme()\r\nTHAT’S IT!\r\nAs you can imagine, animations take a little time to render. So for the sake brevity, I’ll use only a subset of the gapminder dataset.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(gganimate)\r\nlibrary(gapminder)\r\n\r\n# Subset the countries in Asia\r\ngapminder_asia <- gapminder %>%\r\n  filter(continent == 'Asia')\r\n\r\n\r\n\r\n\r\nLet’s “gg”plot it out:\r\n\r\n\r\nasia_p <- gapminder_asia %>%\r\n  ggplot(aes(x = year, y = pop, group = country)) +\r\n  geom_point() +\r\n  geom_path() +\r\n  geom_text(aes(label = country), hjust = -0.3, size = 2.5) +\r\n  scale_y_log10() +\r\n  xlim(1950, 2030) +\r\n  theme_bw()\r\n\r\nasia_p\r\n\r\n\r\n\r\n\r\nThis looks horrible, doesn’t it? But this is what I meant by “plot it all out”. This will become clearer through the animation process though, since the points and texts of each country will only appear once at each time point. Because the line specified by geom_path is continuous (only 1 line per group), it will only “grow” as time progresses. In other words, each country will only have a single line, a single point, and a single text throughout the animation.\r\nTo make the plot an animation, simply choose an appropriate transition function from the gganimate package and add it to your ggplot. But what the heck is a transition function? Transition functions are the functions the allow you to specify how you want your plot to be animated. In most cases, all you need to provide to the function is the variable from your dataframe in which you want the animations to be indexed. For example, if we want the animations to progress over time, then we want the time-indexed variable to be our argument. Here, we’ll use the transition_reveal() function as our transition function since we are trying to visualize the temporal evolution of population size.\r\n\r\n\r\nasia_p + transition_reveal(year)\r\n\r\n\r\n\r\n\r\nAs its name suggests, transition_reveal() works by gradually “revealing” your data. The video/gif you see is really just a combination of multiple frames, and each frame consists of only data from a given year. The order of appearance is dependent on the order of your index variable (in our case, year). In some cases, it might not be time that you want to animate and a continuous animation might not be the “essence” that you want your plot to communicate. Finding the correct transition function ultimately depends on the message that you want to convey.\r\nSummary\r\nI started off by suggesting to you that 2D static plots can sometimes limit our ability to communicate the story of our data. This is because our world is multi-dimensional and dynamic! I then showed you that we can overcome some of these limitations by creating I. Interactive plots that allow you to rotate axes, thereby giving the perception of “depth”, and II. Animations that captures the “passage of time”.\r\nThrough this post, I hope I, at least slightly, highlighted the pedagogical implications of making intuitive and accessible data through thoughtful visualizations. So there you have it! May you live long and prosper 🖖\r\nWilliam Ou is an ecologist broadly interested in complexity science, eco-evolutionary dynamics, and more recently, cognitive psychology. When not sciencing, he enjoys biking around the city, eating ice cream, making generative art with ggplot, and watching netflix. Check out his website to learn more!\r\n\r\nI refer to dynamic here as a term that indicates change over time, recognizing that time is sometimes interpreted as another dimension↩︎\r\n",
    "preview": "posts/2021-05-26-guest-post-1-communicating-the-essence-of-your-data/../../homepage_images/Guest_post1.gif",
    "last_modified": "2021-06-07T08:49:52-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-07-post-2-three-ways-to-create-log-axes-in-ggplots-which-one-should-you-use/",
    "title": "Post #2. Three ways to create log axes in ggplots: which one should you use?",
    "description": "This post shows you three different ways to create log axes in ggplots and provides some suggestions on which method to use for your figures.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-05-07",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nWe often have data spanning across several orders of magnitude or having skewed distributions. In either case, we might consider transforming our data, and log transformation is one of the most common data transformation techniques people use.\r\nIn ggplots, there are three different methods to do log transformation: (1) Transformation of variables  (2) Transformation of scales  (3) Transformation of coordinates\r\nYou can take a look at a brief demonstration of the three methods on this ggplot2 website. These methods share something in common, but also differ from each other in some ways, and I often find it confusing to use them (I think you might feel the same way as I do!)\r\nIn this post, I will go over these methods one by one, explain the details, and make a comprehensive comparison. Hopefully, after reading the article, you will clear up the confusions and know how which method to go for your figures!\r\nBy the way, we will be working with the famous diamonds dataset in ggplot2, which contains the price and various attributes of around 54,000 diamonds.\r\nSay we would like to see how the price of diamonds is related to the weight (carat) of diamonds. Let’s first make a scatterplot to visualize their relationship:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nIt looks a bit over-plotted, but still you can see a seemingly non-linear positive relationship between price and carat. So we decide to log-transform the data to make the relationship more linear.\r\nMethod 1. Transformation of variables\r\nThe first method is transformation of variables. This is done by applying log() directly to the x and/or y variables in the aes():\r\n\r\n\r\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\r\n  geom_point() +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nAs you can see, the relationship does become more linear. This method simply log-transforms the x and y variables and plot them as is, and so now the axis ticks display the transformed rather than the original values.\r\nIf we fit a line through the points using stat_smooth(), we are essentially fitting a linear model with log-transformed carat and price as the predictor and the response:\r\n\r\n\r\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\r\n  geom_point() +\r\n  stat_smooth(method = \"lm\", se = F) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nJust that simple and easy! Though, a minor drawback of this method is that, since the axes now represent the transformed values, the interpretation might become a bit not so straightforward (e.g., what is a diamond of -0.4 log10(carat), or a diamond with a log10(price) of around 3.5?!)\r\nMethod 2. Transformation of scales\r\nThe second method is transformation of scales. This is done by specifying the trans = argument in the scale_XXX_continuous() function:\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  scale_x_continuous(trans = \"log10\") + \r\n  scale_y_continuous(trans = \"log10\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nLooks pretty similar to the plot we get from the first method right? Basically, this second method does the same thing as the first one in the beginning: log-transforming the data. But then, instead of displaying the transformed vales on the axes like what the first method does, it actually converts them back into the original values. This is why you will find that the tick marks are equally-spaced yet their corresponding numbers are not equally-distanced.\r\nAgain, we fit a line using stat_smooth():\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  scale_x_continuous(trans = \"log10\") + \r\n  scale_y_continuous(trans = \"log10\") +\r\n  stat_smooth(method = \"lm\", se = F) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nIt is important to note that the line is fitted after the log transformation of data. In other words, the line is fitted using the log-transformed carat and price as the predictor and the response (i.e., log10(price) ~ log10(carat), not price~carat !!!). So in the plot, a price of around $3,000 for a 1.0 carat diamond actually represents the back-converted predicted log10-price for that diamond.\r\nIn fact, any statistical computations (e.g., fitted line, mean, median, error bars) applied to the data will always occur AFTER the transformation of scales. That is, the statistics will be computed on the log-transformed data!\r\nMethod 3. Transformation of coordinates\r\nThe third method is transformation of coordinates. This is done by specifying the transformation for the x and/or y axis in coord_trans():\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  coord_trans(x = \"log10\", y = \"log10\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nYou can see that the axes display original values, same as what we have seen in the second method. But it is pretty obvious that the tick marks are not equally-spaced, different from the second method (take a quick look back at the previous plot!).\r\nIndeed, what this third method does is that it converts the original linear axes into log axes and shifts the original tick marks (which are equally-spaced with equally-distanced numbers) to the new corresponding log positions (which of course will not be equally-spaced but the corresponding numbers are still the same). As a result, the numbers on the tick marks are equally-distanced yet the tick marks themselves are not equally-spaced.\r\nNow we call stat_smooth() to fit a line:\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  coord_trans(x = \"log10\", y = \"log10\", ylim = c(min(diamonds$price), NA)) + # Need to specify the lower limit for y-axis!\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nWhat! The line is not straight?! Yup, it is not straight. Your vision is fine! So why is that?\r\nThis is because the line is fitted using the original price and carat rather than the log-transformed data (i.e., price~carat, not log10(price) ~ log10(carat) !!!), after which the predicted price is then log-transformed and drawn on the plot. So after the transformation, the line will no longer be straight.\r\nDifferent from the second method, in this third method, any statistical computations applied to the data will always occur BEFORE the transformation of coordinates. That is, the statistics will be computed on the original data and then log-transformed to be shown on the plot!\r\nNote that here I also specify the lower limit (using min price value) for y-axis. Without this, you will get an error message saying something like “missing value where TRUE/FALSE needed”. The line is fitted using the original carat and price as the predictor and the response, and in this example we have some non-positive predicted values. These non-positive values are the culprit: the error arises when ggplot attempts to take log of them (remember the computed statistics will be log-transformed to be drawn on the plot)!\r\n\r\n\r\nlm_diamonds <- lm(price~carat, data = diamonds)\r\npredict(lm_diamonds) %>% head() # Non-positive predicted values exist\r\n\r\n\r\n          1           2           3           4           5 \r\n-472.382688 -627.511200 -472.382688   -6.997151  148.131362 \r\n          6 \r\n-394.818432 \r\n\r\npredict(lm_diamonds) %>% log10() %>% head() # NaNs produced when you take log of the non-positive values \r\n\r\n\r\n       1        2        3        4        5        6 \r\n     NaN      NaN      NaN      NaN 2.170647      NaN \r\n\r\nFor the second method (transformation of scales), in which the line is fitted and drawn after log transformation, there is no such problem because the predicted values (of course can be non-positive) do not need to undergo transformation again, and so you will always get a straight line!\r\nWhich transformation method to use?\r\nStill confused? In the following table, I summarize the similarities/differences among the three log transformation methods we have discussed:\r\n\r\n\r\n\r\n\r\nTransformation of variables\r\n\r\n\r\nTransformation of scales\r\n\r\n\r\nTransformation of coordinates\r\n\r\n\r\nAxis values\r\n\r\n\r\nTransformed\r\n\r\n\r\nOriginal\r\n\r\n\r\nOriginal\r\n\r\n\r\nAxis tick marks\r\n\r\n\r\nEqually-spaced\r\n\r\n\r\nEqually-spaced\r\n\r\n\r\nNot equally-spaced\r\n\r\n\r\nNumbers on tick marks\r\n\r\n\r\nEqually-distanced\r\n\r\n\r\nNot equally-distanced\r\n\r\n\r\nEqually-distanced\r\n\r\n\r\nStatistical computations\r\n\r\n\r\nAfter transformation\r\n\r\n\r\nAfter transformation\r\n\r\n\r\nBefore transformation\r\n\r\n\r\nShape of geoms\r\n\r\n\r\nNot affected\r\n\r\n\r\nNot affected\r\n\r\n\r\nMight be affected*\r\n\r\n\r\n*E.g., the fitted straight line becomes curved.\r\n And here is a simple dichotomous key to which method to use for your figures (of course it is my opinion, not the standard rule!):\r\nYou are fine with log-transformed axis values…………………….. Method 1\r\nYou want your axis to display original values…………………………………2\r\nYou want to preserve the shape of geoms and it is okay for the statistics to be computed on the log-transformed data (geom-focused)………Method 2\r\nYou want the statistics to be computed on the original data and it is okay to have the shape of geoms altered (stat-focused)…………………..Method 3\r\nThis is the end of this rather long post. Hooray! Hope it is worth the time and you do learn something useful. And as always, don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-05-07-post-2-three-ways-to-create-log-axes-in-ggplots-which-one-should-you-use/../../homepage_images/Post2.png",
    "last_modified": "2021-06-07T19:33:34-07:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-05-01-post-1-center-long-legend-titles-in-ggplots/",
    "title": "Post #1. Center long legend titles in ggplots",
    "description": "In this post, I will show you a simple quick hack to center long legend titles in ggplots without bothering gtables and grobs.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-05-01",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nBefore we start\r\n“Blogenesis”! This is the origin of my first ggGallery blog post! Feel excited to write about something in which I am interested. This very first post is a simple one, but I bet it will be pretty handy. Hope you learn something from this post. Most importantly, enjoy the reading!\r\nThe problem\r\nWhen making a ggplot with legend, the legend title is left-aligned by default:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Cyl\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nIf you are happy with it, then fine. But oftentimes, we would like to align the legend title to the center so that the legend looks more balanced. For short titles, this is easy to achieve, just use theme(legend.title.align = 0.5):\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Cyl\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title.align = 0.5) # Align the title to the center\r\n\r\n\r\n\r\n\r\nHowever, for legend titles that are longer than the legend keys and labels, this method does not work:\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title.align = 0.5) # Not work!\r\n\r\n\r\n\r\n\r\nThere is a solution to this problem on stackoverflow. Basically, what it does is to extract the individual elements from the legend grobs, add extra space, and finally piece them back together. This method really delves into the heart of ggplots, but such “brute force” method might require quite a bit of time as well as decent understandings of how ggplot legends is built.\r\nSo isn’t there a simpler and more elegant way to do so?\r\nThe hack\r\nThe answer to this question is a complete no-brainer: Yes! Otherwise, I will not be writing this blog, right?! Here is the hack: just use “negative” left margin around the legend title:\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = -25))) # Negative left margin\r\n\r\n\r\n\r\n\r\nNow the title lies nicely in the center of the legend. Hooray!\r\nThe explanation\r\nSo how does negative margin work? Let’s visualize it by showing the legend box border. By default, there is no margin around the title, which will fit just right within the box border:\r\n\r\n\r\n# Default left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = 0)), \r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Default margin\")\r\n\r\n\r\n\r\n\r\nIf you specify a positive left margin, then there will be extra space added between the title and left box border:\r\n\r\n\r\n# Positive left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = 25)),\r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Positive left margin\")\r\n\r\n\r\n\r\n\r\nBut if you specify a negative margin, then you are asking ggplot to add some “negative” space between the title and left box border, and what that means is that ggplot will “pull” the title toward left beyond the box border:\r\n\r\n\r\n# Negative left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 12) + \r\n  theme(legend.title = element_text(margin = margin(l = -25)),\r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Negative left margin\")\r\n\r\n\r\n\r\n\r\nAnd after removing the box border, you will find that the title just moves to the center of the legend!\r\nFinally, I think you might ask: what negative margin value should I specify? The answer is: it depends! It really depends on the relative length of your title to your legend keys and labels, and so you might need to try out a few different values and see how it goes. Though this might seem a bit tedious, it offers you the most flexibility to place your title at the exact position you desire. It is worth the effort!\r\nDefinitely try this tip out next time. And if you have any further ideas or questions, don’t forget to leave them below!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-05-01-post-1-center-long-legend-titles-in-ggplots/../../homepage_images/Post1.png",
    "last_modified": "2021-06-07T19:27:27-07:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 672
  }
]
