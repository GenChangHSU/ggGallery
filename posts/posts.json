[
  {
    "path": "posts/2024-07-03-post-35-creating-3d-plots-with-plotly/",
    "title": "Post #35. Creating 3D plots with plotly and rayshader",
    "description": "Bring your plots to the next dimension with `plotly` and `rayshader`!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2024-07-15",
    "categories": [
      "2024"
    ],
    "contents": "\r\n\r\nIntroduction\r\n2D plots with an x- and a y-axis displaying the relationships between two variables are probably the most common type of plots in our everyday life. If we want to incorporate more information into the plots, we can use different appearances (colors, sizes, shapes, etc.) of points and lines (or other graphic elements). But sometimes, visualizing the data in a 3D space can be more appealing and may even help us gain deeper insights into the data distribution. Although ggplot does not have geoms for 3D plots (at least by the time of this post), there are other R packages that do the job. And in this post, I’m going to introduce two of these packages to you: plotly and rayshader, both of which have functions for generating cool 3D plots. So buckle up and let’s get ready to bring our plots to the next dimension!\r\n3D plots with plotly\r\nThe first package we’ll be using is plotly. This package features interactive plots and contains functions for generating a wide array of figures. Moreover, plotly also provides the function ggplotly(), which converts ggplots to the corresponding interactive plots.\r\nHere, we’re going to explore the plotly functions for creating 3D plots. Specifically, we’ll create a 3D scatterplot with fitted lines and a 3D surface plot with contours and a path.\r\n(1) 3D scatterplot\r\nThe syntax for plotly is pretty similar to ggplot: we call the global function plotly() to create a plotting canvas (akin to ggplot()) and add other graphical elements using the function add_XXX() (akin to geom_XXX()).\r\nTo create a basic 3D scatterplot, we use the function add_markers() (similar to geom_point()). Simply pass the x-, y-, and z-coordinates to the function and specify the variable you would like to color the points by.\r\nTo add the lines, we use the function add_path() (similar to geom_path()). Again, simply pass the x-, y-, and z-coordinates to the function and specify the variable you would like to color the lines by.\r\nWe can modify the the appearance of the axes and legend using the function layout() (see here for a complete list of things you can adjust!).\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(plotly)\r\n\r\n### Model predictions\r\niris_lm_prediction <- iris %>% \r\n  group_by(Species) %>% \r\n  summarise(Model = list(lm(Petal.Length ~ Sepal.Length + Sepal.Width))) %>% \r\n  rowwise() %>% \r\n  mutate(Newdata = list(data.frame(Sepal.Length = range(Model$model$Sepal.Length),\r\n                                   Sepal.Width = range(Model$model$Sepal.Width)))) %>% \r\n  mutate(Prediction = list(cbind(Newdata, Prediction = predict(Model, newdata = Newdata)))) %>% \r\n  dplyr::select(Species, Prediction) %>% \r\n  unnest(col = Prediction)\r\n\r\n### Create a 3D scatterplot with the fitted lines\r\nscatterplot3d <- plot_ly() %>% \r\n  # add the points\r\n  add_markers(data = iris, \r\n              x = ~ Sepal.Length, \r\n              y = ~ Sepal.Width, \r\n              z = ~ Petal.Length, \r\n              color = ~ Species, \r\n              colors = c(\"#BF382A\", \"#0C4B8E\", \"#018571\"),\r\n              size = 2) %>% \r\n  # add the lines\r\n  add_paths(data = iris_lm_prediction,\r\n            x = ~ Sepal.Length, \r\n            y = ~ Sepal.Width, \r\n            z = ~ Prediction,\r\n            color = ~ Species,\r\n            colors = c(\"#BF382A\", \"#0C4B8E\", \"#018571\"),\r\n            showlegend = F) %>% \r\n  layout(legend = list(x = 0.9, y = 0.5),\r\n         scene = list(xaxis = list(title = \"Sepal length\", range = list(4, 8)),\r\n                      yaxis = list(title = \"Sepal width\", range = list(1, 5)),\r\n                      zaxis = list(title = \"Petal length\", range = list(1, 7))))\r\n\r\nscatterplot3d\r\n\r\n\r\n\r\n(2) 3D surface plot\r\nThe second plot we’re going to create is a 3D surface plot with contour lines. This can be done via the function add_surface(), which takes a matrix (instead of a dataframe column or a vector) as the input for the argument “z”. The contour lines are added via the argument “contour”.\r\nIn the example below, we first estimated the kernel density of the Sepal.Length and Sepal.Width in the iris dataset using the kde2d() from the MASS package. The function returns a matrix of the kernel density estimates, with Sepal.Length as the row and Sepal.Width as the column. This matrix can be passed directly to the “z” argument in add_surface() to generate a 3D surface plot. Additionally, we can specify the x- and y-axis via the argument “x” and “y”. Also note that the matrix column is treated as the x-axis (which is “Sepal.Width”) and the matrix row is treated as the y-axis (which is “Sepal.Length”) in the plot, so make sure you’re specifying the correct variables for the axes (it’s a bit confusing I know!).\r\nFinally, we can add a random path that traverses across the 3D landscape surface, using the function add_paths().\r\n\r\n\r\nlibrary(MASS)\r\n\r\n### 2D kernel density estimates of Sepal.Length and Sepal.Width\r\n### The result is a 100-by-100 matrix with Sepal.Length as the row and Sepal.Width as the column\r\niris_kd_matrix <- kde2d(iris$Sepal.Length, iris$Sepal.Width, n = 100)[[3]]\r\n\r\n### Create a 3D surface plot with contours\r\n### Note that the matrix column (Sepal.Width) will be plotted as the x-axis and the matrix row (Sepal.Length) will be plotted as the y-axis\r\nsurfaceplot3d <- plot_ly() %>%\r\n  add_surface(x = seq(min(iris$Sepal.Width), max(iris$Sepal.Width), length.out = 100),  # x is the matrix column, corresponding to Sepal.Width\r\n              y = seq(min(iris$Sepal.Length), max(iris$Sepal.Length), length.out = 100),  # y is the matrix row, corresponding to Sepal.Length\r\n              z = iris_kd_matrix,  # takes a matrix as the input\r\n              contours = list(z = list(start = 0, \r\n                                       end = 0.5, \r\n                                       size = 0.1,\r\n                                       show = T, \r\n                                       usecolormap = F))) %>% \r\n  layout(scene = list(xaxis = list(title = \"Sepal width\"),\r\n                      yaxis = list(title = \"Sepal length\"),\r\n                      zaxis = list(title = \"Density\")))\r\n\r\n### Create a dataframe of a random path across the 3D surface\r\nset.seed(123)\r\n\r\nrandom_path_df <- data.frame(x = 1, y = 1)\r\nmax_random_path_df <- 1\r\ni <- 1\r\n\r\nwhile (max_random_path_df < 100) {\r\n  random_path_df[i + 1, ] <- random_path_df[i, ] + sample(c(0, 1), size = 2, replace = F)\r\n  max_random_path_df <- max(random_path_df)\r\n  i <- i + 1\r\n}\r\n\r\nrandom_path_df <- random_path_df %>% \r\n  rowwise() %>% \r\n  mutate(Density = iris_kd_matrix[x, y]) %>% \r\n  mutate(Sepal.Length = seq(min(iris$Sepal.Length), max(iris$Sepal.Length), length.out = 100)[x], \r\n         Sepal.Width = seq(min(iris$Sepal.Width), max(iris$Sepal.Width), length.out = 100)[y])\r\n\r\n### Add the random path to the plot\r\nsurfaceplot3d <- surfaceplot3d %>% \r\n  add_paths(data = random_path_df, \r\n            x = ~ Sepal.Width,  # again the x-axis is Sepal.Width \r\n            y = ~ Sepal.Length,  # again the y-axis is Sepal.Length\r\n            z = ~ Density, \r\n            line = list(width = 4))\r\n\r\nsurfaceplot3d\r\n\r\n\r\n\r\n(3) Save the plot\r\nTo save the plot, we can set the configuration options using config() and specify the file format, file name, figure width and height (in pixels), and the scale of the figure (a scale larger than 1 will enlarge the figure). After that, adjust the plot to a desired view and click the camera icon “Download plot as a png” on the mode bar to download it.\r\nAlternatively, we can install the application Orca and save the plot directly using the function orca(). See this page for more details. Of course, we can modify the default plot view by specifying the x, y, and z values in the “eye” argument before we save it.\r\n\r\n\r\n### Option 1. Download the plot from the mode bar\r\n### Set the configuration options and click the download icon\r\nconfig(surfaceplot3d, toImageButtonOptions = list(format = \"png\",\r\n                                                  filename = \"Surfaceplot3d\",\r\n                                                  height = 500,\r\n                                                  width = 700,\r\n                                                  scale = 2))\r\n\r\n\r\n\r\n### Option 2. Save the plot using the function orca()\r\n# modify the plot view\r\nsurfaceplot3d_newview <- surfaceplot3d %>% \r\n  layout(scene = list(camera = list(eye = list(x = 1.5, y = -1.5, z = 1.5))))\r\n\r\nsurfaceplot3d_newview\r\n\r\n\r\n\r\n# save the plot\r\norca(surfaceplot3d_newview, file = \"Surfaceplot3d.png\", width = 700, height = 500, scale = 2)\r\n\r\n\r\n\r\n3D plots with rayshader\r\nThe second package we’re going to explore is rayshader. rayshader features awesome 3D elevation maps using a combination of raytracing and hillshading techniques. Besides maps, the package also has the function plot_gg() that converts ggplots to 3D plots, which you’ll see in a moment. plot_gg() will recognize the “fill” and “color” aesthetic and ignore other aesthetics such as “shape” and “linetype” that cannot be rendered into a 3D view. Let’s take a look at some examples below.\r\n3D contour plot\r\nIn this example, we first created a contour plot in ggplot and then passed the ggplot object to plot_gg(). We can specify additional arguments for the 3D plot: the width and height of the plot, the height of the z-axis, the shadow intensity, the isometric field of view angle, the zoom level, the angle of rotation around the z-axis, etc. The 3D plot will be displayed in a pop-up window. To save the plot as a png file, simply run rander_snapshot(filename = ).\r\n\r\n\r\nlibrary(rayshader)\r\n\r\n### Create a contour ggplot\r\ncontourplot <- ggplot(data = iris) +\r\n  geom_density_2d_filled(aes(x = Sepal.Length, y = Sepal.Width, fill = after_stat(nlevel)),\r\n                         n = 100, bins = 20, contour = TRUE) +\r\n  scale_fill_viridis_c() + \r\n  theme_bw()\r\n\r\n### Convert the contour ggplot to a 3D plot\r\nplot_gg(contourplot, \r\n        width = 3.5,  # the width of the 3D plot in inch \r\n        height = 3,  # the height of the 3D plot in inch\r\n        scale = 250,  # the scaling factor controlling the height of the z-axis\r\n        shadow_intensity = 0.8,  # 0 means full shade and 1 means no shade\r\n        fov = 25,  # the isometric field of view angle\r\n        zoom = 0.6,  # the zoom factor; a value smaller than 1 zooms in on the plot\r\n        theta = 0,  # the rotation around the z-axis\r\n        windowsize = c(900, 900)  # the size of the pop-up window\r\n        )\r\n\r\nrender_snapshot(filename = \"Contourplot3d\")  # save the 3D plot as a png file\r\n\r\n\r\n\r\n\r\n\r\nHere is another example of converting a ggplot heatmap into a 3D plot:\r\n\r\n\r\n### 2D kernel density estimates of Sepal.Length and Sepal.Width\r\nsepal_length_vec <- seq(min(iris$Sepal.Length), max(iris$Sepal.Length), length.out = 30)\r\nSepal_width_vec <- seq(min(iris$Sepal.Width), max(iris$Sepal.Width), length.out = 30)\r\niris_kd_vec <- kde2d(iris$Sepal.Length, iris$Sepal.Width, n = 30)[[3]] %>% \r\n  as.vector()\r\n\r\niris_kd_df <- expand.grid(sepal_length_vec, Sepal_width_vec) %>% \r\n  mutate(Density = iris_kd_vec) %>% \r\n  rename(Sepal_length = Var1,\r\n         Sepal_width = Var2)\r\n\r\n### Create a ggplot heatmap\r\nheatmap <- ggplot(iris_kd_df) + \r\n  geom_tile(aes(x = Sepal_length, y = Sepal_width, fill = Density)) + \r\n  scale_fill_viridis_c() + \r\n  theme_bw()\r\n\r\n### Convert the heatmap to a 3D plot\r\nplot_gg(heatmap, \r\n        width = 3.5,\r\n        height = 3, \r\n        scale = 250,\r\n        shadow_intensity = 0.8,  \r\n        fov = 25,  \r\n        zoom = 0.6,  \r\n        theta = 0,  \r\n        windowsize = c(900, 900))\r\n\r\nrender_snapshot(filename = \"Heatmap3d\")\r\n\r\n\r\n\r\n\r\n\r\nSummary\r\nTo recap, we explored two packages for 3D data visualization in R. The first one is plotly, which creates a variety of interactive plots, and we made a 3D scatterplot and a 3D contour plot with it. The second one is rayshader, which has the function plot_gg() to convert a 2D ggplot into a 3D plot, and we did that using examples of a contour plot and a heatmap. There are a lot more different kinds of 3D plots you can make with these two packages—the sky’s the limit, and we only scratched the surface here. But at least now you know the basics and you can go on to explore more!\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2024-07-03-post-35-creating-3d-plots-with-plotly/../../homepage_images/Post35.png",
    "last_modified": "2024-07-16T21:23:00-04:00",
    "input_file": {},
    "preview_width": 900,
    "preview_height": 700
  },
  {
    "path": "posts/2024-06-11-post-34-connecting-paired-points-by-groups-in-ggplots/",
    "title": "Post #34. Connecting paired points in ggplots",
    "description": "Check out the handy tips for connecting paired points in ggplots!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2024-06-11",
    "categories": [
      "2024"
    ],
    "contents": "\r\n\r\nIntroduction\r\nFeel so glad (and relieved) to blog again after three months of rest! This post was actually inspired by a recent project I am working on: I wanted to make a ggplot comparing the feeding response of control vs. treatment for each larval parent family on two plant types, and I would like to draw a line connecting the control-treatment pair for each family for each plant type. I thought it was a walk in the park, but when I started making the plot, it turned out to be more complicated than I imagined. Thankfully, after a bit of researching and experimenting, I figured it out and I felt it would be helpful to write something about it. So in this post, I’ll show you the tips for connecting paired points in ggplots. Let’s do it!\r\nCase 1. A single group\r\nWe will use the built-in CO2 dataset, which contains data from an experiment looking at how chilling affected the CO2 uptake rates of the grass species Echinochloa crus-galli.\r\nLet’s start with the simplest case where we compare the CO2 uptake rates of the nonchilled vs. chilled plant individual #1 at different ambient CO2 concentrations. We’ll draw a line between each nonchilled-chilled pair to show the treatment effect.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Select plant individual #1\r\nCO2_plant_1 <- filter(CO2, Plant %in% c(\"Qn1\", \"Qc1\")) \r\n  \r\n### Plot  \r\nggplot(CO2_plant_1) + \r\n  geom_point(aes(x = Treatment, y = uptake, shape = Treatment, color = factor(conc))) + \r\n  geom_line(aes(x = Treatment, y = uptake, color = factor(conc), group = factor(conc))) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"Ambient [CO2]\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nLooks like chilling reduces CO2 uptake rates of plant individual #1 under all ambient CO2 concentrations.\r\nCase 2. Two or more groups\r\nNow, what if we’re interested in other plant individuals? Would the patterns be similar? Let’s make another plot and see.\r\n\r\n\r\n### Select plant individual #1 to #3\r\nCO2_plant_1_to_3 <- filter(CO2, Plant %in% c(\"Qn1\", \"Qc1\", \"Qn2\", \"Qc2\", \"Qn3\", \"Qc3\")) %>% \r\n  mutate(Plant_id = str_remove(Plant, \"(n|c)\")) %>% \r\n  mutate(Plant_conc_id = str_c(Plant_id, conc, sep = \"_\"))  # create a unique id for the paired points\r\n  \r\n### Plot  \r\nggplot(CO2_plant_1_to_3) + \r\n  geom_point(aes(x = Plant_id, y = uptake, group = Treatment, shape = Treatment, color = factor(conc)),\r\n             position = position_dodge(width = 0.8)) + \r\n  geom_line(aes(x = Plant_id, y = uptake, group = Plant_conc_id, color = factor(conc)),\r\n            position = position_dodge(width = 0.8)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"Ambient [CO2]\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nOops it doesn’t work. How can we solve this problem? Read below!\r\nMethod 1. Use facets\r\nThe first method is to create separate panels for each plant individual using facets. This is a easy quick fix.\r\n\r\n\r\n### Plot  \r\nggplot(CO2_plant_1_to_3) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = factor(conc))) + \r\n  geom_line(aes(x = Treatment, y = uptake, group = factor(conc), color = factor(conc))) + \r\n  facet_wrap( ~ Plant_id) +  # faceting by plant id\r\n  scale_color_brewer(palette = \"Set1\", name = \"Ambient [CO2]\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nAs we can see, all three plant individuals showed similar responses to chilling.\r\nMethod 2. Manually dodge the endpoints of the connecting lines\r\nThe second method is to manually dodge the endpoints of the connecting lines. This requires slightly more work, but is a non-facet alternative. So basically, we need to dodge the nonchilled and chilled points to the two sides of each plant individual (the x-positions of the three plants are indeed 1, 2, and 3), map the new dodged positions to the x aesthetic in geomline(), and specify each plant individual–CO2 concentration combination as the grouping variable. Sounds a bit abstract?! Let’s take a look at the code below to get a better idea of how it works.\r\n\r\n\r\n### Dodge the nonchilled and chilled points\r\nCO2_plant_1_to_3_recoded <- CO2_plant_1_to_3 %>% \r\n  mutate(Plant_id_x = case_when(Plant_id == \"Q1\" ~ 1,  # these are the x-positions of the three plant individuals\r\n                                Plant_id == \"Q2\" ~ 2,\r\n                                Plant_id == \"Q3\" ~ 3),\r\n         Plant_id_x_dodged = case_when(Treatment == \"nonchilled\" ~ Plant_id_x - 0.25,  # dodge the \"nonchilled\" points to the left of each plant individual\r\n                                       Treatment == \"chilled\" ~ Plant_id_x + 0.25))   # dodge the \"chilled\" points to the right of each plant individual\r\n\r\n### Plot\r\nggplot(CO2_plant_1_to_3_recoded) + \r\n  geom_point(aes(x = Plant_id, y = uptake, shape = Treatment, group = Treatment, color = factor(conc)),\r\n             position = position_dodge(width = 1)) + \r\n  geom_line(aes(x = Plant_id_x_dodged, y = uptake, group = Plant_conc_id, color = factor(conc))) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"Ambient [CO2]\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nWe made it!\r\nSummary\r\nTo recap, we looked at how to connect paired points with lines for a single group as well as for multiple groups. When there are multiple groups, we can use facets or manually dodge the endpoints of the lines. This type of paired-points plot is especially useful for visualizing the treatment effects, and I’m pretty sure you’ll be creating it in the future.\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2024-06-11-post-34-connecting-paired-points-by-groups-in-ggplots/../../homepage_images/Post34.png",
    "last_modified": "2024-06-15T21:02:59-04:00",
    "input_file": {},
    "preview_width": 1344,
    "preview_height": 768
  },
  {
    "path": "posts/2024-02-21-post-33-a-timely-plotvisualizing-time-series-in-ggplots/",
    "title": "Post #33. A \"timely\" plot—Visualizing time series data in ggplot",
    "description": "Let's create an awesome time series chart in ggplot!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2024-02-21",
    "categories": [
      "2024"
    ],
    "contents": "\r\n\r\nIntroduction\r\nWelcome to the first post of 2024! It’s been two months since my post last year, and I feel excited to be back in the saddle and write something about ggplots. Hope we’ll have another year of posts full of useful and fun topics!\r\nI’ll kick things off here with a time series chart, which is essentially a type of line chart with “time” on the x-axis. ggplot offers a family of functions that work with time, and we’re going to explore one of those functions in this post and create a nice time series chart.\r\nThe data\r\nMost of the time, I use built-in R datasets for my posts. But this time it’s a bit different: I’m using the data I collected myself!\r\nI had been recording the number of black kites (Milvus migrans) along the Xindian river in Taipei, Taiwan pretty much every day (except for a few times when I was out of town) from November 2022 to August 2023. This dataset consists of the daily black kite counts, the sites of the observations, and the weather conditions.\r\nLet’s take a quick look at the dataset:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Read the data\r\nblack_kite_raw <- read_csv(\"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2024-02-21-post-33-a-timely-plotvisualizing-time-series-in-ggplots/Black_Kite_Records.csv\")\r\n\r\n### Organize the data\r\nblack_kite_clean <- black_kite_raw %>% \r\n  mutate(Date = ymd(Date)) %>% \r\n  select(Date, Site, Number, Weather)\r\n\r\nhead(black_kite_clean)\r\n\r\n# A tibble: 6 × 4\r\n  Date       Site            Number Weather         \r\n  <date>     <chr>            <dbl> <chr>           \r\n1 2022-11-17 Huajiang_bridge      0 Sunny_with_cloud\r\n2 2022-11-18 Huajiang_bridge      0 Sunny_with_cloud\r\n3 2022-11-19 Huajiang_bridge      7 Sunny           \r\n4 2022-11-20 Huajiang_bridge      1 Cloudy          \r\n5 2022-11-21 Huajiang_bridge      2 Cloudy          \r\n6 2022-11-22 Huajiang_bridge      0 Sunny_with_cloud\r\n\r\nMost observations came from the site “Huajiang Bridge”, so I’ll focus on this particular site from now on. Below is a map of Huajiang Bridge created via ggmap:\r\n\r\n\r\nlibrary(ggmap)\r\n\r\n### Need to register an API key for Stadia Maps and for Google Maps\r\nregister_stadiamaps(key = \"your key\")\r\nregister_google(key = \"your key\")\r\n\r\n### Get the long-lat coordinates of the site\r\nhuajiang_bridge_lon_lat <- geocode(\"Huajiang Bridge, Wanhua District\")\r\n\r\n### Create a map\r\nmap_data <- get_stadiamap(bbox = c(left = huajiang_bridge_lon_lat$lon - 0.05, \r\n                                   bottom = huajiang_bridge_lon_lat$lat - 0.04, \r\n                                   right = huajiang_bridge_lon_lat$lon + 0.05, \r\n                                   top = huajiang_bridge_lon_lat$lat + 0.04), \r\n                          zoom = 14, \r\n                          maptype = \"stamen_terrain\")\r\n\r\nggmap(map_data) + \r\n  annotate(geom = \"rect\", \r\n           xmin = huajiang_bridge_lon_lat$lon - 0.01,\r\n           ymin = huajiang_bridge_lon_lat$lat - 0.01,\r\n           xmax = huajiang_bridge_lon_lat$lon + 0.01,\r\n           ymax = huajiang_bridge_lon_lat$lat + 0.01,\r\n           fill = NA,\r\n           color = \"red\",\r\n           linewidth = 1.5) + \r\n  theme_void()\r\n\r\n\r\n\r\n\r\n\r\n\r\nThe time series chart\r\nNow comes the main topic of the post: creating a time series chart. I’ll break down the process into four steps and walk through them one by one.\r\n(1) Summarize the data by week\r\nInstead of plotting the daily kite counts, I decided to plot the weekly counts to better show the overall trend. To summarize the data by week, I first rounded the dates to the nearest weeks and summed the kite counts in each week. I also assigned a score to each of the four daily weather conditions and calculated the mean score for each week to represent the average weekly weather condition.\r\nAt the end of the code, I added a week ID column by computing the day differences from the first week and dividing the differences by 7. This week ID column is used for fitting a LOESS curve at step (2). Finally, I converted the rounded dates (object “Date”) to datetimes (object “POSIXct”) for plotting purposes at step (3) and (4).\r\n\r\n\r\n### Summarize the data by week\r\nblack_kite_clean_week <- black_kite_clean %>% \r\n  filter(Site == \"Huajiang_bridge\") %>%\r\n  mutate(Date_week = round_date(Date, \"week\")) %>%  # round the dates to the nearest weeks\r\n  mutate(Weather_score = case_when(Weather == \"Sunny\" ~ 3,  # assign a score to each weather condition\r\n                                   Weather == \"Sunny_with_cloud\" ~ 2,\r\n                                   Weather == \"Cloudy\" ~ 1,\r\n                                   Weather == \"Rainy\" ~ 0)) %>% \r\n  group_by(Date_week) %>% \r\n  summarise(Number_week = sum(Number),  # weekly kite counts\r\n            Weather_week = mean(Weather_score)) %>%  # average weekly weather condition\r\n  mutate(Week_id = as.double(Date_week - min(Date_week))/7) %>%   # week ID\r\n  mutate(Date_week = as_datetime(Date_week))  # convert dates to datetimes\r\n\r\nhead(black_kite_clean_week)\r\n\r\n# A tibble: 6 × 4\r\n  Date_week           Number_week Weather_week Week_id\r\n  <dttm>                    <dbl>        <dbl>   <dbl>\r\n1 2022-11-20 00:00:00          10        1.57        0\r\n2 2022-11-27 00:00:00          11        1.43        1\r\n3 2022-12-04 00:00:00          19        1           2\r\n4 2022-12-11 00:00:00          11        0.167       3\r\n5 2022-12-18 00:00:00          18        1.2         4\r\n6 2022-12-25 00:00:00           8        3           5\r\n\r\n(2) Fit a LOESS curve to the weekly black kite counts\r\nTo show the general trend over the observation period, I fit a LOESS curve to the weekly black kite counts, with a smaller span of 0.3 to capture more details. I then created a sequence of datetimes with an interval of six hours (for the sake of model predictions), computed the “week” differences of these datetimes from the first datetime, and made the LOESS predictions based on these week differences.\r\n\r\n\r\n### Fit a LOESS curve to the weekly black kite counts\r\nloess_model <- loess(Number_week ~ Week_id, data = black_kite_clean_week, span = 0.3)\r\n\r\n### Make predictions for the counts\r\nlibrary(modelr)  # for the function \"add_predictions()\"\r\n\r\nloess_predictions <- tibble(Date_seq = seq(min(black_kite_clean_week$Date_week),\r\n                                           max(black_kite_clean_week$Date_week), \r\n                                           by = \"6 hour\"),  # a sequence of datetimes with an interval of six hours,\r\n                            Week_id = as.numeric((Date_seq - min(black_kite_clean_week$Date_week))/86400)/7) %>%  # week differences from the first datetime\r\n  add_predictions(loess_model)  # make the LOESS predictions\r\n\r\nhead(loess_predictions)\r\n\r\n# A tibble: 6 × 3\r\n  Date_seq            Week_id  pred\r\n  <dttm>                <dbl> <dbl>\r\n1 2022-11-20 00:00:00  0       10.1\r\n2 2022-11-20 06:00:00  0.0357  10.2\r\n3 2022-11-20 12:00:00  0.0714  10.3\r\n4 2022-11-20 18:00:00  0.107   10.4\r\n5 2022-11-21 00:00:00  0.143   10.5\r\n6 2022-11-21 06:00:00  0.179   10.6\r\n\r\n(3) Create the time series chart\r\nWith the required data at hand, it’s time to create the time series chart! This chart contains points for the weekly kite counts, line segments joining the points, and the fitted LOESS curve from step (2). I went a bit fancy here by making the points blurry using the function geom_point_blur() from the package ggblur. I also drew a gradient fill background using the function geom_rect_pattern from the package ggpattern. (Note that I added the geom layers in a reversed order to have the points on the top, the lines in the middle, and the background at the very bottom.)\r\nRemember I mentioned in the introduction that we would be using one of the functions that ggplot offers to work with time. That function is scale_x_datetime(), which allows for customizing the appearance of x-axis using date/time specifications. In the code below, I specified the x-axis limits using two datetimes, placed the x-axis breaks at an one-month interval (” date_breaks = “1 month” “), and labeled the x-axis using the R date/time format (” date_labels = “%b ’%y” “; %b represents the abbreviated month name and %y represents the two-digit year; see this documentation for more details).\r\n\r\n\r\nlibrary(ggpattern)  # for the function \"geom_rect_pattern()\"\r\nlibrary(ggblur)  # for the function \"geom_point_blur()\"\r\n\r\np_black_kite <- ggplot(black_kite_clean_week) + \r\n  geom_rect_pattern(aes(xmin = floor_date(min(black_kite_clean_week$Date_week), \"month\"), \r\n                        xmax = ceiling_date(max(black_kite_clean_week$Date_week), \"month\"), \r\n                        ymin = -Inf, \r\n                        ymax = 23),\r\n                    pattern_fill = \"#99d6ff\", pattern_fill2 = \"#ccebff\", pattern = \"gradient\") + \r\n  geom_line(aes(x = Date_week, y = Number_week), color = \"black\", alpha = 0.05) + \r\n  geom_line(data = loess_predictions, aes(x = Date_seq, y = pred),\r\n            color = \"grey60\", linewidth = 2, lineend = \"round\") + \r\n  geom_point_blur(aes(x = Date_week, y = Number_week, color = Weather_week), \r\n                  size = 3, blur_size = 10) + \r\n  scale_x_datetime(limits = c(floor_date(min(black_kite_clean_week$Date_week), \"month\"),\r\n                              ceiling_date(max(black_kite_clean_week$Date_week), \"month\")), \r\n                   expand = c(0, 3), date_breaks = \"1 month\", date_labels = \"%b '%y\") +\r\n  scale_y_continuous(limits = c(-1, 23), breaks = seq(0, 20, 10), \r\n                     labels = c(\"0 \", \"10\", \"20\"), expand = c(0, 0)) + \r\n  scale_color_gradient(low = \"#cce6ff\", high = \"#FFBA00\") +\r\n  theme_classic()\r\n\r\np_black_kite\r\n\r\n\r\n\r\n(4) Polish the chart\r\nLet’s finish up by polishing the chart to make it more visually appealing:\r\nI added a title and an image of a black kite via the HTML syntax using the function geom_richtext() from the package ggtext.\r\nI downloaded the font “Quintessential” from Google Fonts using the function font_add_google(), and applied it to the numbers and text in the chart using the function showtext_auto(). Both functions come from the package showtext.\r\nI removed the axis titles and flipped the y-axis ticks and text to the inner side of the panel.\r\nI changed the legend position and direction, and added the labels manually.\r\n\r\n\r\nlibrary(ggtext)\r\nlibrary(showtext)\r\n\r\n### Download and use the Google Fonts \"Quintessential\"\r\nfont_add_google(name = \"Quintessential\", family = \"Quintessential\")\r\nshowtext_auto()\r\n\r\n### The HTML tag for the title and the black kite image\r\ntitle_text <- \"Weekly Black Kite <span> <\/span> <span> <\/span> Counts at Huajiang Bridge\"\r\ntitle_image <- \"<img src='https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2024-02-21-post-33-a-timely-plotvisualizing-time-series-in-ggplots/Black_Kite.png' width='50'/>\"\r\n\r\n### The final polished chart\r\np_black_kite_final <- p_black_kite + \r\n  geom_richtext(data = NULL, aes(x = as_datetime(\"2023-05-15\"), y = 20, label = title_text),\r\n                fill = NA, label.color = NA, size = 10, family = \"Quintessential\") + \r\n  geom_richtext(data = NULL, aes(x = as_datetime(\"2023-05-04\"), y = 20.4, label = title_image),\r\n                fill = NA, label.color = NA) +\r\n  geom_hline(aes(yintercept = 23), color = \"white\", linewidth = 1) + \r\n  labs(x = NULL, y = NULL) +\r\n  guides(color = guide_colorbar(ticks.colour = \"transparent\")) + \r\n  theme(# panel margin\r\n        plot.margin = margin(t = 10, b = 20, l = 35, r = 25),\r\n        \r\n        # axis appearance and text\r\n        axis.line = element_blank(),\r\n        axis.text.x = element_text(size = 18, family = \"Quintessential\"),\r\n        axis.text.y = element_text(size = 20, margin = margin(r = -20), family = \"Quintessential\"),\r\n        axis.ticks.x = element_blank(),\r\n        axis.ticks.y = element_line(color = \"grey60\"),\r\n        axis.ticks.length.y = unit(-0.2, \"cm\"),\r\n        \r\n        # legend\r\n        legend.position = c(0.8, 0.7),\r\n        legend.direction = \"horizontal\",\r\n        legend.background = element_blank(),\r\n        legend.title = element_blank(),\r\n        legend.text = element_blank()\r\n        ) + \r\n  annotate(geom = \"text\", x = as_datetime(\"2023-06-05\"), y = 16.2, \r\n           label = \"Rainy\", family = \"Quintessential\", size = 5.5) + \r\n  annotate(geom = \"text\", x = as_datetime(\"2023-08-01\"), y = 16.2, \r\n           label = \"Sunny\", family = \"Quintessential\", size = 5.5)\r\n\r\np_black_kite_final\r\n\r\n\r\n\r\nWe made it. Hooray!\r\nAs we can see from the chart, the black kites seemed to be more active in the winter (November to February) and less so in the spring (March to May). There was a small peak in June, and the counts increased again in August. Unfortunately, I didn’t have data from September to November and therefore we can’t really see the full-year dynamics.\r\nAnother thing to note is that the weather conditions didn’t seem to be strongly associated with the weekly kite counts: the kites were out on both sunny and rainy days. However, this is just a visual guess and we certainly need a formal analysis to verify it.\r\nSummary\r\nTo recap what we did in this post, we first summarized the daily black kite counts and weather conditions by week. We then fit a LOESS curve to the weekly counts and made predictions over the observation period. After that, we created a time series chart of the weekly counts with the fitted LOESS curve to show the general trend. Finally, we polished the chart by adding a title and a black kite image as well as modifying the font, text, and legend.\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2024-02-21-post-33-a-timely-plotvisualizing-time-series-in-ggplots/../../homepage_images/Post33.png",
    "last_modified": "2024-03-01T11:06:57-05:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 672
  },
  {
    "path": "posts/2023-12-24-post-32-ggplot-map-series-no5-map-annotation-with-ggsn/",
    "title": "Post #32. ggplot Map Series No.5: Scale bar and north arrow with `ggsn`",
    "description": "Enhance your map with a scale bar and a north arrow using the package `ggsn`!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-12-24",
    "categories": [
      "2023",
      "Map Series"
    ],
    "contents": "\r\n\r\nIntroduction\r\nHave you ever created a map in ggplot and wondered how to add a scale bar and a north arrow to it? Well, you can do it easily using the package ggsn, and this is the topic for this short post.\r\nAn annotated topographic map of Taiwan\r\n(1) Create a topographic map\r\nWe’ll create a topographic map of Taiwan as our example here. First, we’ll use the function get_elev_raster() from the package elevatr to retrieve the elevation tiles of Taiwan from the online map databases. Basically, what we need to do is to read in a shapefile of the area of interest and pass it to the function. It’ll return a “RasterLayer” object, which is then converted to a dataframe for plotting in ggplot.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Download and read in the shapefile of Taiwan's administrative boundary\r\n### The zipped shapefile is available in the GitHub folder of this post\r\nlibrary(sf)\r\n\r\nTaiwan_boundary_admin0_url <- \"https://github.com/GenChangHSU/ggGallery/blob/master/_posts/2023-12-24-post-32-ggplot-map-series-no5-map-annotation-with-ggsn/geoBoundaries-TWN-ADM0-all.zip?raw=TRUE\"\r\ndownload.file(Taiwan_boundary_admin0_url, \"geoBoundaries-TWN-ADM0-all.zip\", mode = \"wb\")\r\nunzip(\"geoBoundaries-TWN-ADM0-all.zip\")\r\n\r\nTaiwan_boundary_admin0 <- st_read(\"geoBoundaries-TWN-ADM0-all/geoBoundaries-TWN-ADM0.shp\", quiet = T)\r\n\r\n### Get the elevation tiles of Taiwan\r\nlibrary(elevatr)\r\n\r\nTaiwan_elevation <- get_elev_raster(locations = Taiwan_boundary_admin0,  # the shapefile\r\n                                    z = 9,  # z controls the resolution of the elevation tiles\r\n                                    clip = \"locations\"  # clip the tiles to the polygon area\r\n                                    ) %>%  \r\n  terra::as.data.frame(xy = T, na.rm = T) %>%  # convert the RasterLayer to a dataframe\r\n  `colnames<-`(c(\"lon\", \"lat\", \"elevation\")) %>%  # rename the columns \r\n  mutate(elevation = if_else(elevation < 0 | is.na(elevation), 0, elevation))  # set the negative elevation values and NAs to 0\r\n\r\n### Make the topographic map\r\nlibrary(tidyterra)  # for the function hypso.colors()\r\ntopo_pal <- hypso.colors(n = 10, palette = \"dem_poster\")  # a topographic color palette\r\n\r\nTaiwan_topographic_map <- ggplot() + \r\n  geom_raster(data = Taiwan_elevation, aes(x = lon, y = lat, fill = elevation), show.legend = F) +\r\n  scale_fill_gradientn(colors = topo_pal,\r\n                       values = c(seq(0, 0.35, length.out = 5), seq(0.5, 1, length.out = 5))) +\r\n  coord_sf(xlim = c(119, 123), ylim = c(21.5, 25.5)) +\r\n  labs(x = NULL, y = NULL) + \r\n  theme_bw() + \r\n  theme(panel.grid = element_blank())\r\n\r\nTaiwan_topographic_map\r\n\r\n\r\n\r\n(2) Add a scale bar\r\nIt’s time to add a scale bar! ggsn has the function scalebar() for it. There are several things we can customize: the position of the scale bar, the distance and unit of the bar segment, the appearance of the bar and bar labels, etc. Let’s see how it works:\r\n\r\n\r\nlibrary(ggsn)\r\n\r\nTaiwan_topographic_map_annotated <- Taiwan_topographic_map + \r\n  scalebar(x.min = 121.9, \r\n           x.max = 122.9,\r\n           y.min = 21.6,\r\n           y.max = 22.1,\r\n           dist = 50,  # the distance of the bar segment\r\n           dist_unit = \"km\",  # the unit of the bar segment\r\n           transform = TRUE,  # \"TRUE\" if the coordinates are in the long-lat format\r\n           model = \"WGS84\",  # ellipsoid model for the transformation if \"transform = TRUE\"\r\n           height = 0.2,  # the height of the scale bar\r\n           st.dist = 0.2,  # the distance between the scale bar and the bar labels\r\n           st.size = 2.5,  # the size of the bar labels\r\n           border.size = 0.25  # the width of the bar border\r\n           )  \r\n\r\nTaiwan_topographic_map_annotated\r\n\r\n\r\n\r\n(3) Add a north arrow\r\nNext, the north arrow. This is also easy-peasy: Just use the function north() and specify the position as well as the type of the arrow you like (there are various types of north arrows available; use northSymbols() to see them), and you’re all set! We’ll also add an “N” above the north arrow. It does take some experimentation to get the desired arrow position and size, so be patient!\r\n\r\n\r\nTaiwan_topographic_map_annotated <- Taiwan_topographic_map_annotated + \r\n  north(x.min = 122.58, \r\n        x.max = 122.68, \r\n        y.min = 22.4, \r\n        y.max = 22.6, \r\n        symbol = 10,  # the type of the north arrow\r\n        scale = 5  # the size of the north arrow\r\n        ) + \r\n  annotate(geom = \"text\", x = 122.45, y = 22.5, label = \"N\", size = 5)\r\n\r\nTaiwan_topographic_map_annotated\r\n\r\n\r\n\r\nDone!\r\n(4) Fun with map\r\nLet’s play around with the map (a bit extra and just for fun)!\r\n\r\n\r\n### A vector of individual characters in the title\r\ntitle_vec <- str_split(\"A Topographic Map of Taiwan\", pattern = \"\")[[1]]\r\n\r\n### Italicize the letters\r\ntitle_vec_italic <- if_else(title_vec == \" \", title_vec, str_glue(\"_{title_vec}_\"))\r\n\r\n### A dataframe for mapping the characters to the plot\r\nx_seq <- seq(119.2, 121.8, by = 0.1)\r\nx_nudge <- c(-0.04, 0.00, 0.02, 0.02, -0.04, 0.00, -0.03, 0.00, 0.00, -0.03, \r\n             0.02, 0.01, 0.01, 0.00, 0.02, 0.07, 0.04, 0.00, 0.04, -0.01, \r\n             0.05, 0.05, 0.05, 0.05, 0.07, 0.09, 0.11)\r\nx_position <- x_seq + x_nudge\r\n\r\ntitle_df <- data.frame(x = x_position, \r\n                       y = 25.6, \r\n                       label = title_vec_italic)\r\n\r\n### The font\r\nlibrary(showtext)\r\nfont_add_google(\"IM FELL English\")\r\nshowtext_auto()\r\n\r\n### The map\r\nlibrary(ggtext)\r\n\r\nggplot() + \r\n  geom_raster(data = Taiwan_elevation, aes(x = lon, y = lat, fill = elevation), show.legend = F) +\r\n  geom_richtext(data = title_df, aes(x = x, y = y, label = label, color = x),\r\n                fill = NA, \r\n                label.color = NA, \r\n                family = \"IM FELL English\",\r\n                size = 7,\r\n                show.legend = F) + \r\n  scale_fill_gradientn(colors = topo_pal,\r\n                       values = c(seq(0, 0.35, length.out = 5), seq(0.5, 1, length.out = 5))) +\r\n  scale_color_gradientn(colors = topo_pal, limits = c(NA, 122.5)) + \r\n  coord_sf(xlim = c(119, 123), ylim = c(21.5, 25.73)) +\r\n  theme_void() + \r\n  theme(panel.background = element_rect(fill = \"#FEFEDF\", color = NA)) + \r\n  scalebar(x.min = 122.1, \r\n           x.max = 122.9,\r\n           y.min = 21.6,\r\n           y.max = 22.2,\r\n           dist = 50,\r\n           dist_unit = \"km\",\r\n           transform = TRUE,\r\n           model = \"WGS84\",\r\n           height = 0.1,\r\n           st.dist = 0.15,\r\n           st.size = 4.5,\r\n           border.size = 0.2,\r\n           family = \"IM FELL English\") + \r\n  north(x.min = 122.51, \r\n        x.max = 122.61, \r\n        y.min = 22.2, \r\n        y.max = 22.4, \r\n        symbol = 10,\r\n        scale = 4) + \r\n  annotate(geom = \"text\", x = 122.41, y = 22.35, label = \"N\", size = 7, family = \"IM FELL English\", fontface = \"italic\")\r\n\r\n\r\n\r\nSummary\r\nTo summarize what we did, we used the package elevatr to get the elevation tiles and made a topographic map of Taiwan, and then we added a scale bar and a north arrow to the map using the scalebar() and north() function from the package ggsn. Now, it’s your turn to make use of what we learned here!\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-12-24-post-32-ggplot-map-series-no5-map-annotation-with-ggsn/../../homepage_images/Post32.png",
    "last_modified": "2023-12-29T13:43:11-05:00",
    "input_file": {},
    "preview_width": 672,
    "preview_height": 672
  },
  {
    "path": "posts/2023-12-09-post-31-from-static-to-dynamic-animations-in-ggplots/",
    "title": "Post #31. From static to dynamic—Create ggplot animations by hand",
    "description": "Read more here to bring your plots alive!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-12-09",
    "categories": [
      "2023"
    ],
    "contents": "\r\n\r\nIntroduction\r\nAnimations are a powerful tool for data visualization and communication: They turn static images/plots into dynamic stories. If we say A figure is worth a thousand words, then I would argue that An animation is worth a thousand figures.\r\nCreating ggplot animations is not a daunting task: The extension package gganimate provides a plethora of functions to make animations with ggplots and customize them. (See this guest post by William Ou on conveying the essence of data using gganimate!) But if you understand the underlying principle of animations, they are essentially an array of individual images/plots displayed in a chronological order, and we can easily make animations (for any kind of R plots) ourselves.\r\nIn this post, I’m going to show you how to make ggplot animations by hand based on this simple principle, without turning to gganimate functions. I think this will make a fun coding exercise and at the same time sharpen our programming skills. Also, a big shout-out to June Choe for his neat post, which is the ultimate inspiration for this one. Enjoy!\r\nCreate a ggplot animation by hand\r\n(1) The static plot\r\nWe’ll begin by creating a toy plot: A plot consists of ten geom_rect() layers with successively narrower widths, and each rectangle is filled with a different color:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### The toy dataframe\r\ndf <- data.frame(xmin = 0, xmax = 0, ymin = -10, ymax = 10) \r\n\r\n### The color vector\r\ncolor_vec <- terrain.colors(n = 10)  \r\n\r\n### The toy plot\r\nggplot(df) +\r\n  geom_rect(aes(xmin = xmin - 10^1.0, xmax = xmax + 10^1.0, ymin = ymin, ymax = ymax), fill = color_vec[10]) + \r\n    geom_rect(aes(xmin = xmin - 9^0.9, xmax = xmax + 9^0.9, ymin = ymin, ymax = ymax), fill = color_vec[9]) + \r\n    geom_rect(aes(xmin = xmin - 8^0.8, xmax = xmax + 8^0.8, ymin = ymin, ymax = ymax), fill = color_vec[8]) + \r\n    geom_rect(aes(xmin = xmin - 7^0.7, xmax = xmax + 7^0.7, ymin = ymin, ymax = ymax), fill = color_vec[7]) + \r\n    geom_rect(aes(xmin = xmin - 6^0.6, xmax = xmax + 6^0.6, ymin = ymin, ymax = ymax), fill = color_vec[6]) + \r\n    geom_rect(aes(xmin = xmin - 5^0.5, xmax = xmax + 5^0.5, ymin = ymin, ymax = ymax), fill = color_vec[5]) + \r\n    geom_rect(aes(xmin = xmin - 4^0.4, xmax = xmax + 4^0.4, ymin = ymin, ymax = ymax), fill = color_vec[4]) + \r\n    geom_rect(aes(xmin = xmin - 3^0.3, xmax = xmax + 3^0.3, ymin = ymin, ymax = ymax), fill = color_vec[3]) + \r\n    geom_rect(aes(xmin = xmin - 2^0.2, xmax = xmax + 2^0.2, ymin = ymin, ymax = ymax), fill = color_vec[2]) + \r\n    geom_rect(aes(xmin = xmin - 1^0.1, xmax = xmax + 1^0.1, ymin = ymin, ymax = ymax), fill = color_vec[1]) + \r\n    scale_x_continuous(limits = c(-10, 10)) + \r\n  theme_void()\r\n\r\n\r\n\r\nThe code looks quite like an eyesore, doesn’t it? The arguments in all geom_rect() layers are basically the same; the only difference is the supplied values. Let’s fix it.\r\n(2) Reduce the repetitive code\r\nThe function reduce(), as its name suggests, is meant to “reduce” the repetitive code by iteratively applying a function over a list/vector of values and taking the output in the current iteration as the input for the next iteration. Sounds abstract? Let’s take a look at how it actually works:\r\n\r\n\r\n### Reduce the repetitive code using \"reduce()\"\r\nreduce(10:1,  # a vector of values to iterate over\r\n       .f = ~ .x + geom_rect(aes(xmin = xmin - .y^(.y/10), xmax = xmax + .y^(.y/10), ymin = ymin, ymax = ymax), fill = color_vec[.y]),  # the function\r\n       .init = ggplot(df) + theme_void()  # the constant part of the code \r\n       )\r\n\r\n\r\n\r\nIn the above code, we supplied a vector of values for the arguments in the function, the function itself, and the constant part of the code to start the iteration.\r\nThe first iteration would be:\r\n\r\n\r\nggplot(df) + \r\n  theme_void() + \r\n  geom_rect(aes(xmin = xmin - 10^(10/10), xmax = xmax + 10^(10/10), ymin = ymin, ymax = ymax), fill = color_vec[10])\r\n\r\n\r\n\r\nThe second iteration would be:\r\n\r\n\r\nggplot(df) + \r\n  theme_void() + \r\n  geom_rect(aes(xmin = xmin - 10^(10/10), xmax = xmax + 10^(10/10), ymin = ymin, ymax = ymax), fill = color_vec[10]) + \r\n  geom_rect(aes(xmin = xmin - 9^(9/10), xmax = xmax + 9^(9/10), ymin = ymin, ymax = ymax), fill = color_vec[9])\r\n\r\n\r\n\r\nSo on and so forth. After the last iteration was completed, the final product would be returned (which is the same as what you saw in the first code chunk).\r\n(3) The intermediate plots\r\nRemember that to create an animation, we need a sequence of images/plots. We only have one plot now. So where are our plots? Don’t worry; we’re going to get them here using the cool function accumulate(): This function works essentially in the same way as reduce(), except that it keeps all the intermediate outputs from the iterations. Simply swap out reduce() for accumulate() to get all the intermediate plots stored in a list:\r\n\r\n\r\n### Use \"accumulate()\" to get the intermediate plots\r\np_intermediate <- accumulate(10:1,\r\n                             .f = ~ .x + geom_rect(aes(xmin = xmin - .y^(.y/10), xmax = xmax + .y^(.y/10), ymin = ymin, ymax = ymax), fill = color_vec[.y]),\r\n                             .init = ggplot(df) + theme_void()\r\n                             ) \r\n\r\nlibrary(patchwork)\r\nwrap_plots(p_intermediate[-1], ncol = 4, nrow = 3, byrow = T)  # omit the first empty plot\r\n\r\n\r\n\r\n(4) Make them alive\r\nHaving a sequence of plots at hand, it’s time to make them alive!\r\nHere, we’ll use the package magick to create the animation. The package has lots of handy functions for image processing. First, we need to convert the ggplots into “magick-image” objects that the package works with. We’ll then use image_join() to combine the individual magick-images into a single magick-image with multiple frames. Finally, we’ll pass it to image_animate() to make the animation.\r\n\r\n\r\n# install.packages(\"magick\")  # install the package if you haven't\r\nlibrary(magick)\r\n\r\n### Convert the ggplots into \"magick-image\" objects\r\nimages <- map(1:length(p_intermediate), function(x) {\r\n  image <- image_graph(width = 400, height = 300, res = 600)\r\n  plot(p_intermediate[[x]])\r\n  dev.off()\r\n  image\r\n})\r\n\r\n### Combine the individual images\r\nimage_frames <- image_join(images)\r\n\r\n### Animate the frames\r\nimage_animation <- image_animate(image_frames, fps = 5)  # modify \"fps\" to adjust the animation speed \r\nprint(image_animation)\r\n\r\n# A tibble: 11 × 7\r\n   format width height colorspace matte filesize density\r\n   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>  \r\n 1 gif      400    300 sRGB       TRUE         0 600x600\r\n 2 gif      400    300 sRGB       TRUE         0 600x600\r\n 3 gif      400    300 sRGB       TRUE         0 600x600\r\n 4 gif      400    300 sRGB       TRUE         0 600x600\r\n 5 gif      400    300 sRGB       TRUE         0 600x600\r\n 6 gif      400    300 sRGB       TRUE         0 600x600\r\n 7 gif      400    300 sRGB       TRUE         0 600x600\r\n 8 gif      400    300 sRGB       TRUE         0 600x600\r\n 9 gif      400    300 sRGB       TRUE         0 600x600\r\n10 gif      400    300 sRGB       TRUE         0 600x600\r\n11 gif      400    300 sRGB       TRUE         0 600x600\r\n\r\n\r\nHere you go!\r\nSummary\r\nTo recap what we did, we first used the function accumulate() to generate a sequence of ggplots, and then we used the functions from the package magick to turn the individual plots into an animation. In fact, you can make animations for any images/plots you have. The key is to get an array of images/plots and combine them in a desired order!\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-12-09-post-31-from-static-to-dynamic-animations-in-ggplots/../../homepage_images/Post31.gif",
    "last_modified": "2023-12-13T16:23:37-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2023-10-26-post-30-ggplot-map-series-no4-creating-maps-with-ggmap/",
    "title": "Post #30. ggplot Map Series No.4: Google Maps in R with `ggmap`",
    "description": "A quick three-minute post on creating maps using Google Maps tiles with the package `ggmap`.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-10-26",
    "categories": [
      "2023",
      "Map Series"
    ],
    "contents": "\r\n\r\nIntroduction\r\nGoogle Maps is arguably the most commonly used online map application in our everyday life: for navigation, for finding specific places, for measuring the distance, just to name a few. We also use Google Maps frequently in presentations, for example, showing a satellite image and the location of the study sites. Traditionally, what we’ll do is going to the Google Maps webpage, taking a screen shot of the map, cropping and editing it in PowerPoint.\r\nNow, thanks to the extension package ggmap, we can get rid of the tedious work and directly retrieve Google Maps tiles from R and plot them in ggplots. We can then add polygons, lines, and points to the maps. This is exactly the goal of this post, and I’m going to show you how to do these things. The post will be short but handy!\r\nCreate maps using Google Maps tiles\r\nBefore we start, there is one thing you need to do: registering with Google and setting up an API key for the map platform. This is required to retrieve data from Google Map. Visit this page for how to do this.\r\nAfter you get your API key, paste it into the function register_google() and you’re all set:\r\n\r\n\r\n\r\n\r\n\r\nlibrary(ggmap)\r\nregister_google(key = \"your key\")\r\n\r\n\r\nGet the map tiles\r\nThe first step is to get the map tiles of the desired area using the function get_googlemap(). There are two ways to do so:\r\nBy location: supply the name of the place (e.g., “New York City”)\r\nBy longitude and latitude: supply the lon-lat coordinates of the place\r\nThe place will occur at the center of the map. To control the extent of the map area, you can specify an additional argument “zoom”, which ranges from 3 to 21. As a rule of thumb, 3 gives continent-level view, 12 gives city-level view, and 21 gives building-level view. Experiment the values a bit to get the desired outcome.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Get the map data\r\nmy_location <- \"Ithaca\"  # location\r\nmy_lon_lat <- c(-76.50, 42.44)  # lon-lat pair\r\n\r\nmy_location_map <- get_googlemap(my_location, zoom = 12)\r\nmy_lon_lat <- get_googlemap(my_lon_lat, zoom = 12)\r\n\r\n\r\n\r\nThere is a useful helper function geocode() that can find the longitude and latitude coordinates of a given location:\r\n\r\n\r\n### Find the lon-lat coordinates of the given location\r\ngeocode(\"Ithaca\")\r\n\r\n# A tibble: 1 × 2\r\n    lon   lat\r\n  <dbl> <dbl>\r\n1 -76.5  42.4\r\n\r\nDraw the map\r\nAfter we get the map tiles of the area, it’s time to draw the map! Super simple: just pass the map tiles to ggmap():\r\n\r\n\r\nmap_by_location <- ggmap(my_location_map) + \r\n  labs(title = \"By location\") + \r\n  theme(plot.title = element_text(hjust = 0.5))\r\n\r\nmap_by_lon_lat <- ggmap(my_lon_lat) + \r\n  labs(title = \"By lon-lat pair\") +\r\n    theme(plot.title = element_text(hjust = 0.5))\r\n\r\nlibrary(patchwork)\r\nmap_by_location + map_by_lon_lat\r\n\r\n\r\n\r\nLet’s also try out different zoom values:\r\n\r\n\r\n### Different zoom values\r\nmy_maps_zooms <- lapply(c(3, 6, 10, 13, 17, 21), function(x){\r\n  get_googlemap(my_location, zoom = x) %>% \r\n    ggmap() + \r\n    labs(title = paste0(\"zoom = \", x)) +\r\n    theme(plot.title = element_text(hjust = 0.5))\r\n})\r\n\r\npatchwork::wrap_plots(my_maps_zooms, ncol = 3, nrow = 2, byrow = T)\r\n\r\n\r\n\r\n\r\nBesides the default terrain map, we can also get the road map, satellite image, or a hybrid of them:\r\n\r\n\r\n### Different map types\r\nmy_maps <- lapply(c(\"terrain\", \"roadmap\", \"satellite\", \"hybrid\"), function(x){\r\n  get_googlemap(my_location, zoom = 12, maptype = x) %>% \r\n    ggmap() + \r\n    labs(title = x) +\r\n    theme(plot.title = element_text(hjust = 0.5))\r\n})\r\n\r\npatchwork::wrap_plots(my_maps, ncol = 2, nrow = 2, byrow = T)\r\n\r\n\r\n\r\nAdd a polygon and points to a satellite image\r\nWe can spice up the “plain” map by adding polygons/lines/points to it. Here, I’m going to draw the boundary of Ithaca City and show the locations of the city street trees on a Google satellite image. The data (shapefiles) can be download from City of Ithaca Community Data Portal.\r\nWe’ll first retrieve the zip files from the GitHub repository, unzip them, and read in the shapefiles using the function st_read() from the package sf (see my previous post on making maps with sf!). Next, we can add the shapefile data to the satellite image using geom_sf(). Note that we need to set “inherit.aes = F” so that geom_sf() will not use the aesthetics from the global plot that are used for the satellite image.\r\nLet’s take a look at how it works:\r\n\r\n\r\n### Download the zip files from the GitHub repository and unzip them\r\n# (1) city boundary\r\nurl_city_boundary <- \"https://github.com/GenChangHSU/ggGallery/blob/master/_posts/2023-10-26-post-30-ggplot-map-series-no4-creating-maps-with-ggmap/Municipal_Boundary.zip?raw=TRUE\"\r\ndownload.file(url_city_boundary, \"Municipal_Boundary.zip\", mode = \"wb\")\r\nunzip(\"Municipal_Boundary.zip\")\r\n\r\n# (2) city trees\r\nurl_city_trees <- \"https://github.com/GenChangHSU/ggGallery/blob/master/_posts/2023-10-26-post-30-ggplot-map-series-no4-creating-maps-with-ggmap/City_Managed_Trees.zip?raw=TRUE\"\r\ndownload.file(url_city_trees, \"City_Managed_Trees.zip\", mode = \"wb\")\r\nunzip(\"City_Managed_Trees.zip\")\r\n\r\n### Read in the shapefiles of city boundary and city trees\r\nlibrary(sf)\r\n\r\ncity_boundary <- st_read(\"./Municipal_Boundary/Municipal_Boundary.shp\", quiet = T)\r\ncity_trees <- st_read(\"./City_Managed_Trees/City_Managed_Trees.shp\", quiet = T)\r\n\r\n### Add the city boundary and city trees to a satellite image\r\nget_googlemap(my_location, zoom = 13, maptype = \"satellite\") %>% \r\n  ggmap() + \r\n  geom_sf(data = city_boundary, fill = NA, color = \"red\", linewidth = 1, inherit.aes = F) +  # need to set \"inherit.aes = F\"\r\n  geom_sf(data = city_trees, color = \"forestgreen\", size = 0.1, inherit.aes = F)\r\n\r\n\r\n\r\nVoila!\r\nSummary\r\nIn this post, we learned how to create maps using Google Maps tiles with the package ggmap. First, we got the map tiles of the area of interest using get_googlemap(), and then we passed the data to ggmap() to draw the map. We also tried out a few different zoom values and map types. Finally, we polished a Google satellite image by adding a polygon and points to it. Next time, you can use this method to create a map to show your study site/plot and the locations of the species/organisms!\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-10-26-post-30-ggplot-map-series-no4-creating-maps-with-ggmap/../../homepage_images/Post30.png",
    "last_modified": "2023-10-29T20:04:31-04:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "posts/2023-09-09-post-29-creating-raincloud-plots-in-ggplots/",
    "title": "Post #29. Bad weather today—Creating raincloud plots in ggplots",
    "description": "Come and learn how to create raincloud plots in ggplots to make your data \"shine\"!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-09-09",
    "categories": [
      "2023"
    ],
    "contents": "\r\n\r\nIntroduction\r\nRainclound plot, what a cool name! You might, or might not have heard of it before, but as you’ll see soon, this type of chart is awesome for visualizing data distribution.\r\nA rainclound plot is actually not a single plot, but instead it consists of three different plots: a boxplot, a dot plot, and a density plot. With these components, a rainclound plot can capture various aspects of the data and convey more information than the individual constituent plots alone.\r\nThis post is actually inspired by two previous posts (post 1 and post 2) I stumbled upon the other day. Both posts give a neat tutorial of creating rainclound plots using the extension package ggdist, so I will not repeat that again here. Instead, what I’m going to do is to show you how we can create a raincloud plot in ggplots using basic ggplot functions. Should be fun!\r\nCreate the plot\r\nWe’ll use the penguins dataset in the package palmerpenguins, which contains size measurements of three penguin species (Adélie, Chinstrap, and Gentoo) on the islands in Palmer Archipelago. In the following example, we’ll create a raincloud plot to visualize the distribution of body mass of the three penguins.\r\nStep 1. The box plot\r\nThe first step is to draw a box plot. This is quite straightforward: simply use the function geom_boxplot(). We’ll also reduce the width of the boxes to save space for the two upcoming plots.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(palmerpenguins)\r\n\r\nP_box <- penguins %>% \r\n  ggplot() + \r\n  geom_boxplot(aes(x = species, fill = species, y = body_mass_g), \r\n               width = 0.15,\r\n               show.legend = F)\r\n\r\nP_box\r\n\r\n\r\n\r\nStep 2. The dot plot\r\nThe second step is to draw the dot plot, which resembles a histogram but uses stacked dots instead of bars to represent the counts. To do so, we’ll use the function geom_dotplot() and specify “binaxis =”y”” to place the stacked dots along the y-axis (not the default x-axis). We’ll also use “stackratio = -1” to flip the dots to the left of the boxes and “position_nudge(x = -0.15)” to shift the dots slightly away from the boxes so that they don’t overlap with each other.\r\n\r\n\r\nP_box_dot <- P_box +\r\n  geom_dotplot(aes(x = species, fill = species, y = body_mass_g),\r\n               binaxis = \"y\",\r\n               stackratio = -1,\r\n               position = position_nudge(x = -0.15),\r\n               dotsize = 0.5,\r\n               show.legend = F)\r\n\r\nP_box_dot\r\n\r\n\r\n\r\nStep 3. The density plot\r\nThe third step is to draw the density plot. Here, we’ll use geom_ribbon(stat = \"density\") instead of geom_density() because geom_ribbon() allows us to create a density curve for each group (species). The mapping specification in aes() is a bit complicated, so let me explain it:\r\nThe key lies in the two arguments “xmin = after_stat(group)” and “xmax = after_stat(group + ndensity*0.2)“.”xmin” represents the lower boundary of the area (i.e., the base), and “xmax” represents the upper boundary (i.e., the density curve). As for after_stat(), it evaluates the new variables created by the geom after the transformation of the original data (e.g., computing the kernel density estimates). In this example, “group” is a new variable created for each species (because we map species to color and fill) and coded as integers; “ndensity” is another new variable created for the kernel density estimates computed from the variable “body_mass_g”. Now, with these two new variables, we can map “xmin” and “xmax” to them to draw the density curves. Also note that “ndensity” is multiplied by 0.2 to adjust the height of the density curves. We’ll also specify “trim = T” to truncate the tails of the density curves that extend across the entire y-axis range.\r\n\r\n\r\nP_box_dot_density <- P_box_dot + \r\n  geom_ribbon(aes(xmin = after_stat(group),\r\n                  xmax = after_stat(group + ndensity*0.2),\r\n                  y = body_mass_g,\r\n                  colour = species, fill = after_scale(alpha(colour, 0.3))),\r\n              stat = \"density\", \r\n              outline.type = \"upper\",\r\n              position = position_nudge(x = 0.1),  # shift the density curves to the right of the boxes\r\n              trim = T,  # truncate the long tails\r\n              show.legend = F)\r\n\r\nP_box_dot_density \r\n\r\n\r\n\r\nStep 4. Flip the axes\r\nWe’re almost there! The clouds and raindrops are in the vertical direction, so the final step is to flip the axes to make them horizontal. Simply use coord_flip() to achieve this.\r\n\r\n\r\nP_raincloud <- P_box_dot_density + \r\n  labs(x = \"Body mass (g)\", y = \"Species\") +\r\n  coord_flip(x = c(0.5, 3), y = c(2500, 6500)) + \r\n  theme_classic(base_size = 12)\r\n\r\nP_raincloud \r\n\r\n\r\n\r\nWe made it!\r\nSummary\r\nTo recap, we learned how to create a raincloud plot in ggplots step by step: first drawing the boxplot, next the dot plots, third the density plot, and finally flipping the axes. Depending on the data, you may wish to adjust the thickness of the clouds or the size of the raindrops to prevent the items from overlapping with each other.\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-09-09-post-29-creating-raincloud-plots-in-ggplots/../../homepage_images/Post29.png",
    "last_modified": "2023-09-11T21:14:06-04:00",
    "input_file": {},
    "preview_width": 864,
    "preview_height": 960
  },
  {
    "path": "posts/2023-08-22-post-28-adding-images-to-ggplots/",
    "title": "Post #28. Adding an external image to ggplots",
    "description": "Come and learn four different ways of adding an external image to ggplots to decorate your figure!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-08-22",
    "categories": [
      "2023"
    ],
    "contents": "\r\n\r\nIntroduction\r\nSometimes, we would like to put an image, an illustration, or a silhouette in the figure to make it more visually appealing. How can we do this in ggplots? Well, this is actually not difficult at all. In this post, I’m going to introduce four ways of adding an external image to ggplots. Read below!\r\nFour ways of adding an external image to ggplots\r\n(1) The package ggimage\r\nThe extension package ggimage has a function geom_image() that draws images on ggplots. Simply specify the x- and y-coordinates and map the image (either a local file path or an url) to the “image” argument and you’re all set!\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(ggimage)\r\n\r\n### The url of an iris image\r\nimage_url <- \"https://images.phylopic.org/images/0a8ab4f9-04c9-4485-b21a-df683d506055/raster/222x512.png\"\r\n\r\n### The boxplot with an iris image added\r\nggplot(iris, aes(x = Species, y = Sepal.Length, color = Species)) + \r\n  geom_boxplot() + \r\n  geom_image(aes(x = 1, y = 7.1, image = image_url), size = 0.11, color = \"purple\") +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nWe can also use the image as points for the scatterplot:\r\n\r\n\r\nggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) + \r\n  geom_image(aes(image = image_url, color = Species), size = 0.03) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n(2) The package ggtext\r\nggtext is another extension package that we can use to add images to ggplots, yet the way how ggtext does it is a bit different from ggimage: instead of directly specifying the image path in aes(), we need to wrap the image path into an HTML <img> tag and use the function geom_richtext(label = ) to render the tag into an actual image for plotting. The size of the image can be controlled using the “width” or “height” attribute in the <img> tag. There’s one limitation though: you can’t change the color of the image as you did earlier.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(ggtext)\r\n\r\n### Create an HTML <img> tag\r\nimage_tag <- \"<img src = 'https://images.phylopic.org/images/0a8ab4f9-04c9-4485-b21a-df683d506055/raster/222x512.png' width = '19'/>\"\r\n\r\n### The boxplot with an iris image added\r\nggplot(iris, aes(x = Species, y = Sepal.Length, color = Species)) + \r\n  geom_boxplot() + \r\n  geom_richtext(aes(x = 1, y = 7.1, label = image_tag), color = NA) +  # specify \"color = NA\" to remove the outline box \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nAs a side note, you can use ggtext to modify the labels and text in ggplots in a more sophisticated and customized manner. Check out my previous post on using ggtext for awesome text displays in ggplots!\r\n(3) The package cowplot\r\nThe third extension package that we can use to add an image to ggplots is cowplot. The basic idea is that we will first create a drawing canvas using the function ggdraw(), and then we can add plots (using the function draw_plot()) or images (using the function draw_image()) to the canvas. The canvas has x- and y-coordinates between 0 and 1, and we can specify the image position using relative coordinates. It does require some experimentation to tweak the image position! Setting “hjust = 0.5” and “vjust = 0.5” will make the center of the image at the point of the specified x- and y-location.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(cowplot)\r\n\r\n### The url of an iris image\r\nimage_url <- \"https://images.phylopic.org/images/0a8ab4f9-04c9-4485-b21a-df683d506055/raster/222x512.png\"\r\n\r\n### The boxplot\r\niris_boxplot <- ggplot(iris, aes(x = Species, y = Sepal.Length, color = Species)) + \r\n  geom_boxplot() + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  theme_classic(base_size = 13)\r\n\r\n### Draw the boxplot and image on the canvas\r\nggdraw() +\r\n  draw_plot(iris_boxplot) +  # the plot will take up the entire canvas space by default\r\n  draw_image(image_url, x = 0.21, y = 0.77, scale = 0.2, hjust = 0.5, vjust = 0.5)  # use the argument \"scale\" to adjust the size of the image\r\n\r\n\r\n\r\n(4) The package patchwork\r\nThe last extension package is patchwork, which is an awesome package for arranging multiple ggplots. The package has a function inset_element() that draws plots (“grob” or “ggplot” objects) or images (“raster” objects) as insets. To do so, we’ll first read in the iris image using the function image_read() from the package magick and convert it to a raster object using the function as.raster(). After that, we can pass the raster image to inset_element() to add it to the boxplot as an inset. The position and the size of the inset are controlled by the locations of the vertices (“left”, “bottom”, “right”, “top”), and we need to experiment a bit to get the inset at the exact position with the desired size.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(patchwork)\r\n\r\n### The url of an iris image\r\nimage_url <- \"https://images.phylopic.org/images/0a8ab4f9-04c9-4485-b21a-df683d506055/raster/222x512.png\"\r\n\r\n### Read in the image as a raster object\r\nlibrary(magick)\r\nimage_raster <- image_read(image_url) %>% as.raster()\r\n\r\n### The boxplot\r\niris_boxplot <- ggplot(iris, aes(x = Species, y = Sepal.Length, color = Species)) + \r\n  geom_boxplot() + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  theme_classic(base_size = 13)\r\n\r\n### Add the image to the boxplot as an inset\r\niris_boxplot + inset_element(image_raster, left = 0.13, bottom = 0.62, right = 0.24, top = 0.92)\r\n\r\n\r\n\r\nSummary\r\nIn this post, we looked at four different extension packages that we can use to add an image to ggplots. You may ask: which one should I use? Well, I would say they’re pretty much similar in most cases, so simply pick the one that’s down your alley! If you want to do something further (e.g., change the image color), then look for a certain package (e.g., ggimage) that has the functionality you need.\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-08-22-post-28-adding-images-to-ggplots/../../homepage_images/Post28.png",
    "last_modified": "2023-08-29T20:52:53-04:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2023-07-31-post-27-ggplot-map-series-no3-the-veins-of-taiwan/",
    "title": "Post #27. ggplot Map Series No.3: Visualizing the veins of Taiwan in ggplots with `osmdata`",
    "description": "In this post, we will create a map of the rivers in Taiwan in ggplots using the package `osmdata`.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-07-31",
    "categories": [
      "2023",
      "Map Series"
    ],
    "contents": "\r\n\r\nIntroduction\r\nOpenStreetMap (OSM) is a free open global geographic database maintained by a community of volunteers and contributors. The map data in OSM contain almost every physical feature on the ground, from natural properties like mountain peaks, water bodies, and vegetation types, to human-made structures like roads, shops, and trails (see this website for a complete list of the map features). These data are used by a great number of websites and software apps for their maps.\r\nIn this post, we’re going to visualize the rivers in Taiwan in ggplots using data in OSM. Hopefully, after reading the post, you will be able to make good use of this database to make your own awesome ggplot maps!\r\nCreate the map\r\nLet’s jump right in! First, we’ll obtain the river data of Taiwan from OSM, and then we’ll visualize them in ggplots. Finally, we’ll have some fun with the map by making it artistic.\r\n(1) Prepare the data\r\nThe package osmdata allows users to download map data from OSM for any given area. This involves three steps:\r\nDefining a bounding box using the function opq(bbox = ). The argument “bbox” can be either a character string of the location name (e.g., \"Taipei\"), or four numerical values specifying the minimal and maximal longitudes and latitudes of the area (e.g., c(120, 20, 120.5, 21)).\r\nBuilding an osmdata query using the function add_osm_feature(key = , value = ). The requested data are specified using “key-value” pairs, with key representing the major category of the data and the value representing the more specific feature type under that major category. Take a look at the website for the available features.\r\nRetrieving OSM data with the query. The function osmdata_sf() will send the query to OSM, obtain the requested data, and return them in the “simple feature (sf)” format.\r\nLet’s see a worked example below: We got a vector of the county names in Taiwan and looped over the vector to retrieve the OSM data for each county. Because the river information is stored as a list of simple feature lines in the returned object, we further extracted it for each county and merged all the lists into a single dataframe.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(osmdata)\r\n\r\n### Get the county names in Taiwan \r\n# library(remotes)\r\n# install_github(\"wmgeolab/rgeoboundaries\")  # install the package if you haven't\r\nlibrary(rgeoboundaries)  # for the function \"geoboundaries()\"\r\nTaiwan_county_names <- geoboundaries(\"Taiwan\", \"adm1\") %>% \r\n  as.tibble() %>% \r\n  filter(!shapeName %in% c(\"Kinmen\", \"Matsu Islands\")) %>%  # exclude Kinmen and Matsu islands for better visualization\r\n  pull(shapeName)\r\n  \r\n### Obtain the OSM river data for each county\r\nTaiwan_river_osmdata <- Taiwan_county_names %>%\r\n  map(., ~ opq(bbox = .x, timeout = 100) %>%  # need to increase the \"timeout\" (default to 25 seconds) for larger queries\r\n        add_osm_feature(key = 'waterway', value = \"river\") %>%\r\n        osmdata_sf()) %>% \r\n  `names<-`(Taiwan_county_names)\r\n\r\n### Extract the list of simple feature lines for each county and merge them into a single dataframe\r\nTaiwan_river_osmdata_lines <- Taiwan_river_osmdata %>% \r\n  map(., ~ .x$osm_lines) %>% \r\n  bind_rows(.id = \"county\")\r\n\r\n### Take a look at the dataframe\r\nTaiwan_river_osmdata_lines %>% \r\n  select(osm_id, county, geometry) %>% \r\n  head()\r\n\r\nSimple feature collection with 6 features and 2 fields\r\nGeometry type: LINESTRING\r\nDimension:     XY\r\nBounding box:  xmin: 120.9303 ymin: 24.65206 xmax: 121.5074 ymax: 25.17773\r\nGeodetic CRS:  WGS 84\r\n               osm_id         county                       geometry\r\n25887259...1 25887259 Hsinchu County LINESTRING (121.4859 25.042...\r\n27696480...2 27696480 Hsinchu County LINESTRING (121.23 24.89155...\r\n27696492...3 27696492 Hsinchu County LINESTRING (121.1948 24.888...\r\n91846587...4 91846587 Hsinchu County LINESTRING (121.0272 24.844...\r\n91846590...5 91846590 Hsinchu County LINESTRING (121.1085 24.730...\r\n91907207...6 91907207 Hsinchu County LINESTRING (121.2379 24.652...\r\n\r\nCreate the river map\r\nNow we have the river data on hand, we can visualize them in ggplots! The river data is an “sf” object, which can be passed directly to the function geom_sf() for plotting (also see my previous post on making simple feature maps in ggplots!). We’ll also draw the boundary of Taiwan as the base map.\r\n\r\n\r\n### Taiwan boundary data\r\nTaiwan_boundary_adm0 <- geoboundaries(\"Taiwan\", \"adm0\")\r\n\r\n### The river map of Taiwan\r\nggplot() + \r\n  geom_sf(data = Taiwan_boundary_adm0, fill = \"grey90\", alpha = 0.7) + \r\n  geom_sf(data = Taiwan_river_osmdata_lines, linewidth = 0.1, color = \"steelblue\") + \r\n  coord_sf(xlim = c(119, 123), ylim = c(21.7, 25.5)) + \r\n  theme_minimal() + \r\n  theme(panel.background = element_rect(color = \"black\"),\r\n        panel.grid.major = element_blank())\r\n\r\n\r\n\r\nHere we go!\r\nMake it artistic\r\nLet’s modify the appearance of the map to make it artistic:\r\n\r\n\r\nggplot() + \r\n  geom_sf(data = Taiwan_river_osmdata_lines, aes(color = county), linewidth = 0.1, show.legend = F) + \r\n  coord_sf(xlim = c(119, 122.5), ylim = c(21.7, 25.5)) + \r\n  theme_void() + \r\n  theme(panel.background = element_rect(fill = \"black\"))\r\n\r\n\r\n\r\nThe veins of Taiwan clear at a glance!\r\nSummary\r\nTo summarize what we did, we obtained the river data of Taiwan from OSM using the package osmdata and visualized them in ggplots. I showcased the river data here, but the same principle applies to other features as well, and you can take advantage of them to create great thematic maps.\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-07-31-post-27-ggplot-map-series-no3-the-veins-of-taiwan/../../homepage_images/Post27.png",
    "last_modified": "2023-08-04T00:14:28-04:00",
    "input_file": {},
    "preview_width": 710,
    "preview_height": 518
  },
  {
    "path": "posts/2023-05-24-post-26-ggplot-map-series-no2-simple-feature-maps/",
    "title": "Post #26. ggplot Map Series No.2: Creating simple feature ggplot maps from shapefiles",
    "description": "Come and take a look at the nuts and bolts of creating simple feature maps from external shapefiles in ggplots!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-05-24",
    "categories": [
      "2023",
      "Map Series"
    ],
    "contents": "\r\n\r\nIntroduction\r\nIn the first post of this Map Series, we looked at how to create polygon maps in ggplots. But this is not the only way to create ggplot maps; there are indeed many more ways out there! And in this post, I’m going to show you another method: creating maps from shapefiles.\r\nI believe you might have heard of shapefiles (or even used them before!). So what exactly are they? A shapefile (.shp) is a common geospatial vector data format for storing the locations, shapes, and attributes of geographic features. It comes with a set of related files (.shx, .prj, .dbf, etc.) that together describe vector features such as points, lines, and polygons, representing all kinds of spatial objects like mountain peaks, country boundaries, roads, rivers, and lakes.\r\nBecause of the commonness and popularity of shapefiles, I think it would be useful to have some basic ideas of how to handle them in R. Hopefully, after reaching the very end of this post, you’ll be able to make good use of shapefiles to create your own cool ggplot maps!\r\nCreat a simple feature map\r\nIn this post, we’ll be creating a map of the number of visitors in the national parks (units managed by the National Park Service) in California in 2022. It’s called a “simple feature” map because this is the type of R spatial object we’ll use for data processing and plotting. Briefly, a simple feature object (sf) is a special data frame that contains several columns of feature attributes (the metadata like country names) and a list column of feature geometry (the coordinates representing the points/lines/polygons), with an associated coordinate reference system (crs). The R package sf is dedicated to sf objects and allows users to do all sorts of manipulation and computation.\r\nRetrieve the data\r\nLet’s start by preparing the data we need for making the map. The data files we have on hand are:\r\nA shapefile of California state boundary, retrieved from Natural Earth\r\nA shapefile of California national park boundaries, retrieved from National Park Service Open Data Portal\r\nA CSV file of the number of visitors in each park in 2022, retrieved from National Park Service Stats Report Viewer\r\nWe’ll download the zip files from the GitHub repository, unzip them, and read the shapefiles into R as “sf” objects using the function st_read() from the package sf.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(sf)\r\n\r\n### Download the zip files from the GitHub repository and unzip them\r\noptions(timeout = 500)  # need to increase the download time\r\n\r\nurl_CA_boundary <- \"https://github.com/GenChangHSU/ggGallery/blob/master/_posts/2023-05-24-post-26-ggplot-map-series-no2-simple-feature-maps/NE_State_Boundaries.zip?raw=TRUE\"\r\ndownload.file(url_CA_boundary, \"NE_State_Boundaries.zip\", mode = \"wb\")\r\nunzip(\"NE_State_Boundaries.zip\")\r\n\r\nurl_Park_boundary <- \"https://github.com/GenChangHSU/ggGallery/blob/master/_posts/2023-05-24-post-26-ggplot-map-series-no2-simple-feature-maps/CA_Park_Boundaries.zip?raw=TRUE\"\r\ndownload.file(url_Park_boundary, \"CA_Park_Boundaries.zip\", mode = \"wb\")\r\nunzip(\"CA_Park_Boundaries.zip\")\r\n\r\n### Read the shapefile of state boundaries\r\nCA_boundary <- st_read(\"NE_State_Boundaries/ne_10m_admin_1_states_provinces.shp\", quiet = T) %>% \r\n  filter(admin == \"United States of America\") %>%  # US state boundaries\r\n  filter(gn_name == \"California\")  # California boundary\r\n\r\n### Read the shapefile of park boundaries\r\nPark_boundary <- st_read(\"CA_Park_Boundaries/National_Park_Service_Land_Resources_Division_Tract_and_Boundary_Service.shp\", quiet = T) %>% \r\n    filter(STATE == \"CA\")  # California park boundaries\r\n\r\n### Read the CSV of park visitors in 2022\r\nPark_visitors <- read_csv(\"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2023-05-24-post-26-ggplot-map-series-no2-simple-feature-maps/CA_Park_Visitation.csv\") %>% \r\n  select(Park = Field1, Visitors = Field2) %>%  # select the park and visitor columns\r\n  mutate(Park_name = str_remove(Park, pattern = \" N[A-Z]{1,4}\"))  # remove the park type abbreviations\r\n\r\n\r\nProcess the data\r\nNow we have the data loaded in R, the next step is to process them for plotting. There are two things to do here. First, we’ll join the park boundary and park visitor data so that later we can map the numbers of visitors in the parks to different colors. Second, we’ll check the crs of the two data layers (state boundary and park boundaries) to ensure that they can be drawn on the same map.\r\n\r\n\r\n### Join the park boundary and park visitor data\r\nPark_boundary_visitor <- Park_boundary %>% \r\n  mutate(PARKNAME = case_match(PARKNAME, \"Rosie the Riveter WWII Home Front\" ~ \"Rosie The Riveter WWII Home Front\", \r\n                               .default = PARKNAME)) %>%  # adjust the park name \r\n  left_join(Park_visitors, by = join_by(\"PARKNAME\" == \"Park_name\"))  # join by park names\r\n\r\n### Check the crs of the two data layers\r\nst_crs(CA_boundary)$epsg\r\n\r\n[1] 4326\r\n\r\nst_crs(Park_boundary_visitor)$epsg\r\n\r\n[1] 3857\r\n\r\n### Transform the crs of park boundary data\r\nPark_boundary_visitor <- st_transform(Park_boundary_visitor, crs = 4326) \r\nst_crs(Park_boundary_visitor)$epsg\r\n\r\n[1] 4326\r\n\r\nIn this example, the two layers have different crs (EPSG code 4326 vs. 3857), so we used st_transform() to convert the crs of the park boundary data into the one used by the state boundary data.\r\nCreate the map\r\nIt’s time to make the map. Simply pass the sf objects to the “data” argument in geom_sf() and it will take care of everything! We also cut the number of visitors into discrete categories for color mapping.\r\n\r\n\r\n### Cut the number of visitors into discrete categories\r\nPark_boundary_visitor <- Park_boundary_visitor %>% \r\n  mutate(Visitors_cat = case_when(Visitors < 50000 ~ \"< 50,000\",\r\n                                  Visitors > 50000 & Visitors < 500000 ~ \"50,000– \\n500,000\",\r\n                                  Visitors > 500000 & Visitors < 1000000 ~ \"500,000– \\n1,000,000\",\r\n                                  Visitors > 1000000 & Visitors < 10000000 ~ \"1,000,000– \\n10,000,000\",\r\n                                  Visitors > 10000000 ~ \"> 10,000,000\")) %>% \r\n  mutate(Visitors_cat = factor(Visitors_cat, levels = c(\"< 50,000\", \"50,000– \\n500,000\", \"500,000– \\n1,000,000\", \"1,000,000– \\n10,000,000\", \"> 10,000,000\"))) %>% \r\n  drop_na() %>% \r\n  filter(OBJECTID != 14)\r\n\r\n### Create the map\r\nCA_park_map <- ggplot() + \r\n  geom_sf(data = CA_boundary) + \r\n  geom_sf(data = Park_boundary_visitor, aes(fill = Visitors_cat))\r\n\r\nCA_park_map \r\n\r\n\r\n\r\nPolish the map\r\nThe map doesn’t really look pleasant. Let’s polish it now! We’re going to (1) change the background color of the map, (2) pick a new color palette for the visitor categories, (3) modify the legend appearance, (4) label the park names, and (5) add a title, text annotations, and a logo to the map.\r\n\r\n\r\n# devtools::install_github(\"yutannihilation/ggsflabel\")  # install the package if you haven't\r\nlibrary(ggtext)\r\nlibrary(ggsflabel)  # for the function \"geom_sf_text_repel()\"\r\nlibrary(showtext)  # for the function \"font_add_google()\" and \"showtext_auto()\"\r\n\r\n### Import the new font  \r\nfont_add_google(\"Lora\")\r\nshowtext_auto()\r\n\r\n### Map\r\nCA_park_map <- ggplot() + \r\n  \r\n  # California state \r\n  geom_sf(data = CA_boundary, color = \"transparent\", fill = \"grey80\") + \r\n  \r\n  # national parks\r\n  geom_sf(data = Park_boundary_visitor, aes(color = Visitors_cat, fill = Visitors_cat)) +\r\n  \r\n  # national park labels\r\n  geom_sf_text_repel(data = Park_boundary_visitor, aes(label = str_wrap(Park, width = 25)), \r\n                     color = \"white\", size = 2.75, family = \"sans\", fontface = \"bold\", \r\n                     segment.size = 0.2, lineheight = 0.5, vjust = 0.5, hjust = 0.5, \r\n                     max.overlaps = Inf, force = 3) +\r\n  \r\n  # title\r\n  geom_richtext(aes(x = -115.5, y = 41.5, label = \"What Are the Most Visited <br> National Parks in California?\"), \r\n                color = \"white\", size = 6.5, family = \"Lora\", fontface = \"bold.italic\",\r\n                lineheight = 0.75, fill = NA, label.color = NA, label.padding = unit(rep(0, 4), \"pt\")) +\r\n  \r\n  # text annotations\r\n  geom_textbox(aes(x = -114.75, y = 40, label = \"This is a map of the number of \r\n                   visitors in the national parks in California in 2022. \r\n                   The top three most visited parks are **Golden Gate National\r\n                   Recreation Area**, **Yosemite National Park**, and **Joshua\r\n                   Tree National Park**.\"), \r\n               color = \"white\", size = 3.75, family = \"Lora\", lineheight = 0.6,\r\n               width = unit(1.8, \"in\"), fill = NA, box.color = NA) + \r\n  \r\n  # NPS logo\r\n  geom_richtext(aes(x = -118.75, y = 40, label = \"<img src='NPS_logo.PNG' width='27.5'/>\"), \r\n                fill = NA, label.color = NA, label.padding = unit(rep(0, 4), \"pt\")) + \r\n\r\n  # color pallete\r\n  scale_color_manual(values = c(\"#fee5d9\", \"#fcae91\", \"#fb6a4a\", \"#de2d26\", \"#a50f15\")) + \r\n  scale_fill_manual(values = c(\"#fee5d9\", \"#fcae91\", \"#fb6a4a\", \"#de2d26\", \"#a50f15\")) + \r\n  \r\n  # map limits\r\n  coord_sf(xlim = c(-125, -112), ylim = c(31.5, 42.2)) +\r\n  \r\n  # legend label position\r\n  guides(color = guide_legend(title = NULL, label.position = \"bottom\"),\r\n         fill = guide_legend(title = NULL, label.position = \"bottom\")) + \r\n  \r\n  # plot background and legend appearance\r\n  theme_void() + \r\n  theme(plot.background = element_rect(fill = \"grey40\", color = \"grey40\"),\r\n        legend.position = c(0.5, 0.05),\r\n        legend.direction = \"horizontal\",\r\n        legend.key.width = unit(0.5, \"in\"),\r\n        legend.key.height = unit(0.05, \"in\"),\r\n        legend.text = element_text(color = \"white\", size = 9, family = \"Lora\", \r\n                                   lineheight = 0.5, margin = margin(t = -2)),\r\n        legend.spacing.x = unit(0, \"in\"))\r\n\r\nCA_park_map\r\n\r\n\r\n\r\nThis is our final product. Awesome!\r\nSummary\r\nTo recap what we did in this post, we made a ggplot map from external shapefiles. The key is to read the shapefiles into R as sf objects using the function st_read(), make sure their coordinate reference systems are compatible, and plot the sf objects using the function geom_sf(). Finally, a bit of polishing will bring the map to the next level!\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-05-24-post-26-ggplot-map-series-no2-simple-feature-maps/../../homepage_images/Post26.png",
    "last_modified": "2023-08-03T03:37:12-04:00",
    "input_file": {},
    "preview_width": 729,
    "preview_height": 768
  },
  {
    "path": "posts/2023-03-09-post-25-ggplot-map-series-no1-basic-ggplot-maps/",
    "title": "Post #25. ggplot Map Series No.1: Creating polygon maps in ggplots",
    "description": "In this post, you will learn about how to create basic polygon maps and choropleth maps in ggplots.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-03-09",
    "categories": [
      "2023",
      "Map Series"
    ],
    "contents": "\r\n\r\nBackground\r\nWelcome to my second blog post series: the ggplot Map Series! Maps are a staple for research, science communication, and even everyday life. In this series, I’ll write about making all kinds of maps in ggplots: polygon maps, vector maps, and raster maps, using a variety of data sources from built-in package data sets and online databases, to manually-created data and other external files. Making maps is a critical skill to have under the belt and will certainly go a long way, and I hope this series will come in handy for every reader, you included of course!\r\nIntroduction\r\nThere are a diverse set of maps in ggplots. In this first post of the series, I’ll just start simple with the most basic type of maps—the polygon maps, using the built-in map data from the maps package.\r\nCreate a polygon map with maps\r\nIn the following section, we’ll first create a world base map using the world map data in maps package. Next, we’ll turn this base map into a choropleth map by adding a theme to it. Finally, we’ll take a look at some other available map data in the maps package.\r\n1. A basic world map\r\nLet’s make a world base map by retrieving the world data from the maps package. The returned object is a dataframe with a set of longitude and latitude coordinates that define the border of each country. To draw the map, we’ll pass this dataframe into geom_polygon() and map the longitude and latitude coordinates to x and y aesthetic. Also, we need to specify the “group” aesthetic so that ggplot knows how the points are grouped in order to form the polygons.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(maps)\r\n\r\n### Get the world map data\r\nworld_map <- map_data(map = \"world\")\r\nhead(world_map)\r\n\r\n       long      lat group order region subregion\r\n1 -69.89912 12.45200     1     1  Aruba      <NA>\r\n2 -69.89571 12.42300     1     2  Aruba      <NA>\r\n3 -69.94219 12.43853     1     3  Aruba      <NA>\r\n4 -70.00415 12.50049     1     4  Aruba      <NA>\r\n5 -70.06612 12.54697     1     5  Aruba      <NA>\r\n6 -70.05088 12.59707     1     6  Aruba      <NA>\r\n\r\n### Make a world base map\r\nP_world_map <- ggplot(data = world_map) + \r\n  geom_polygon(aes(x = long, y = lat, group = group), color = \"white\", fill = \"grey\") +  # need to specify the \"group\" aesthetic\r\n  geom_hline(yintercept = Inf, color = \"grey\") +  # top panel border\r\n  geom_hline(yintercept = -Inf, color = \"grey\") +  # bottom panel border\r\n  geom_vline(xintercept = Inf, color = \"grey\") +  # right panel border\r\n  geom_vline(xintercept = -Inf, color = \"grey\") +  # left panel border\r\n  theme_void() # empty theme\r\n\r\nP_world_map\r\n\r\n\r\n\r\n\r\nDo you notice that there is a “region” column in the world map data containing the country names? The map_data() function has a useful argument that allows user to subset the world data by this column. For example, we can get the data for Australia and draw it on the base map using different border and fill colors:\r\n\r\n\r\n### Get the Australia data\r\nworld_map_Australia <- map_data(map = \"world\", region = \"Australia\")\r\n\r\n### Draw the Australia map with different colors\r\nP_world_map <- P_world_map + \r\n  geom_polygon(data = world_map_Australia, aes(x = long, y = lat, group = group), color = \"green4\", fill = \"green3\")\r\n\r\nP_world_map\r\n\r\n\r\n\r\n\r\nAnother thing we can do is to add points to the map. Let’s get a table of top peaks in the world from Wikipedia and draw them on the map.\r\n\r\n\r\nlibrary(rvest)  # the package for web scraping\r\n\r\n### Get a table of world's top peaks from Wikipedia\r\ntop_peaks_df_raw <- read_html(\"https://en.wikipedia.org/wiki/List_of_highest_mountains_on_Earth\") %>% \r\n  html_element(xpath = '//*[@id=\"mw-content-text\"]/div[1]/table[3]') %>% \r\n  html_table()\r\n\r\n### Data wrangling\r\ntop_peaks_df_clean <- top_peaks_df_raw %>% \r\n  select(2, 3, 8) %>% \r\n  `colnames<-`(c(\"Mountain\", \"Elevation\", \"Coordinates\")) %>% \r\n  slice(-(1:2)) %>% \r\n  mutate(Mountain = ifelse(row_number(Mountain) == 1, \"Mount Everest\", Mountain)) %>% \r\n  rowwise() %>% \r\n  mutate(Coordinates = str_extract(Coordinates, pattern = \"/ [0-9|.]*; [0-9|.]+\")) %>% \r\n  mutate(Coordinates = str_remove(Coordinates, pattern = \"/ \")) %>% \r\n  separate(col = \"Coordinates\", into = c(\"Lat\", \"Long\"), sep = \"; \", convert = T)\r\n  \r\n### Draw the peaks on the map\r\nP_world_map <- P_world_map + \r\n  geom_point(data = top_peaks_df_clean, aes(x = Long, y = Lat), shape = 17)\r\n\r\nP_world_map\r\n\r\n\r\n\r\n\r\nThe default map projection is the Mercator projection, in which the true bearing and shape are preserved while the area is increasingly distorted towards the polar regions. We can apply other projections provided by the mapproj package. For example, the Mollweide projection sacrifices the bearing and shape for area, and so it is appropriate for maps that require a more accurate representation of country sizes. A full list of the available projections are shown on the help page of mapproject().\r\n\r\n\r\nlibrary(mapproj)\r\n\r\n### Change the map projection to Mollweide projection\r\nP_world_map + \r\n  coord_map(projection = \"mollweide\", xlim = c(-180, 180))  # need to set \"xlim = c(-180, 180)\" to avoid the weird plotting bug \r\n\r\n\r\n\r\n2. Choropleth map\r\nA choropleth map is a thematic map that visualizes the quantity of a variable across a geographical area (e.g., the population size of each county in a country) using different colors. This kind of map provides an easy quick glance at the spatial patterns of the variable of interest.\r\nMaking a choropleth map is pretty similar to making a base map; the only additional step is to get the variable data and associate them with the map data. In the example below, we’re going to make a choropleth map of the bird species richness in the world. We first get a table of bird richness by country from the website, standardize the country names and merge the bird data into the world map data, and fill the countries by richness.\r\n\r\n\r\n### Get a table of bird species richness by country\r\nbird_by_country <- read_html(\"https://rainforests.mongabay.com/03birds.htm\") %>% \r\n  html_element(\"table\") %>% \r\n  html_table()\r\n\r\n### Standardize the country names\r\nlibrary(countrycode)\r\n\r\nbird_by_country <- bird_by_country %>% \r\n  rename(region = `Country / region`,\r\n         richness = `Bird species count`) %>% \r\n  mutate(region_std = countryname(region)) %>% \r\n  rowwise() %>% \r\n  mutate(richness = str_remove(richness, pattern = \",\") %>% as.numeric())\r\n\r\nworld_map <- world_map %>% \r\n  mutate(region_std = countryname(region))\r\n\r\n### Merge the bird data into the world map data\r\nworld_map <- world_map %>% \r\n  left_join(bird_by_country, by = \"region_std\")\r\n\r\n### Make the choropleth\r\nP_choropleth <- ggplot(data = world_map) + \r\n  geom_polygon(aes(x = long, y = lat, group = group, fill = richness), color = \"grey\") +\r\n  geom_hline(yintercept = Inf, color = \"grey\") +\r\n  geom_hline(yintercept = -Inf, color = \"grey\") +\r\n  geom_vline(xintercept = Inf, color = \"grey\") +\r\n  geom_vline(xintercept = -Inf, color = \"grey\") +\r\n  scale_fill_viridis_c(name = \"Number of species\", breaks = seq(0, 1800, by = 300)) + \r\n  guides(fill = guide_colorbar(title.position = \"top\")) +\r\n  theme_void() + \r\n  theme(legend.position = \"top\",\r\n        legend.direction = \"horizontal\",\r\n        legend.key.width = unit(0.8, \"in\"),\r\n        legend.title = element_text(hjust = 0.5, vjust = 0.5, size = 11),\r\n        legend.text = element_text(size = 10))\r\n\r\nP_choropleth\r\n\r\n\r\n\r\n3. Other available map data\r\nBesides the world map we’ve been playing around with earlier, there are a few other map data in the maps package: the first-level administrative divisions of the US, Italy, and France, as well as the second-level administrative divisions (counties) of the US. Let’s take a look at them:\r\n\r\n\r\n### A function to create the map\r\nmap_fun <- function(map_name){\r\n  \r\n  map_dat <- map_data(map = map_name)\r\n  \r\n  P <- ggplot(data = map_dat) + \r\n    geom_polygon(aes(x = long, y = lat, group = group), color = \"white\", fill = \"grey\") +\r\n    geom_hline(yintercept = Inf, color = \"grey\") + \r\n    geom_hline(yintercept = -Inf, color = \"grey\") +  \r\n    geom_vline(xintercept = Inf, color = \"grey\") +  \r\n    geom_vline(xintercept = -Inf, color = \"grey\") +\r\n    labs(title = map_name) +\r\n    theme_void() + \r\n    theme(plot.title = element_text(hjust = 0.5, vjust = 3, size = 15))\r\n  \r\n  return(P)\r\n}\r\n\r\n### Make the maps \r\nP_state <- map_fun(\"state\")\r\nP_italy <- map_fun(\"italy\")\r\nP_france <- map_fun(\"france\")\r\nP_us_county <- map_fun(\"county\")\r\n\r\n### Arrange the maps\r\nlibrary(patchwork)\r\n\r\n(P_italy + plot_spacer() + P_state + \r\n  plot_layout(ncol = 3, widths = c(1, 0.05, 1.5)))/\r\n(P_france + plot_spacer() + P_us_county +\r\n  plot_layout(ncol = 3, widths = c(1, 0.05, 1.5)))\r\n\r\n\r\n\r\nSummary\r\nTo recap, in this post we learned about how to create a polygon world map using the built-in data from the maps package, and how we can modify the base map by highlighting a certain area, adding points, and changing the map projection. We also went a step further to make a choropleth map of the bird species richness in the world. This type of map is more informative and it would be quite handy to know how to make it yourself!\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-03-09-post-25-ggplot-map-series-no1-basic-ggplot-maps/../../homepage_images/Post25.png",
    "last_modified": "2023-05-26T02:18:41-04:00",
    "input_file": {},
    "preview_width": 1536,
    "preview_height": 960
  },
  {
    "path": "posts/2023-02-18-post-24-gt-and-ggplot-visualizing-bwc-in-taiwan/",
    "title": "Post #24. The spark between gt and ggplot2: Visualizing the top ten bird-window collision species in Taiwan",
    "description": "An awesome integration of `gt` and `ggplot2` tells the story of the top ten bird-window collision species in Taiwan!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-02-18",
    "categories": [
      "2023"
    ],
    "contents": "\r\n\r\nIntroduction\r\nThe ggplot2 package, one of the most popular packages in R, is a powerful tool for making elegant data visualizations based on the grammar of graphics. Recently, the gt package, the ggplots for tables, came on the scene. Based on the grammar of tables, it makes creating tables in R much more convenient and versatile.\r\nThe main idea of gt is to build tables from a set of components such as the header, the stub, the column labels, the body, and the footer. We can compose each of these parts individually, customize their formats and styles, and finally put them together. gt is itself an amazing package for awesome table displays. But what’s even more exciting is that it can be used in conjunction with ggplots, which will certainly enhance the effectiveness of data visualizations and I can’t wait to try it out.\r\nTo this end, I’ll do a small data viz project in this post to visualize the top ten bird-window collision species in Taiwan. Bird-window collisions, quite literally, are birds colliding with windows of buildings or other human-made structures. Study 1 has shown that this is one of the leading anthropogenic bird mortality sources, killing hundreds of millions of birds each year.\r\nAt the end of the post, you’ll find out what the top ten bird-window collision species in Taiwan are. Also, this post is not just a data viz practice; hopefully, it can help raise the awareness of this concerning wildlife issue and make the invisible visible. Finally, a shout-out to my friend Chi-Heng Hsieh, who kindly provided the bird-window collision data for this post!\r\nLet’s build the table\r\nBefore we start off, I would like to give you an overall idea of what the table will look like: It has a first column showing the images of the bird species, a second column showing the species names along with a short description of each, a third column showing the total number of collision cases for each species between 2010 and 2022, and a fourth column showing the annual collision trends for each species over this 13-year period.\r\nIn the following section, I’ll break down the process into several steps so that it’s easier to follow and understand what the code is doing.\r\n1. Data preparation and summary\r\nAs always, the first step in a data project is to prepare the data. After reading in the data set, we count the total number of collision cases between 2010 and 2022, as well as the number of species recorded in this period. Because there are some cases where the colliding individuals were only identified to the genus or family level, we filter them out before tallying the unique species names.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Read in the data set\r\nbwc_data <- read_csv(\"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2023-02-18-post-24-gt-and-ggplot-visualizing-bwc-in-taiwan/BWC_data.csv\")\r\n\r\n### Total cases between 2010 and 2022\r\nbwc_data %>% \r\n  filter(year >= 2010) %>% \r\n  nrow()\r\n\r\n[1] 3608\r\n\r\n### Number of collision species\r\nbwc_data %>% \r\n  filter(year >= 2010) %>%\r\n  rowwise() %>% \r\n  filter(length(unlist(str_split(species, \" \"))) == 2) %>%  # remove the families\r\n  filter(!str_detect(species, \"sp\\\\.\")) %>%  # remove the genera\r\n  distinct(species) %>% \r\n  nrow()\r\n\r\n[1] 170\r\n\r\n2. The top ten collision species\r\nNext, we count the number of collision cases by species, select the top ten species, and add their common names.\r\n\r\n\r\nbwc_top_collision_df <- bwc_data %>% \r\n  filter(year >= 2010) %>% \r\n  group_by(species) %>% \r\n  summarise(n = n()) %>% \r\n  arrange(desc(n)) %>% \r\n  slice_head(n = 10) %>% \r\n  mutate(common_name = c(\"Taiwan barbet\",\r\n                         \"Asian emerald dove\",\r\n                         \"Spotted dove\",\r\n                         \"Eurasian tree sparrow\",\r\n                         \"Crested goshawk\",\r\n                         \"Common kingfisher\",\r\n                         \"Light-vented bulbul\",\r\n                         \"Pale thrush\",\r\n                         \"Swinhoe's white-eye\",\r\n                         \"Oriental turtle dove\"))\r\n\r\n\r\n3. The images and short descriptions of the species\r\nNow, we get the images of the top ten collision species from the The Cornell Lab of Ornithology’s Macaulay Library and add a short description of each species based on the information on eBird. The descriptions are wrapped inside the HTML <tags> to customize the text appearance. (You’ll see how this works later.)\r\n\r\n\r\n### The species images\r\nbwc_top_collision_df <- bwc_top_collision_df %>% \r\n  mutate(image = c(\"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/85866641/480\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/65752231/320\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/351501301/480\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/391684791/320\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/352462361/320\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/387920071/320\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/147572491/320\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/465299711/480\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/299650741/480\",\r\n                   \"https://cdn.download.ams.birds.cornell.edu/api/v1/asset/472227361/480\"))\r\n\r\n### Short descriptions of the species\r\nlibrary(glue)\r\n\r\nbwc_top_collision_df <- bwc_top_collision_df %>% \r\n  mutate(description = c(\r\n  \"Distinctive <span style = 'color: green'>endemic<\/span> with a bright green body and a head in red, blue, yellow, \r\n  and black. Vocalization characterized by a frog-like croaking.\",\r\n  \"Brightly-colored dove of the forest floor with emerald green wings, coral-red bill, and ash-gray forehead. \r\n  Male with an extensive silver cap.\",\r\n  \"Tame dove commonly found in open forests, fields, and parks. \r\n  Brown overall with a rosy breast and a unique white-spotted black nape patch.\",\r\n  \"Frequent visitor of urban areas and human settlements. Easily identified by a rich chestnut cap and contrasting black-white cheeks.\",\r\n  \"Powerful hawk of forests with thick brown stripes in belly and breast. \r\n  Flying adults showing white fluffy feather clumps on both sides of the tail.\",\r\n  \"Beautiful little blue-and-orange bird with a long pointed bill. Female with an orange-red lower mandible.\r\n  Found along rivers, lakes, and ponds.\",\r\n  \"Common songbird of gardens, parks, and forests. Grey-olive back with a large white patch covering the nape and black head.\",\r\n  \"Brownish songbird in green areas and forests. Male with a blue-grey head and female with a white throat. \r\n  White tail corners obvious in flight.\",\r\n  \"Adorable exquisite songbird with lemon-yellow throat and olive-suffused back. \r\n  Featuring a prominent white eyering.\",\r\n  \"Attractive dove with golden-brown-scaled wing coverts, clay-colored underparts, \r\n  and black-and-white striped patches on the sides of its neck.\")) %>% \r\n  mutate(description = glue(\"<p align = 'left' style = 'line-height: 25px'>\r\n                              <span style = 'font-size: 17px'><b>{common_name}<\/b> (<i>{species}<\/i>)<\/span>\r\n                              <br>{description}<\/p>\"))\r\n\r\n\r\n4. The line charts of annual collision trends\r\nOur last column in the table is the line charts of annual collision trends for the top ten species. First, we select the top ten species from the full data and summarize the annual cases for each of them. Next, we create a function to draw the line charts by species. Lastly, we apply the function to create a line chart for each species.\r\n\r\n\r\n### The annual cases for the top ten collision species \r\nbwc_linechart_df <- bwc_data %>% \r\n  filter(year >= 2010) %>% \r\n  filter(species %in% bwc_top_collision_df$species) %>% \r\n  group_by(species, year) %>% \r\n  summarise(n = n())\r\n\r\n### A function to create the line charts by species\r\nlinechart_fun <- function(sp){\r\n  ggplot(data = filter(bwc_linechart_df, species == sp)) + \r\n    geom_line(aes(x = year, y = n), linewidth = 4, alpha = 0.5) +\r\n    geom_point(aes(x = year, y = n), size = 5) +\r\n    labs(x = \"\", y = \"Number of cases\") +\r\n    scale_x_continuous(limits = c(2010, 2022), breaks = c(2010, 2016, 2022)) +\r\n    scale_y_continuous(limits = c(0, max(filter(bwc_linechart_df, species == sp)$n + 3)), expand = c(0, 0)) +\r\n    theme_classic(base_size = 13) +\r\n    theme(plot.background = element_blank(),\r\n          panel.background = element_blank(),\r\n          axis.ticks.x = element_blank(),\r\n          panel.grid.major.y = element_line(color = \"#66666680\"),\r\n          axis.title.y = element_text(size = 45, hjust = 0.6),\r\n          axis.text.x = element_text(size = 40, vjust = -2),\r\n          axis.text.y = element_text(size = 40),\r\n          plot.margin = margin(25, 10, 0, 0))\r\n}\r\n\r\n### Apply the line chart function to each species \r\nbwc_linecharts <- map(bwc_top_collision_df$species, linechart_fun)\r\nbwc_linecharts[[1]]  # take a look at the line chart for the first species\r\n\r\n\r\n\r\n5. The header and footer\r\nThe final two pieces of the table are the header and footer. The header consists of a main title and a subtitle with a brief table description; the footer shows the data source of the species images and descriptions. Again, the text is written in HTML to allow for more customization.\r\n\r\n\r\ntitle_text <- \"<b><i>Top Ten Bird-Window Collision Species in Taiwan<\/i><\/b>\"\r\n\r\nsubtitle_text <- \"This summary table shows the top ten bird-window collision \r\nspecies between 2010 and 2022 in Taiwan, based on a data set collected from \r\n<span style = 'color: #ffc107'>The Taiwan Roadkill Observation Network<\/span> and \r\n<span style = 'color: #4267B2'>Reports on Bird-Glass Collisions Facebook Group<\/span>. \r\n170 species with around 3,600 collision cases were recorded over this 13-year period.\"\r\n\r\nfooter_text <- \"<p margin-bottom: 0em><i>Species images and descriptions: \r\nThe Cornell Lab of Ornithology Macaulay Library & eBird<\/i> <span style = 'margin-left: 5px'> <img src = 'https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2023-02-18-post-24-gt-and-ggplot-visualizing-bwc-in-taiwan/Macaulay_lib_logo.png' width = '90' height = '30' style = 'vertical-align: middle'/><\/span><span style = 'margin-left: 3px'><img src = 'https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2023-02-18-post-24-gt-and-ggplot-visualizing-bwc-in-taiwan/eBird_logo.png' width = '70' height = '30' style = 'vertical-align: middle'/><\/p>\"\r\n\r\n\r\n6. Put everything together\r\nHaving all the ingredients on hand, it’s time to put them together! There are several things to note here:\r\nWe prepare a data frame with the columns in the desired order and pass it to the master function gt() to create a table.\r\nWe create two blank columns to add some white space. The amount of spacing may not be desirable now, but this can be easily adjusted later.\r\nWe use the function gt_img_circle() to create circle images of the species.\r\nRemember we used HTML in the short descriptions? This is not readily recognized by gt(), but we can use text_transform() along with html() to tell gt() that the column “description” should be understood in the HTML language.\r\nFor the line charts, we first set the column elements to NA, and again use text_transform() along with ggplot_image() to tell gt() that the line charts in the list “bwc_linecharts” should be treated as ggplots.\r\nSame as the descriptions, the header and footer are passed into html() so that the text is understood in the HTML language.\r\n\r\n\r\nlibrary(gt)\r\nlibrary(gtExtras)  # for the function gt_img_circle()\r\n\r\n### Build the first table\r\nbwc_table <- bwc_top_collision_df %>% \r\n  mutate(blank1 = \"\", blank2 = \"\", linechart = NA) %>% \r\n  select(blank1, image, blank2, description, n, linechart) %>% \r\n  gt() %>%\r\n  \r\n  # images\r\n  gt_img_circle(column = \"image\", height = 100, border_weight = 0) %>% \r\n  \r\n  # short descriptions\r\n  text_transform(locations = cells_body(columns = description),\r\n                 fn = function(x){map(bwc_top_collision_df$description, html)}) %>% \r\n  \r\n  # line charts\r\n  text_transform(locations = cells_body(columns = linechart),\r\n                 fn = function(x){map(bwc_linecharts, ggplot_image, \r\n                                      height = px(90), aspect_ratio = 2.2)}) %>%   \r\n  # header\r\n  tab_header(title = html(title_text),\r\n             subtitle = html(subtitle_text)) %>%\r\n  \r\n  # footer\r\n  tab_source_note(source_note = html(footer_text))\r\n\r\nbwc_table\r\n\r\n\r\nTop Ten Bird-Window Collision Species in Taiwan\r\n    This summary table shows the top ten bird-window collision \r\nspecies between 2010 and 2022 in Taiwan, based on a data set collected from \r\nThe Taiwan Roadkill Observation Network and \r\nReports on Bird-Glass Collisions Facebook Group. \r\n170 species with around 3,600 collision cases were recorded over this 13-year period.\r\n    blank1\r\n      image\r\n      blank2\r\n      description\r\n      n\r\n      linechart\r\n    \r\n\r\n\r\n\r\nTaiwan barbet (Psilopogon nuchalis)\r\nDistinctive endemic with a bright green body and a head in red, blue, yellow, \r\n  and black. Vocalization characterized by a frog-like croaking.\r\n639\r\n\r\n\r\n\r\n\r\nAsian emerald dove (Chalcophaps indica)\r\nBrightly-colored dove of the forest floor with emerald green wings, coral-red bill, and ash-gray forehead. \r\n  Male with an extensive silver cap.\r\n351\r\n\r\n\r\n\r\n\r\nSpotted dove (Streptopelia chinensis)\r\nTame dove commonly found in open forests, fields, and parks. \r\n  Brown overall with a rosy breast and a unique white-spotted black nape patch.\r\n196\r\n\r\n\r\n\r\n\r\nEurasian tree sparrow (Passer montanus)\r\nFrequent visitor of urban areas and human settlements. Easily identified by a rich chestnut cap and contrasting black-white cheeks.\r\n193\r\n\r\n\r\n\r\n\r\nCrested goshawk (Accipiter trivirgatus)\r\nPowerful hawk of forests with thick brown stripes in belly and breast. \r\n  Flying adults showing white fluffy feather clumps on both sides of the tail.\r\n188\r\n\r\n\r\n\r\n\r\nCommon kingfisher (Alcedo atthis)\r\nBeautiful little blue-and-orange bird with a long pointed bill. Female with an orange-red lower mandible.\r\n  Found along rivers, lakes, and ponds.\r\n176\r\n\r\n\r\n\r\n\r\nLight-vented bulbul (Pycnonotus sinensis)\r\nCommon songbird of gardens, parks, and forests. Grey-olive back with a large white patch covering the nape and black head.\r\n155\r\n\r\n\r\n\r\n\r\nPale thrush (Turdus pallidus)\r\nBrownish songbird in green areas and forests. Male with a blue-grey head and female with a white throat. \r\n  White tail corners obvious in flight.\r\n144\r\n\r\n\r\n\r\n\r\nSwinhoe's white-eye (Zosterops simplex)\r\nAdorable exquisite songbird with lemon-yellow throat and olive-suffused back. \r\n  Featuring a prominent white eyering.\r\n97\r\n\r\n\r\n\r\n\r\nOriental turtle dove (Streptopelia orientalis)\r\nAttractive dove with golden-brown-scaled wing coverts, clay-colored underparts, \r\n  and black-and-white striped patches on the sides of its neck.\r\n93\r\nSpecies images and descriptions: \r\nThe Cornell Lab of Ornithology Macaulay Library & eBird  \r\n    \r\n\r\n\r\nNice, we get our fist table out! Though, it is not in a good shape and definitely needs some adjustments and fine-tuning. This is what we are going to do next.\r\n7. Polish the table\r\nThere are quite a few things in the table we can modify:\r\nColumn labels\r\nColumn widths\r\nTable width and the padding around table components\r\nThe style (font size, font family, color, alignment, etc.) of header, column labels, body columns, and footer\r\nThe background color of the table rows\r\nThe main purpose here is to show that we can customize the table as we wish, and so I’ll not dive into the nitty-gritty of styling functions and arguments. In fact, we are only scratching the surface, and there are a lot more things we can do. If interested, check out the amazing references and tutorials on the gt package website for more details!\r\nIt does require a bit of trial and error to get everything at the exact place. So be patient and have fun experimenting. It’s super satisfying to see the final product!\r\n\r\n\r\nbwc_table <- bwc_table %>% \r\n  \r\n  # column labels\r\n  cols_label(blank1 = \"\",\r\n             image = \"\",\r\n             blank2 = \"\",\r\n             description = \"\",\r\n             n = html(\"2010-2022&nbsp; <br> Total Cases\"),\r\n             linechart = html(\"2010-2022 <br> Annual Trend\")) %>%\r\n  \r\n  # column widths\r\n  cols_width(blank1 ~ px(10),\r\n             image ~ px(107.5),\r\n             blank2 ~ px(10),\r\n             description ~ px(370),\r\n             n ~ px(110),\r\n             linechart ~ px(300)) %>%\r\n  \r\n  # table width and padding\r\n  tab_options(table.width = 900,\r\n              container.width = 950,\r\n              heading.padding = px(12),\r\n              data_row.padding = px(0),\r\n              source_notes.padding = px(0)) %>%\r\n  \r\n  # title style\r\n  tab_style(locations = cells_title(groups = \"title\"),\r\n            style = list(cell_text(font = google_font(name = \"Kanit\"),\r\n                                   size = px(35),\r\n                                   align = \"left\"))) %>% \r\n  \r\n  # subtitle style\r\n  tab_style(locations = cells_title(groups = \"subtitle\"),\r\n            style = list(cell_text(font = google_font(name = \"Arimo\"),\r\n                                   size = px(20),\r\n                                   color = \"grey30\",\r\n                                   align = \"left\"))) %>% \r\n  \r\n  # column label style \r\n  tab_style(locations = cells_column_labels(c(n, linechart)),\r\n            style = list(cell_text(font = google_font(name = \"Arimo\"),\r\n                                   v_align = \"middle\",\r\n                                   weight = \"bold\",\r\n                                   size = \"large\"))) %>% \r\n  \r\n  # body column style\r\n  tab_style(locations = cells_body(columns = c(description)),\r\n            style = list(cell_text(font = google_font(name = \"Arimo\"),\r\n                                   align = \"center\"))) %>%\r\n  \r\n  tab_style(locations = cells_body(columns = c(n)),\r\n            style = list(cell_text(font = google_font(name = \"Arimo\"),\r\n                                   align = \"center\",\r\n                                   size = px(25)))) %>%\r\n  \r\n  # footer style\r\n  tab_style(locations = cells_source_notes(),\r\n            style = list(cell_text(font = google_font(name = \"Arimo\"),\r\n                                   size = \"small\",\r\n                                   v_align = \"top\"))) %>% \r\n  \r\n  # row background color\r\n  tab_style(locations = cells_body(rows = seq(1, 10, 2)),\r\n            style = list(cell_fill(color = \"#d8dde0\")))\r\n\r\nbwc_table\r\n\r\n\r\nTop Ten Bird-Window Collision Species in Taiwan\r\n    This summary table shows the top ten bird-window collision \r\nspecies between 2010 and 2022 in Taiwan, based on a data set collected from \r\nThe Taiwan Roadkill Observation Network and \r\nReports on Bird-Glass Collisions Facebook Group. \r\n170 species with around 3,600 collision cases were recorded over this 13-year period.\r\n    \r\n      \r\n      \r\n      \r\n      2010-2022   Total Cases\r\n      2010-2022  Annual Trend\r\n    \r\n\r\n\r\n\r\nTaiwan barbet (Psilopogon nuchalis)\r\nDistinctive endemic with a bright green body and a head in red, blue, yellow, \r\n  and black. Vocalization characterized by a frog-like croaking.\r\n639\r\n\r\n\r\n\r\n\r\nAsian emerald dove (Chalcophaps indica)\r\nBrightly-colored dove of the forest floor with emerald green wings, coral-red bill, and ash-gray forehead. \r\n  Male with an extensive silver cap.\r\n351\r\n\r\n\r\n\r\n\r\nSpotted dove (Streptopelia chinensis)\r\nTame dove commonly found in open forests, fields, and parks. \r\n  Brown overall with a rosy breast and a unique white-spotted black nape patch.\r\n196\r\n\r\n\r\n\r\n\r\nEurasian tree sparrow (Passer montanus)\r\nFrequent visitor of urban areas and human settlements. Easily identified by a rich chestnut cap and contrasting black-white cheeks.\r\n193\r\n\r\n\r\n\r\n\r\nCrested goshawk (Accipiter trivirgatus)\r\nPowerful hawk of forests with thick brown stripes in belly and breast. \r\n  Flying adults showing white fluffy feather clumps on both sides of the tail.\r\n188\r\n\r\n\r\n\r\n\r\nCommon kingfisher (Alcedo atthis)\r\nBeautiful little blue-and-orange bird with a long pointed bill. Female with an orange-red lower mandible.\r\n  Found along rivers, lakes, and ponds.\r\n176\r\n\r\n\r\n\r\n\r\nLight-vented bulbul (Pycnonotus sinensis)\r\nCommon songbird of gardens, parks, and forests. Grey-olive back with a large white patch covering the nape and black head.\r\n155\r\n\r\n\r\n\r\n\r\nPale thrush (Turdus pallidus)\r\nBrownish songbird in green areas and forests. Male with a blue-grey head and female with a white throat. \r\n  White tail corners obvious in flight.\r\n144\r\n\r\n\r\n\r\n\r\nSwinhoe's white-eye (Zosterops simplex)\r\nAdorable exquisite songbird with lemon-yellow throat and olive-suffused back. \r\n  Featuring a prominent white eyering.\r\n97\r\n\r\n\r\n\r\n\r\nOriental turtle dove (Streptopelia orientalis)\r\nAttractive dove with golden-brown-scaled wing coverts, clay-colored underparts, \r\n  and black-and-white striped patches on the sides of its neck.\r\n93\r\nSpecies images and descriptions: \r\nThe Cornell Lab of Ornithology Macaulay Library & eBird  \r\n    \r\n\r\n\r\nLooks cool, but still there are a few formatting issues (e.g., the short descriptions are cut off on the right) when displayed as an HTML page here.\r\nWe can save the HTML as an image to solve this problem:\r\n\r\n\r\nlibrary(webshot2)\r\ngtsave_extra(bwc_table, \"bwc_table.png\", zoom = 2)\r\n\r\n\r\nThis is the final table. Perfect!\r\n\r\n8. The messages from the table\r\nBefore we call it a wrap, let’s take a closer look at the table and see what we can learn from it.\r\nMany of the bird species on the list commonly occur in urban or sub-urban areas (e.g., spotted dove, Eurasian tree sparrow, light-vented bulbul, Swinhoe’s white-eye, and oriental turtle dove), which is a strong reason why they collide with windows quite frequently. But the collision issue is not limited to urban dwellers. There is also common kingfisher, a species that lives around water bodies, and pale thrush, a winter migrant in Taiwan. In fact, nine of the top ten species are resident birds, even though Taiwan lies close to the center of the East Asian-Australian Flyway. This is quite different from the patterns in the Western countries, where the majority of collisions are migratory birds.\r\nThe species that tops the list, Taiwan barbet (an endemic species in Taiwan), has nearly twice as many collision cases as the second species! This is quite special as not many cases have been reported for similar species in other countries. Another surprising species on the list is the raptor crested goshawk. It’s a bit mind-boggling that such an agile flyer also falls victim to bird-window collision. This could potentially have some ecological impacts as hawks are top predators in the ecosystem. Interestingly, three dove species show up on the list. Perhaps it’s because they are relatively poor in maneuvering, and also they are quite abundant around human settlements. A combination of both makes them vulnerable to window collisions.\r\nIn general, the collisions for these top ten species are trending upwards, despite some year-to-year fluctuations. This may be due to more reports in recent years as people are more aware of bird-window collisions. It can also be that there are more buildings/infrastructures with window surface, thus causing more collisions. The increasing trends are concerning and deserve our close attention.\r\nIt is noteworthy that the numbers of total cases shown in the table are just the tip of the iceberg: A majority of bird-window collisions got unnoticed. Even if noticed, many were unreported. There is increasing research on why birds collide with windows, and hopefully we will come up with effective measures to prevent it.\r\nSummary\r\nTo recap, in this post we built a cool gt table to visualize the top ten bird-window collision species in Taiwan. We first prepared the table columns, then put them in a data frame and created a first table, and finally polished the table by tweaking the format and style. We also integrated ggplots into the table to enhance data visualization.\r\nI used to think that R is not good at making tables, but now I’ve completely changed my point of view after writing this post. I believe you will have an itch for making your own gt tables too!\r\nHope you learn something useful from this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\nLoss, S. R., Will, T., & Marra, P. P. (2015). Direct mortality of birds from anthropogenic causes. Annual Review of Ecology, Evolution, and Systematics, 46, 99-120.↩︎\r\n",
    "preview": "posts/2023-02-18-post-24-gt-and-ggplot-visualizing-bwc-in-taiwan/../../homepage_images/Post24.png",
    "last_modified": "2023-03-16T23:54:39-04:00",
    "input_file": {},
    "preview_width": 1934,
    "preview_height": 3334
  },
  {
    "path": "posts/2023-01-13-post-23-ggplot-legend-tips-series-no8-legend-item-spacing/",
    "title": "Post #23. ggplot Legend Tips Series No.8: The nuts and bolts of legend item spacing",
    "description": "Here are all the nuts and bolts you need for working on legend item spacing!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2023-01-13",
    "categories": [
      "2023",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nIntroduction\r\nWelcome to my first blog post in 2023! I have been slacking off a\r\nlittle bit lately and feel so glad to ring in the new year with another\r\nLegend\r\nTips Series post.\r\nIn this post, I will show you how to adjust the spacing between\r\ndiscrete legend items (legend title, keys, and labels) as well as\r\nbetween multiple legends. This is going to be a handy one and let’s get\r\nto it!\r\nThe nuts and bolts of\r\nlegend spacing\r\n1. Single discrete legend\r\nWe’ll start with a single legend: There are four main arguments in\r\ntheme() when it comes to adjusting the spacing between\r\nlegend title, keys, and labels: legend.title,\r\nlegend.text, legend.spacing.x, and\r\nlegend.spacing.y. I’ll demonstrate them in the following\r\nsection for a vertical legend, a horizontal legend, and a legend with a\r\nmatrix layout.\r\n\r\n(1) Vertical legend\r\nTo adjust the spacing between legend title and the first legend key,\r\nchange the bottom margin of the title by specifying\r\nmargin = margin(b = ) in the legend.title\r\nargument. To adjust the spacing between legend keys and labels, use\r\nlegend.spacing.x = unit() and specify an appropriate value.\r\nSimilarly, to adjust the spacing between legend keys, use\r\nlegend.spacing.y = unit() and specify an appropriate value.\r\nNote that for legend.spacing.y = unit() to work, you\r\nMUST specify byrow = T in the\r\ncorresponding guides (in this case “color” guide). Otherwise, nothing\r\nwill happen!\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Default plot\r\nP_vertical_default <- ggplot(data = iris) + \r\n  geom_point(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_smooth(aes(x = Sepal.Length, y = Sepal.Width, color = Species, fill = after_scale(color)), method = \"lm\", se = T) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Sepal length\", y = \"Sepal width\") + \r\n  theme_classic(base_size = 13)\r\n\r\n### Adjust the spacing between legend items\r\nP_vertical_adjusted <- P_vertical_default + \r\n  theme(legend.title = element_text(margin = margin(b = 10)),  # adjust the spacing between the legend title and the first legend key \r\n        legend.spacing.x = unit(0.2, \"inch\"),  # adjust the horizontal spacing between legend keys and labels\r\n        legend.spacing.y = unit(0.2, \"inch\")) +  # adjust the vertical spacing between legend keys\r\n  guides(color = guide_legend(byrow = T))  # \"byrow = T\" is necessary for \"legend.spacing.y\" to work for vertical legends  \r\n\r\nP_vertical_default; P_vertical_adjusted\r\n\r\n\r\n\r\n\r\n(2) Horizontal layout\r\nSimilar to vertical legends, to adjust the spacing between legend\r\ntitle and the first legend key, change the right margin of the title by\r\nspecifying margin = margin(r = ) in the\r\nlegend.title argument. To adjust the spacing between legend\r\nkeys and labels, use legend.spacing.x = unit() and specify\r\nan appropriate value. Additionally, you can use\r\nlegend.text = element_text(margin = margin(r = )) to fine\r\ntune the spacing between the label (e.g., the label “setosa”) and the\r\nadjacent key (e.g., the blue key for “versicolor”).\r\nlegend.spacing.y = unit() is not relevant to horizontal\r\nlegends here.\r\n\r\n\r\n### Default plot\r\nP_horizontal_default <- ggplot(data = iris) + \r\n  geom_point(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_smooth(aes(x = Sepal.Length, y = Sepal.Width, color = Species, fill = after_scale(color)), method = \"lm\", se = T) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Sepal length\", y = \"Sepal width\") + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.position = \"top\",\r\n        legend.direction = \"horizontal\")\r\n\r\n### Adjust the spacing between legend items\r\nP_horizontal_adjusted <- P_horizontal_default + \r\n  theme(legend.title = element_text(margin = margin(r = 10)),  # adjust the spacing between legend title and the first legend key\r\n        legend.spacing.x = unit(0.2, \"inch\"),  # adjust the spacing between legend keys and labels\r\n        legend.text = element_text(margin = margin(r = 15)))  # fine tune the spacing between legend labels and adjacent legend keys\r\n        \r\nP_horizontal_default; P_horizontal_adjusted\r\n\r\n\r\n\r\n\r\n(3) Matrix layout\r\nWe’ve seen both vertical and horizontal legends, how about a\r\ncombination of both (matrix layout)? That’s actually easy-peasy: just\r\nput everything we did earlier together!\r\n\r\n\r\n### Default plot\r\nP_matrix_default <- ggplot(data = iris) + \r\n  geom_point(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_smooth(aes(x = Sepal.Length, y = Sepal.Width, color = Species, fill = after_scale(color)), method = \"lm\", se = T) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Sepal length\", y = \"Sepal width\") + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.position = \"top\",\r\n        legend.direction = \"horizontal\") + \r\n  guides(color = guide_legend(nrow = 2, ncol = 2, byrow = T))\r\n\r\n### Adjust the spacing between legend items\r\nP_matrix_adjusted <- P_matrix_default + \r\n  theme(legend.title = element_text(margin = margin(r = 10)),  # adjust the spacing between legend title and the first legend key\r\n        legend.spacing.x = unit(0.2, \"inch\"),  # adjust the horizontal spacing between legend keys and labels\r\n        legend.spacing.y = unit(0.2, \"inch\"),  # adjust the vertical spacing between legend keys\r\n        legend.text = element_text(margin = margin(r = 15)))  # fine tune the spacing between the legend label and the adjacent legend key\r\n        \r\nP_matrix_default; P_matrix_adjusted\r\n\r\n\r\n\r\nMultiple legends\r\nIn the previous section, we focused on adjusting the spacing between\r\nthe items within a legend. What if we have multiple legends and we want\r\nto change the spacing between them? Let’s see an example now:\r\n\r\n\r\n### Default plot\r\nP_multiple_default <- ggplot(data = iris) + \r\n  geom_point(aes(x = Sepal.Length, y = Sepal.Width, color = Species, alpha = Sepal.Length*Sepal.Width)) + \r\n  geom_smooth(aes(x = Sepal.Length, y = Sepal.Width, color = Species, fill = after_scale(color)), method = \"lm\", se = T) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  scale_alpha_continuous(name = \"Sepal L*W\") +\r\n  labs(x = \"Sepal length\", y = \"Sepal width\") + \r\n  theme_classic(base_size = 13)\r\n\r\nP_multiple_default\r\n\r\n\r\n\r\nSay we would like to increase the spacing between the two legends. We\r\ncan use the same hack as before by increasing the top margin of the\r\nlegend title, which will create more white space above both the title\r\n“Sepal L*W” and “Species”. However, because of this extra white space,\r\nthe legends will be squeezed down a bit. To solve this problem, I used\r\nlegend.box.margin = margin(b = 50) to increase the margin\r\nbelow the legend box to push the legends up.\r\n\r\n\r\n### Adjust the spacing between legends\r\nP_multiple_adjusted <- P_multiple_default +\r\n  theme(legend.title = element_text(margin = margin(t = 30)),  # create more white space above the legend titles\r\n        legend.box.margin = margin(b = 50))  # increase the margin below the legend box to push the legends up\r\n\r\nP_multiple_adjusted\r\n\r\n\r\n\r\nSummary\r\nTo recap, we learned how to adjust the spacing between the title,\r\nkeys, and labels within a legend, as well as the spacing between\r\nmultiple legends. Next time when you’re making ggplots, remember to\r\napply these tips to polish your figure!\r\nHope you learn something useful from this post and don’t forget to\r\nleave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2023-01-13-post-23-ggplot-legend-tips-series-no8-legend-item-spacing/../../homepage_images/Post23.png",
    "last_modified": "2023-01-18T23:54:44-05:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 768
  },
  {
    "path": "posts/2022-11-02-post-22-the-glowing-solar-system/",
    "title": "Post #22. An epic ggplot journey through the glowing solar system",
    "description": "Ready for an epic ggplot journey through the glowing solar system? Let's go!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-11-02",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nBackground\r\nRecently, I stumbled upon a post\r\nby data visualization designer Cédric Scherer, and I was completely\r\nblown away: I could never imagine how amazing ggplots can be (I believe\r\nyou’ll be in awe of it too)! Inspired by this, I hope to create my own\r\none as well, both for fun and for learning and practicing. In fact, I\r\nthink this is an excellent opportunity to bring together different data\r\nscience skills: data scraping, data wrangling, and data visualization,\r\nto produce something cool and interesting.\r\nThe rocket is about to lift off now. Take a deep breath and we are\r\nready for our space journey!!!\r\nA leg-by-leg\r\njourney through the solar system\r\nThis is quite a long journey, and so I’ll break it down into several\r\nlegs so that we can fully explore the great scenery of the outer space\r\nalong our trip.\r\nLeg 1. Scrape the planetary\r\ndata\r\nOur first leg is to prepare the planetary data for our figure. We’ll\r\ndo so by scraping the information from the website and organizing it\r\ninto a tidy table.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(rvest)  # for scraping the website\r\nlibrary(janitor)  # for the function \"clean_names()\"\r\n\r\n### Read the website content \r\nhtml <- read_html(\"https://www.encyclopedia.com/reference/encyclopedias-almanacs-transcripts-and-maps/major-planets-solar-system-table\")\r\n\r\n### Extract and organize the table\r\nplanetary_dat <- html %>% \r\n  html_element(\"table\") %>%  # find the <table> element in the content\r\n  html_table() %>%  # parse the table into a dataframe\r\n  slice(-c(1, 2, 4)) %>%  # remove row 1, 2, and 4\r\n  select(where(function(x){!is.na(x) %>% any()})) %>%  # remove the columns with NAs\r\n  `colnames<-`(.[1, ]) %>%  # set the first row as the header\r\n  .[-1, ] %>%  # remove the first row\r\n  mutate(across(c(2, 5, 6, 7), as.numeric)) %>%  # convert these columns to numeric\r\n  rowid_to_column(var = \"row_id\") %>%  # add a row id\r\n  clean_names() %>%  # clean the column names\r\n  mutate(volume_earth_1 = (diameter_earth_1)^3)  # volumes of the planets relative to Earth\r\n\r\nhead(planetary_dat, 5)\r\n\r\n# A tibble: 5 × 9\r\n  row_id planet  distance_fr…¹ perio…² perio…³ mass_…⁴ diame…⁵ numbe…⁶\r\n   <int> <chr>           <dbl> <chr>   <chr>     <dbl>   <dbl>   <dbl>\r\n1      1 Mercury          0.39 88 days 59 days    0.06    0.38       0\r\n2      2 Venus            0.72 225 da… 243 da…    0.82    0.95       0\r\n3      3 Earth            1    365 da… 24 hou…    1       1          1\r\n4      4 Mars             1.52 687 da… 25 hou…    0.11    0.53       2\r\n5      5 Jupiter          5.2  12 yea… 10 hou…  318.     11.2       63\r\n# … with 1 more variable: volume_earth_1 <dbl>, and abbreviated\r\n#   variable names ¹​distance_from_the_sun_au, ²​period_of_revolution,\r\n#   ³​period_of_rotation, ⁴​mass_earth_1, ⁵​diameter_earth_1,\r\n#   ⁶​number_of_confirmed_satellites\r\n\r\nLeg 2.\r\nRetrieve the url paths to the planet images\r\nOur next leg is to add the urls of planet images to our planetary\r\ndata and create HTML <img> tags for plotting. The\r\ncolumn image_width specifies the sizes of the images that\r\nwill show up in the figure later.\r\n\r\n\r\nlibrary(glue)\r\n\r\n### The urls of planet images and HTML <img> tags\r\nplanetary_dat <- planetary_dat %>%\r\n  mutate(image_url = c(\r\n    \"https://scx2.b-cdn.net/gfx/news/hires/2015/whatsimporta.jpg\",\r\n    \"https://cdn.britannica.com/86/21186-050-C48F8AA1/radar-clouds-Scientists-surface-Venus-computer-image.jpg\",\r\n    \"https://cdn.britannica.com/25/160325-050-EB1C8FB7/image-instruments-Earth-satellite-NASA-Suomi-National-2012.jpg\",\r\n    \"https://mars.nasa.gov/system/content_pages/main_images/256_Webp.net-resizeimage_%284%29.jpg\",\r\n    \"https://upload.wikimedia.org/wikipedia/commons/c/c1/Jupiter_New_Horizons.jpg\",\r\n    \"https://cdn.britannica.com/80/145480-050-24BF0658/image-Hubble-Space-Telescope-Saturn-moons-shadow.jpg\",\r\n    \"https://upload.wikimedia.org/wikipedia/commons/c/c9/Uranus_as_seen_by_NASA%27s_Voyager_2_%28remastered%29_-_JPEG_converted.jpg\",\r\n    \"https://upload.wikimedia.org/wikipedia/commons/6/63/Neptune_-_Voyager_2_%2829347980845%29_flatten_crop.jpg\")) %>%  # the urls of planet images\r\n  mutate(image_width = c(15, 16, 17, 30, 31, 50, 22, 20)) %>%  # image sizes\r\n  mutate(image_tag = glue(\"<img src='{image_url}' width = '{image_width}'/>\"))  # HTML <img> tags\r\n\r\n\r\nLeg 3.\r\nCreate a basic polar line-dot chart of planets\r\nThe previous two legs were mostly about data preparation, and now we\r\nare ready to roll up our sleeves and do some heavy lifting. In our third\r\nleg, we will create a polar line-dot chart for the planets, with the\r\nlength of the curve proportional to the distance of the planet to the\r\nSun, and the size of the point proportional to the volume of the\r\nplanet.\r\nHere we’ll use the function geom_point_blur() in the\r\npackage ggblur to add blurry points, and the functions\r\nlighten() and desaturate() in the package\r\ncolorspace to modify the color of the points and lines.\r\nWe’ll also extend the lower limit of the x-axis to -1 to create some\r\nextra space at the center of the figure where we will be adding an image\r\nlater, and extend the upper limit of the y-axis to 35 to prevent the\r\nlongest curve from sticking too close to the origin.\r\n\r\n\r\nlibrary(ggblur)  # for the function \"geom_point_blur()\"\r\nlibrary(ggforce)  # for the function \"geom_link()\"\r\nlibrary(colorspace)  # for the function \"lighten()\" and \"desaturate()\"\r\n\r\n### A basic polar line-dot chart of planets\r\nP_solar_system <- ggplot() + \r\n  geom_point_blur(data = planetary_dat, aes(x = row_id, y = distance_from_the_sun_au,\r\n                                            color = row_id, color = after_scale(lighten(color, 0.5, space = \"HLS\")),\r\n                                            size = volume_earth_1, blur_size = volume_earth_1)) +\r\n  geom_link(data = planetary_dat, aes(x = row_id, y = 0, xend = row_id, \r\n                                      yend = distance_from_the_sun_au,\r\n                                      color = row_id, color = after_scale(desaturate(color, 0.3))), \r\n            size = 0.75, n = 300) +\r\n  geom_point(data = planetary_dat, aes(x = row_id, y = distance_from_the_sun_au, \r\n                                       color = row_id, size = volume_earth_1)) + \r\n  scale_x_continuous(limits = c(-1, 8)) +  # extend the lower limit of the x-axis\r\n  scale_y_continuous(limits = c(0, 35)) +  # extend the upper limit of the y-axis\r\n  scale_blur_size_continuous(range = c(5, 20)) + \r\n  guides(color = \"none\", size = \"none\", blur_size = \"none\") + \r\n  coord_polar(theta = \"y\", clip = \"off\")\r\n\r\nP_solar_system\r\n\r\n\r\n\r\nLeg 4. Make the lines\r\nand points shine\r\nOur forth leg is to change the appearance of the basic chart we just\r\nmade earlier. Specifically, we’ll change the color of the lines and\r\npoints using a customized color palette created with the function\r\ntableau_div_gradient_pal() in the package\r\nggthemes. We’ll then add a vertical line at the origin\r\nusing the function geom_link2() in the package\r\nggforce, which allows for continuous color gradients along\r\nthe line. I think this vertical line serves as an anchor for the curves\r\nso that they don’t seem to be floating. Lastly, we’ll set the background\r\nto black.\r\n\r\n\r\nlibrary(ggthemes)  # for the function \"tableau_div_gradient_pal()\"\r\n\r\n### Create a customized color palette\r\ncol_pal <- rev(tableau_div_gradient_pal(palette = \"Sunset-Sunrise Diverging\")(seq(0, 1, length = 8)))  \r\n\r\n### Glowing lines and points           \r\nP_solar_system <- P_solar_system + \r\n  geom_link2(aes(x = 1:8, y = 0, xend = 2:9, yend = 0, color = 1:8), n = 100) +\r\n  scale_color_gradientn(colors = col_pal) + \r\n  theme_void() + \r\n  theme(plot.background = element_rect(fill = \"black\"),  # black background\r\n        plot.margin = margin(0, 0, 0, 0))\r\n\r\nP_solar_system\r\n\r\n\r\n\r\nLeg 5. Add the planet images\r\nLeg five is an exciting one: adding the planet images! We’ll achieve\r\nthis by mapping the HTML <img> tags we created\r\nearlier in leg two to the figure, using the function\r\ngeom_richtext() in the package ggtext. By the\r\nway, ggtext is a super handy package for text manipulations\r\nin ggplots. Check out my previous\r\npost for more details if interested!\r\nOh, did you notice that the lower left corner of the Saturn image\r\ncovered the curve? How can we fix this? Easy-peasy: just move the image\r\nlayer to the very bottom! The function move_layers() in the\r\npackage gginnards will do the trick.\r\n\r\n\r\nlibrary(ggtext)\r\n\r\n### Add planet images to the figure\r\nP_solar_system <- P_solar_system + \r\n    geom_richtext(data = planetary_dat, aes(x = row_id, y = distance_from_the_sun_au,\r\n                                            label = image_tag),\r\n                  color = NA, fill = NA,\r\n                  nudge_x = c(0, 0, 0, 0, -0.3, -0.2, 0, 0),\r\n                  nudge_y = c(2.4, 1.7, 1.3, 1, 1.4, 1.1, 0.7, 0.6)) +\r\n    geom_richtext(aes(x = -1, y = 0, label = \"<img src='https://res.cloudinary.com/dtpgi0zck/image/upload/s--fMAvJ-9u--/c_fit,h_580,w_860/v1/EducationHub/photos/sun-blasts-a-m66-flare.jpg' width='70'/>\"), \r\n                  color = NA, fill = NA)\r\n\r\n### Move the layer \"GeomRichText\" to the bottom\r\nlibrary(gginnards)\r\n\r\nmap_chr(P_solar_system$layers, function(x){class(x$geom)[1]})  # get the layer names\r\n\r\n[1] \"GeomPointBlur\"       \"GeomPath\"            \"GeomPoint\"          \r\n[4] \"GeomPathInterpolate\" \"GeomRichText\"        \"GeomRichText\"       \r\n\r\nP_solar_system <- move_layers(P_solar_system, \"GeomRichText\", position = \"bottom\")    \r\nP_solar_system\r\n\r\n\r\n\r\nLeg 6. Add a title and\r\nplanet labels\r\nOur sixth leg is to add a title and planet labels to the figure.\r\nWe’ll use geom_text() to map the planet labels to the\r\ndesired positions, and again geom_richtext() to add a title\r\nusing the HTML syntax.\r\nYou might wonder why I padded the planet labels. Actually, when I\r\njust added the labels and set hjust = 1 to adjust their\r\npositions to the left of the vertical line, these labels were\r\nleft-shifted but right-aligned (which didn’t look so pleasant in my\r\nopinion; I wanted the labels to be centered!). This is mainly due to the\r\nfact that the labels are of different lengths. Therefore, I used this\r\npadding trick to make the labels extremely long and of similar lengths.\r\nIn this way, I don’t have to adjust the positions that much\r\n(hjust = 0.7 would be enough to shift the labels to the\r\nleft), and this will largely reduce the right-alignment problem.\r\nAfter some trial and error, the labels seemed to be fairly centered.\r\nSometimes it does take a while to experiment and fine-tune the values\r\nwhen you adjust the item positions (which could even a bit irritating!).\r\nBut isn’t this the most fun and fulfilling part of ggplots?!\r\n\r\n\r\nlibrary(ggtext)\r\n\r\n### Pad the planet labels\r\nplanetary_dat <- planetary_dat %>% \r\n  mutate(planet_pad = ifelse(nchar(planet)%%2 == 0, \r\n                             str_pad(planet, width = 50, side = \"both\"),\r\n                             str_pad(planet, width = 51, side = \"both\")))\r\n\r\n### Add a title to the figure\r\nP_solar_system <- P_solar_system + \r\n  geom_text(data = planetary_dat, aes(x = row_id, y = 0, color = row_id,\r\n                                          label = glue(\"{planet_pad}\")),\r\n            size = 2.5, fontface = \"bold\", hjust = 0.7) + \r\n  geom_richtext(data = planetary_dat, aes(x = 3.3, y = 18.2,\r\n                                          label = \"<b><span style = 'font-size:24pt'>A<\/span>n<span> <\/span><span style = 'font-size:24pt'>E<\/span>pic<span> <\/span><span style = 'font-size:24pt'>J<\/span>ourney<span> <\/span>through<span> <\/span>the<span> <\/span><span style = 'font-size:24pt'>G<\/span>lowing<span> <\/span><span style = 'font-size:24pt'>S<\/span>olar<span> <\/span><span style = 'font-size:24pt'>S<\/span>ystem<\/b><br>\"),\r\n                size = 4.5, \r\n                color = NA,\r\n                fill = NA,\r\n                text.color = \"#09bab7\",\r\n                family = \"Bookman\",\r\n                fontface = \"bold.italic\")\r\n\r\nP_solar_system\r\n\r\n\r\n\r\nLeg 7. Sprinkle some\r\nglittering stars\r\nWe’re almost done with our trip! The final leg is to embellish the\r\nfigure with some glittering stars. We’ll do this by first creating\r\nanother ggplot with random blurry points scattered across a transparent\r\nbackground, and then overlaying it on the original planet figure using\r\nthe functions in the package cowplot.\r\n\r\n\r\n### Stars of random positions and sizes\r\nset.seed(123)\r\nstars_df <- data.frame(x = runif(50),\r\n                       y = runif(50),\r\n                       size = runif(50))  \r\n\r\n### The ggplot for the stars\r\nP_stars <- ggplot() + \r\n  geom_point_blur(data = stars_df, aes(x = x, y = y, size = size,\r\n                                       blur_size = size), \r\n                  color = \"white\", alpha = 0.5, show.legend = F) + \r\n  scale_blur_size_continuous(range = c(0, 2)) +\r\n  scale_size_continuous(range = c(0, 0.35)) + \r\n  theme_void() + \r\n  theme(plot.background = element_rect(fill = \"transparent\", \r\n                                       color = \"transparent\"),\r\n        plot.margin = margin(0, 0, 0, 0))\r\n\r\n### Overlay the stars on the planet figure\r\nlibrary(cowplot)\r\n\r\nP_final <- ggdraw(P_solar_system) + \r\n  draw_plot(P_stars)  \r\n\r\nP_final\r\n\r\n\r\n\r\nWell done! We make it to the very end. This is absolutely an amazing\r\njourney. Unfortunately, our rocket is running out of fuel and so it’s\r\ntime to go back to Earth. Hope you enjoy this memorable trip and will\r\nsee you soon next time!\r\nSummary\r\nHope you learn something useful from this post and don’t forget to\r\nleave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-11-02-post-22-the-glowing-solar-system/../../homepage_images/Post22.png",
    "last_modified": "2022-11-07T22:39:47-05:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 1728
  },
  {
    "path": "posts/2022-10-22-post-21-useful-tips-for-mapping-color-and-fill-aesthetics-in-the-same-geom-layer/",
    "title": "Post #21. Useful tips for mapping color and fill aesthetic in the same geom layer",
    "description": "In this quick post, I will show you how to use color and fill aesthetic together in the same geom layer to achieve the desired outcome!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-10-22",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nBackground\r\nColor and fill aesthetic often come hand in hand in ggplots, and\r\nknowing how to use them together will be handy and save lots of your\r\ntime searching the internet. In this quick post, I will use a simple\r\nboxplot example to demonstrate their use.\r\nVarious mappings\r\nof color and fill aesthetics\r\nThe boxplot below shows the sepal length of the three species in the\r\niris dataset, with box lines colored by species:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(iris, aes(x = Species, y = Sepal.Length)) + \r\n  geom_boxplot(aes(color = Species)) +\r\n  scale_color_brewer(palette = \"Set1\") + \r\n  labs(x = \"Species\", y = \"Sepal length\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nSuppose that we want to fill the boxes by species too. We can do this\r\nby specifying fill = species in aes() and\r\nadding scale_fill_brewer(palette = \"Set1\"):\r\n\r\n\r\nggplot(iris, aes(x = Species, y = Sepal.Length)) + \r\n  geom_boxplot(aes(color = Species, fill = Species)) +\r\n  scale_color_brewer(palette = \"Set1\") + \r\n  scale_fill_brewer(palette = \"Set1\") +\r\n  labs(x = \"Species\", y = \"Sepal length\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nBut there is a shortcut for doing this: using the function\r\nafter_scale(). So this function will reuse the scale of a\r\nprevious aesthetic (in this case “color”) for another aesthetic (in this\r\ncase “fill”) so that the latter aesthetic will follow the scale of the\r\nprevious one (sounds a bit abstract? See the code and figure below!).\r\nAlso, with after_scale(), you don’t need to add\r\nscale_fill_brewer(palette = \"Set1\") as what we did in the\r\nprevious figure.\r\n\r\n\r\nggplot(iris, aes(x = Species, y = Sepal.Length)) + \r\n  geom_boxplot(aes(color = Species, fill = after_scale(color))) + # use \"after_scale()\" to reuse the scale of color aesthetic for the fill aesthetic\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Species\", y = \"Sepal length\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nNow, let’s say we want to change the transparency of the box lines.\r\nWe can do this by applying after_scale() to a second color\r\naesthetic to modify the scale of the first color aesthetic and change\r\nits transparency:\r\n\r\n\r\nggplot(iris, aes(x = Species, y = Sepal.Length)) + \r\n  geom_boxplot(aes(color = Species, fill = after_scale(color),\r\n                   color = after_scale(alpha(color, 0.1)))) +  # use \"after_scale()\" to modify the scale of first color aesthetic\r\n  scale_color_brewer(palette = \"Set1\") + \r\n  labs(x = \"Species\", y = \"Sepal length\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nLikewise, we can apply the same method to the fill aesthetic to\r\nchange the transparency of the boxes:\r\n\r\n\r\nggplot(iris, aes(x = Species, y = Sepal.Length)) + \r\n  geom_boxplot(aes(color = Species, fill = after_scale(alpha(color, 0.1)))) +  # use \"after_scale()\" to reuse and modify the scale of color aesthetic for the fill aesthetic\r\n  scale_color_brewer(palette = \"Set1\") + \r\n  labs(x = \"Species\", y = \"Sepal length\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nNote that you can also change the transparency of the boxes by\r\ndirectly specifying the “alpha” argument outside aes(). But\r\ndid you notice the subtle difference from the previous figure? There you\r\ngo: The outlier point in the bottom right corner has become partially\r\ntransparent now!\r\n\r\n\r\nggplot(iris, aes(x = Species, y = Sepal.Length)) + \r\n  geom_boxplot(aes(color = Species, fill = after_scale(color)), alpha = 0.1) +\r\n  scale_color_brewer(palette = \"Set1\") + \r\n  labs(x = \"Species\", y = \"Sepal length\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nSummary\r\nTo recap, we learned how to use the function\r\nafter_scale() to tweak the color and fill aesthetic in the\r\nsame geom layer. As its name suggests, this function reuses the scale of\r\nan aesthetic for another aesthetic after the mapping of the first\r\naesthetic, or modifies the scale of an aesthetic after the first mapping\r\nof that aesthetic.\r\nHope you learn something useful from this post and don’t forget to\r\nleave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-10-22-post-21-useful-tips-for-mapping-color-and-fill-aesthetics-in-the-same-geom-layer/../../homepage_images/Post21.png",
    "last_modified": "2022-10-25T03:36:49-04:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 768
  },
  {
    "path": "posts/2022-10-01-post-20-ggplot-legend-tips-series-no7-working-on-legends-with-theme/",
    "title": "Post #20. ggplot Legend Tips Series No.7: Working on legends with theme()",
    "description": "In this post, you will learn how to modify the appearance of ggplot legends using the arguments in `theme()`.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-10-04",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nIntroduction\r\nThere are three main legend-related function groups in ggplots:\r\nguides(), scale_XX family of functions, and\r\ntheme(). In my previous posts, I showed how we can modify\r\ndiscrete and continuous legends using the first two function groups\r\n(check theme out here! Post\r\n#10, Post\r\n#11, Post\r\n#16, and Post\r\n#17). In this post, I will continue to introduce to you the third\r\nfunction “theme()”. I’ll also wrap up this topic by\r\nsummarizing the features of these three function groups and discuss\r\ntheir usages. After this journey, I believe you will be able to make the\r\nmost of these functions to achieve your ggplot goals!\r\nThe theme() function\r\ntheme() is one of the key components of ggplots and\r\ncontrols various aspects of the plot appearance: plot title, panel\r\nbackground, axis labels, grid lines, facet strips, and of course\r\nlegends. There are quite a few legend-related arguments in\r\ntheme(). To make life easier, I classify them into four\r\nmain categories based on which parts of the legends they focus on:\r\n (1)\r\nArguments for legend box  (2)\r\nArguments for legend keys  (3)\r\nArguments for legend title and labels  (4)\r\nArguments for legend layout\r\nLet’s kick things off by creating an example plot with two legends,\r\none discrete and one continuous, using the CO2\r\ndata set:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nP <- ggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, fill = uptake), position = position_jitter(width = 0.05), shape = 21, size = 2, color = \"transparent\") + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\") + \r\n  scale_fill_viridis_c(name = expression(paste(CO[2], \" uptake rate\")))\r\n\r\nP\r\n\r\n\r\n\r\n(1) Arguments for legend box\r\nThese arguments control the appearance and margin of entire legend\r\narea as well as individual legend boxes, the arrangement of multiple\r\nlegends, and the spacing between panel area and legend area:\r\n\r\n\r\nP + theme(# the appearance of entire legend area\r\n          legend.box.background = element_rect(fill = \"green1\",\r\n                                               color = \"black\",\r\n                                               size = 1,\r\n                                               linetype = \"dashed\"),\r\n          \r\n          # the margin of entire legend area\r\n          legend.box.margin = margin(t = 50, r = 10, b = 50, l = 10),\r\n          \r\n          # the appearance of individual legend boxes\r\n          legend.background = element_rect(fill = \"grey90\",\r\n                                           color = \"black\",\r\n                                           size = 0.5,\r\n                                           linetype = \"dotted\"),\r\n          \r\n          # the margin of individual legend boxes\r\n          legend.margin = margin(t = 5, r = 15, b = 5, l = 15),\r\n          \r\n          # the arrangement of the legends\r\n          legend.box = \"horizontal\",\r\n          legend.box.just = \"right\",\r\n          \r\n          # the spacing between panel area and legend area\r\n          legend.box.spacing = unit(0, \"inch\"))\r\n\r\n\r\n\r\nDid you notice that both legends were modified in the same manner?\r\nThis is an important feature of theme(): it changes\r\neverything in the plot (i.e., global effect)! So if you want to\r\nmodify just a certain legend, or modify the legends differently (i.e.,\r\nlocal effect), you should use guides() instead and specify\r\na specific legend (e.g., the legend for “color” aesthetics) to\r\nmodify.\r\n(2) Arguments for legend keys\r\nThese arguments control the appearance and size (height and width) of\r\nlegend keys:\r\n\r\n\r\nP + theme(# the appearance of legend keys\r\n          legend.key = element_rect(fill = \"orange\",\r\n                                    color = \"black\",\r\n                                    size = 0.5,\r\n                                    linetype = \"solid\"),\r\n          \r\n          # the height of legend keys\r\n          legend.key.height = unit(0.3, \"inch\"),\r\n          \r\n          # the width of legend keys\r\n          legend.key.width = unit(0.6, \"inch\"))\r\n\r\n\r\n\r\n(3) Arguments for legend\r\ntitle and labels\r\nThese arguments control the appearance and alignment of legend title\r\nand labels, the spacing between legend keys and labels, and the spacing\r\nbetween legend title and keys/labels:\r\n\r\n\r\nP + theme(# the appearance of legend title\r\n          legend.title = element_text(size = 15,\r\n                                      margin = margin(l = -10)),\r\n          \r\n          # the alignment of legend title\r\n          legend.title.align = 0.5,\r\n          \r\n          # the appearance of legend labels\r\n          legend.text = element_text(color = \"red\", \r\n                                     face = \"bold\",\r\n                                     angle = 45),\r\n          \r\n          # the alignment of legend labels\r\n          legend.text.align = 0.5,\r\n          \r\n          # the spacing between legend keys and labels\r\n          legend.spacing.x = unit(0.5, \"inch\"),\r\n          \r\n          # the spacing between legend title and keys/labels\r\n          legend.spacing.y = unit(0.2, \"inch\"))\r\n\r\n\r\n\r\nIn the above figure, I centered the long title “CO2 uptake\r\nrate” by specifying a negative left margin, which pulled the title to\r\nthe left. Check out my very\r\nfirst post on this trick if interested!\r\n(4) Arguments for legend\r\nlayout\r\nThese arguments control the position of legend area and the direction\r\nof legend items:\r\n\r\n\r\nP + theme(# the position of legend area\r\n          legend.position = \"top\",  # can pass a vector c(x, y) as well\r\n          \r\n          # the direction of legend items\r\n          legend.direction = \"horizontal\")\r\n\r\n\r\n\r\nFor the argument legend.position, besides the built-in\r\npositions (“top”, “right”, “bottom”, “left”), you can also place the\r\nlegend(s) inside the plot by passing a vector of length two\r\nc(x, y) (between 0 and 1) as the x- and y-coordinate\r\nrelative to the plot area. For instance,\r\nlegend.position = c(0.5, 0.5) will place the legend(s) in\r\nthe middle of the plot.\r\nComparisons of the\r\nthree function groups\r\nHere is a summary table of the key features of the three\r\nlegend-related function groups:\r\n\r\n\r\n\r\n\r\nguides()\r\n\r\n\r\nscale_XX functions\r\n\r\n\r\ntheme()\r\n\r\n\r\nGeneral appearance of legends\r\n\r\n\r\nX\r\n\r\n\r\n\r\n\r\nX\r\n\r\n\r\nArrangement/layout of legends\r\n\r\n\r\nX\r\n\r\n\r\n\r\n\r\nX\r\n\r\n\r\nScales (e.g., range) of legends\r\n\r\n\r\n\r\n\r\nX\r\n\r\n\r\n\r\n\r\nText of legend title/labels\r\n\r\n\r\n\r\n\r\nX\r\n\r\n\r\n\r\n\r\nOrder of legend keys\r\n\r\n\r\n\r\n\r\nX\r\n\r\n\r\n\r\n\r\nOverride default legend keys\r\n\r\n\r\nX\r\n\r\n\r\n\r\n\r\n\r\n\r\nEffect\r\n\r\n\r\nLocal\r\n\r\n\r\nLocal\r\n\r\n\r\nGlobal\r\n\r\n\r\n\r\nIn general, guides() and theme() resemble\r\neach other and both control the physical appearance of legends, whereas\r\nscale_XX functions control the scales (legend range, legend\r\ntick positions, etc.) and text (the words displayed in title and labels)\r\nof legends. Additionally, there are some specific legend modifications\r\nthat certain functions can make. For example, scale_XX\r\nfunctions can be used to reorder the legend items; guides()\r\ncan be used to overwrite the default aesthetic mappings of legend keys.\r\nFinally, these three functions differ in their effects:\r\ntheme() affects every legend in the plot, whereas\r\nguides() and scale_XX functions affect only\r\nthe specified legend(s).\r\nSummary\r\nIn this post, I showed how you can use various theme()\r\narguments to modify the appearance of ggplot legends: legend box, legend\r\nkeys, legend title and labels, and legend layout. I also summarized the\r\nfeatures of three legend-related function groups (guides(),\r\nscale_XX, and theme()) and offered some tips\r\nfor using them. Of course, having a combination of these functions is\r\nthe best way to achieve the desired outcome!\r\nHope you learn something useful from this post and don’t forget to\r\nleave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-10-01-post-20-ggplot-legend-tips-series-no7-working-on-legends-with-theme/../../homepage_images/Post20.png",
    "last_modified": "2022-10-05T03:40:51-04:00",
    "input_file": {},
    "preview_width": 1344,
    "preview_height": 768
  },
  {
    "path": "posts/2022-09-10-post-19-go-with-the-flow-alluvial-plots-with-ggplot/",
    "title": "Post #19. Go with the flow - alluvial diagrams in ggplot",
    "description": "Let's make flowy alluvial diagrams in ggplot using the extension package `ggalluvial`!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-09-10",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nIntroduction\r\nAlluvial\r\ndiagrams are a type of chart that shows the relationships between\r\ncategorical variables for a given quantity (number of people, amount of\r\nenergy, etc.) They look like a stacked barplot with flow streams\r\nconnecting the stacks of adjacent bars (that’s why it gets its name!).\r\nThese diagrams are useful for visualizing pathways and trends across\r\nvariables. Another similar chart is bump\r\ncharts, which emphasize the change in rankings of multiple objects\r\nover time.\r\nCreate alluvial\r\ndiagrams with ggalluvial\r\nWe’ll be using the extension package ggalluvial\r\nto create alluvial diagrams in ggplot. The functions in\r\nggalluvial can take data in both wide and long format, and\r\nwe’ll start with the wide format here.\r\nWorking with wide format\r\ndata\r\nFirst, let’s prepare our example data using the diamonds\r\ndataset: We’ll classify the carat of the diamonds into “Large” and\r\n“Small” as well as the price into “Low”, “Mid”, and “High”, and then\r\ntally the numbers of diamonds by carat, cut, and price.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Prepare wide format diamonds data\r\ndiamonds_wide <- diamonds %>% \r\n  mutate(price_cat = case_when(price < quantile(price, 0.33) ~ \"Low\",\r\n                               price > quantile(price, 0.67) ~ \"High\",\r\n                               TRUE ~ \"Mid\"),\r\n         price_cat = factor(price_cat, levels = c(\"High\", \"Mid\", \"Low\")),\r\n         carat_cat = ifelse(carat > median(carat), \"Large\", \"Small\"),\r\n         cut = fct_rev(cut)) %>% \r\n  group_by(carat_cat, cut, price_cat) %>%\r\n  summarise(count = n()) %>% \r\n  ungroup()\r\n\r\nhead(diamonds_wide)\r\n\r\n# A tibble: 6 × 4\r\n  carat_cat cut       price_cat count\r\n  <chr>     <ord>     <fct>     <int>\r\n1 Large     Ideal     High       5808\r\n2 Large     Ideal     Mid        2648\r\n3 Large     Premium   High       5649\r\n4 Large     Premium   Mid        2283\r\n5 Large     Premium   Low           2\r\n6 Large     Very Good High       4135\r\n\r\n\r\nNow having the appropriate data on hand, we can visualize the\r\nrelationships between carat, cut, and price in an alluvial diagram.\r\nThere are a few things worth noting in the below code chunk:\r\nThe flow\r\nstreams and bars are drawn using geom_alluvium() and\r\ngeom_stratum(), respectively\r\nThe bars are\r\npositioned along the horizontal axis using the arguments\r\naes(axis1 = carat_cat, axis2 = cut, axis3 = price_cat)\r\nThe function\r\ngeom_stratum() will create a new internal variable\r\n“stratum” that can be used to label the bars via the\r\nargument aes(label = after_stat(stratum))\r\nThe flow\r\nstreams are colored by price\r\n\r\n\r\n# install.packages(\"ggalluvial\")  # install the package if you haven't\r\nlibrary(ggalluvial)\r\nlibrary(scales)  # for the function \"comma_format()\"\r\n\r\nggplot(diamonds_wide, aes(axis1 = carat_cat, axis2 = cut, axis3 = price_cat, y = count)) +\r\n  geom_alluvium(aes(fill = price_cat), width = 1/5) +\r\n  geom_stratum(width = 1/5, fill = \"#fee6ce\", color = \"grey30\") +\r\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum)), size = 2.5) +\r\n  scale_x_discrete(limits = c(\"Carat\", \"Cut\", \"Price\"), expand = c(0, 0.2)) +\r\n  scale_y_continuous(expand = c(0, 0), labels = comma_format()) + \r\n  labs(y = \"Count\") + \r\n  scale_fill_brewer(name = \"Price\", palette = \"Set1\") + \r\n  theme_classic(base_size = 13) + \r\n  theme(axis.line.x = element_blank(),\r\n        axis.ticks.x = element_blank())\r\n\r\n\r\n\r\nIt seems that no large diamond has a low price and no small diamond\r\nhas a high price, regardless of the cut quality.\r\nFrom this plot, we can further produce the so-called “parallel\r\nsets” by adjusting the width of the bars, the knot position (the\r\ninflection point) of the flow streams, and the orientation of the\r\ndiagram:\r\n\r\n\r\nggplot(diamonds_wide, aes(axis1 = carat_cat, axis2 = cut, axis3 = price_cat, y = count)) +\r\n  geom_alluvium(aes(fill = price_cat), width = 0, knot.pos = 0, show.legend = F) +  # knot.pos = 0 generates straight flow streams\r\n  geom_stratum(width = 0.02, fill = \"black\", color = \"white\") +  # reduce the bar width to create thick lines\r\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum)), size = 2.5, nudge_x = 0.05) +\r\n  scale_x_discrete(limits = c(\"Carat\", \"Cut\", \"Price\"), expand = c(0, 0.1)) +\r\n  scale_y_continuous(expand = c(0, 0), labels = comma_format()) + \r\n  labs(y = \"Count\") + \r\n  scale_fill_brewer(palette = \"Set1\") + \r\n  coord_flip() +  # change the orientation of the diagram\r\n  theme_classic(base_size = 13) + \r\n  theme(axis.line.y = element_blank(),\r\n        axis.ticks.y = element_blank())\r\n\r\n\r\n\r\n\r\nWorking with long format\r\ndata\r\nAs mentioned earlier, ggalluvial also works with data in\r\nlong format. So let’s convert the data now. Note that we need to add an\r\nID column to the dataframe before melting it into long format. These\r\nID’s will tell the functions how to connect the flows between adjacent\r\nbars (each ID represents a flow stream across all the bars from left to\r\nright).\r\n\r\n\r\n# Convert the wide data into long format\r\ndiamonds_long <- diamonds_wide %>%\r\n  mutate(alluvium_ID = row_number()) %>%  # add an ID for each row\r\n  pivot_longer(cols = -c(count, alluvium_ID), names_to = \"variable\", values_to = \"level\") %>% \r\n  mutate(level = factor(level, levels = c(\"Large\", \"Small\", \"Ideal\", \"Premium\", \"Very Good\", \"Good\", \"Fair\", \"High\", \"Mid\", \"Low\")))  # adjust the level order for later plotting\r\n\r\nhead(diamonds_long)\r\n\r\n# A tibble: 6 × 4\r\n  count alluvium_ID variable  level\r\n  <int>       <int> <chr>     <fct>\r\n1  5808           1 carat_cat Large\r\n2  5808           1 cut       Ideal\r\n3  5808           1 price_cat High \r\n4  2648           2 carat_cat Large\r\n5  2648           2 cut       Ideal\r\n6  2648           2 price_cat Mid  \r\n\r\n\r\nGreat. It’s time to make the diagram! As the data are now in long\r\nformat, the argument specifications are a bit different from those we\r\nused for previous plots:\r\nThe flow\r\nstreams are drawn using geom_flow() instead of\r\ngeom_alluvium(), and the alluvium ID’s are specified via\r\nthe argument aes(alluvium = alluvium_ID)\r\nThe positions\r\nof the bars along the x-axis are specified via\r\naes(x = variable), and the stacks of the bars are specified\r\nvia aes(stratum = level)\r\nThe bars are\r\nlabeled directly via the argument aes(label = ) without\r\nhaving to call after_stat()\r\n\r\n\r\n# Create a color palette for the bars\r\ncolor_pal <- set_names(c(\"#bdbdbd\", \"#525252\", \"#fde725\", \"#7ad151\", \"#22a884\", \"#2a788e\", \"#414487\", \"#e41a1c\", \"#377eb8\", \"#4daf4a\"), nm = levels(diamonds_long$level))\r\n\r\nggplot(diamonds_long, aes(x = variable, y = count, stratum = level, alluvium = alluvium_ID)) +\r\n  geom_flow(aes(fill = level), width = 1/5) +\r\n  geom_stratum(aes(fill = level), alpha = 0.75, width = 1/5) +\r\n  geom_text(stat = \"stratum\", aes(label = level), size = 3) +\r\n  scale_x_discrete(labels = c(\"Carat\", \"Cut\", \"Price\"), expand = c(0, 0.2)) +\r\n  scale_y_continuous(expand = c(0, 0), labels = comma_format()) + \r\n  labs(x = \"\", y = \"Count\") +\r\n  guides(fill = \"none\") + \r\n  scale_fill_manual(values = color_pal) +\r\n  theme_classic(base_size = 13) + \r\n  theme(axis.line.x = element_blank(),\r\n        axis.ticks.x = element_blank())\r\n\r\n\r\n\r\nDo you notice the difference from the previous alluvial diagrams\r\ncreated with wide format data? You’re right! The bars and flows have\r\ntheir own colors now! With this method, we are able to color the bars\r\nand the flows between adjacent bars by their corresponding levels (the\r\nflow color will be the same as that of the bar stack where the flow\r\noriginates).\r\nSummary\r\nTo recap what we’ve done in this post, we started by creating a\r\nstandard alluvial diagram with wide format diamonds data\r\nusing the package ggalluvial. We then modified the diagram\r\nto produce parallel sets. Finally, we converted the data into long\r\nformat and created another alluvial diagram that had different bar and\r\nflow colors.\r\nAs mentioned in the beginning, alluvial diagrams are best for\r\nvisualizing the relationships between categorical variables. And if the\r\nbars along the axis are ordered by time, distance, or some kind of\r\nfactor gradients, then they can help reveal trends.\r\nHope you learn something useful from this post and don’t forget to\r\nleave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-09-10-post-19-go-with-the-flow-alluvial-plots-with-ggplot/../../homepage_images/Post19.png",
    "last_modified": "2022-10-04T04:58:59-04:00",
    "input_file": {},
    "preview_width": 1536,
    "preview_height": 864
  },
  {
    "path": "posts/2022-08-01-post-18-bump-charts-with-ggplot/",
    "title": "Post #18. Bump charts with ggplot",
    "description": "Come and learn how to create nice bump charts with ggplot!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-08-01",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nIntroduction\r\nBump charts are a special type of line charts that visualize the\r\nrankings of multiple objects over time. These charts are especially\r\nuseful for comparing and highlighting trends. Honestly, I haven’t really\r\nheard of this kind of charts before until recently I came across a Tweet\r\nabout creating bump charts using ggplot. I then took a deeper dive into\r\nit and felt that this would certainly make an interesting blog topic.\r\nAlso, I believe the charts will come in handy someday in the future,\r\nboth for myself and for the readers like you!\r\nSo without further ado, let’s jump right in!\r\nPrepare the data\r\nAs mentioned earlier, bump charts are useful for visualizing rankings\r\nof items over time. Instead of using a built-in R dataset, this time\r\nI’ll prepare my own one, which focuses on the rankings of five\r\necological journals (Journal of\r\nEcology, Journal of Animal\r\nEcology, Journal of Applied\r\nEcology, Functional\r\nEcology, and Methods in\r\nEcology and Evolution) from the British\r\nEcological Society. Specifically, I would like to see how the\r\nrankings of these five journals, in terms of their impact factors (IFs),\r\nchange over the past decade.\r\nTo get the data, I visited Journal\r\nCitation Reports website and downloaded the journals’ IF\r\nrecords.\r\nLet’s read in the datasets and do some data wrangling:\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(janitor)  # for the function \"row_to_names()\"\r\n\r\n# Create a list of url paths\r\nBES_journals <- c(\"J_ECOL\", \"J_ANIM_ECOL\", \"J_APPL_ECOL\", \"FUNCT_ECOL\", \"METHODS_ECOL_EVOL\")\r\ndataset_urls <- str_glue(\"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2022-08-01-post-18-bump-charts-with-ggplot/BES_journals_data/{BES_journals}.csv\")\r\n\r\n# Loop through the url paths\r\nBES_journals_data <- map(dataset_urls, function(x){\r\n  read_csv(x) %>% \r\n    row_to_names(row_number = 5) %>%  # set the fifth row as column names\r\n    slice_head(n = nrow(.)-4)  # remove the last four rows\r\n  }) %>%\r\n  `names<-`(BES_journals) %>%\r\n  bind_rows(.id = \"Journal\") %>%  # convert the list to a dataframe\r\n  select(Journal, Year, IF = `Journal impact factor`) %>% \r\n  filter(Year >= 2011) %>%  # retain data starting from 2011\r\n  group_by(Year) %>% \r\n  mutate(IF = as.numeric(IF),\r\n         Ranking = row_number(desc(IF))) %>%  # add the journal rankings by year\r\n  arrange(Year, Journal)\r\n\r\nlibrary(DT)  # for the function \"datatable()\"\r\ndatatable(BES_journals_data, options = list(pageLength = 5))\r\n\r\n\r\n\r\nBasic bump chart\r\nNow we have our data on hand, it’s time for the chart!\r\nCreating a basic bump chart is as simple as making a scatterplot (or\r\ndotplot) of time vs. rankings and “connecting the dots” with lines,\r\nwhich can be done with geom_line() and\r\ngeom_point(). Also, we can use\r\nscale_y_reverse() to flip the y-axis so that the\r\nhighest-ranking item stays on the top of the plot.\r\n\r\n\r\n# A color palette for the journals\r\ncol_pal <- set_names(c(\"#0e96d4\", \"#7581bd\", \"#48a749\", \"#e38d26\", \"#de2127\"), nm = BES_journals)\r\n\r\n# The basic bump chart\r\nggplot(BES_journals_data) + \r\n  geom_line(aes(x = Year, y = Ranking, color = Journal, group = Journal), size = 2) + \r\n  geom_point(aes(x = Year, y = Ranking, color = Journal), shape = 21, fill = \"white\", size = 4, stroke = 2) +\r\n  scale_y_reverse() +  # the highest-ranking journal is on the top\r\n  scale_color_manual(values = col_pal) +  # use the customized color palette\r\n  theme_classic()\r\n\r\n\r\n\r\nSeems that Methods in Ecology and\r\nEvolution has been the leading journal of the five in recent\r\nyears!\r\nThis figure looks fine, but we can make it shine. Let’s spice it\r\nup!\r\nThere are a few things we can do to modify the chart:\r\n (1)\r\nAdd a title, a subtitle, and a caption  (2) Remove\r\nthe legend and annotate the items directly in the plot panel\r\n (3)\r\nChange the background color\r\n\r\n\r\n# install.packages(\"ggtext\")  # install the package if you haven't\r\nlibrary(ggtext)  # for the function \"element_markdown()\"\r\n\r\n# A color palette for the journals\r\ncol_pal <- set_names(c(\"#0e96d4\", \"#7581bd\", \"#48a749\", \"#e38d26\", \"#de2127\"), nm = BES_journals)\r\n\r\n# The journal labels on the left\r\nJournal_label <- c(\"<span style = 'color: #de2127'>Methods in<br>Ecology and Evolution<\/span>\",\r\n                   \"<span style = 'color: #48a749'>Journal of<br>Applied Ecology\",\r\n                   \"<span style = 'color: #0e96d4'>Journal of Ecology<\/span>\",\r\n                   \"<span style = 'color: #7581bd'>Journal of<br>Animal Ecology<\/span>\",\r\n                   \"<span style = 'color: #e38d26'>Functional Ecology<\/span>\")\r\n\r\n# The fancy bump chart\r\nggplot(BES_journals_data) + \r\n  geom_line(aes(x = Year, y = Ranking, color = Journal, group = Journal), size = 2) + \r\n  geom_point(aes(x = Year, y = Ranking, color = Journal), shape = 21, fill = \"white\", size = 4, stroke = 2) +\r\n  geom_text(data = data.frame(x = 11.5, y = 1:5), aes(x = x, y = y, label = y)) +\r\n  scale_y_reverse(labels = Journal_label) +  # add the journal labels\r\n  scale_color_manual(values = col_pal) + \r\n  labs(title = \"<img src='https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2022-08-01-post-18-bump-charts-with-ggplot/BES_logo_tp.png' width = '100'/>\",  # add the BES logo\r\n       subtitle = \"Journal rankings based on their impact factors each year\",\r\n       caption = \"Data source: Journal Citation Reports\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\",\r\n        plot.margin = margin(5, 5, 5, 5),\r\n        plot.background = element_rect(fill = \"#b6e3d4\", color = NA),\r\n        plot.title = element_markdown(margin = margin(b = 0, unit = \"mm\"), hjust = -0.1),\r\n        plot.subtitle = element_text(margin = margin(t = -10, b = 10, unit = \"mm\"), hjust = 0.35, face = \"bold\", size = 13),\r\n        plot.caption = element_text(margin = margin(t = 5, unit = \"mm\"), face = \"italic\", color = \"grey60\"),\r\n        axis.text.x = element_text(margin = margin(t = 3, unit = \"mm\"), size = 10),\r\n        axis.text.y = element_markdown(margin = margin(r = -5, unit = \"mm\"), color = NULL, size = 11))\r\n\r\n\r\n\r\n\r\n\r\n\r\nHere I used the function element_markdown() from the\r\npackage ggtext\r\nto embed a logo in the plot title via the HTML <img>\r\ntag and to label the journals via the HTML <span>\r\ntag. The package has many nice features for text manipulations in\r\nggplots using HTML and CSS syntax. I won’t go into the details here, but\r\ndo check out my previous post\r\non this topic if interested!\r\nA modified bump chart\r\nwith smooth curves\r\nInstead of connecting the dots with straight line segments like what\r\nwe did in the above figure, we can use smooth curves. This is actually\r\nsuper easy: just replace geom_line() with\r\ngeom_bump()!\r\n\r\n\r\n# install.packages(\"ggbump\")  # install the package if you haven't\r\nlibrary(ggbump)\r\nlibrary(ggtext)\r\n\r\ncol_pal <- set_names(c(\"#0e96d4\", \"#7581bd\", \"#48a749\", \"#e38d26\", \"#de2127\"), nm = BES_journals)\r\n\r\nJournal_label <- c(\"<span style = 'color: #de2127'>Methods in<br>Ecology and Evolution<\/span>\",\r\n                   \"<span style = 'color: #48a749'>Journal of<br>Applied Ecology\",\r\n                   \"<span style = 'color: #0e96d4'>Journal of Ecology<\/span>\",\r\n                   \"<span style = 'color: #7581bd'>Journal of<br>Animal Ecology<\/span>\",\r\n                   \"<span style = 'color: #e38d26'>Functional Ecology<\/span>\")\r\n\r\n# The modified bump chart using \"geom_bump()\"\r\nggplot(BES_journals_data) + \r\n  geom_bump(aes(x = Year, y = Ranking, color = Journal, group = Journal), size = 2) + \r\n  geom_point(aes(x = Year, y = Ranking, color = Journal), shape = 21, fill = \"white\", size = 4, stroke = 2) +\r\n  geom_text(data = data.frame(x = 11.5, y = 1:5), aes(x = x, y = y, label = y)) +\r\n  scale_y_reverse(labels = Journal_label) +\r\n  scale_color_manual(values = col_pal) +\r\n  labs(title = \"<img src='https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2022-08-01-post-18-bump-charts-with-ggplot/BES_logo_tp.png' width = '100'/>\",\r\n       subtitle = \"Journal rankings based on their impact factors each year\",\r\n       caption = \"Data source: Journal Citation Reports\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\",\r\n        plot.margin = margin(5, 5, 5, 5),\r\n        plot.background = element_rect(fill = \"#b6e3d4\", color = NA),\r\n        plot.title = element_markdown(margin = margin(b = 0, unit = \"mm\"), hjust = -0.1),\r\n        plot.subtitle = element_text(margin = margin(t = -10, b = 10, unit = \"mm\"), hjust = 0.35, face = \"bold\", size = 13),\r\n        plot.caption = element_text(margin = margin(t = 5, unit = \"mm\"), face = \"italic\", color = \"grey60\"),\r\n        axis.text.x = element_text(margin = margin(t = 3, unit = \"mm\"), size = 10),\r\n        axis.text.y = element_markdown(margin = margin(r = -5, unit = \"mm\"), color = NULL, size = 11))\r\n\r\n\r\n\r\n\r\n\r\n\r\nLooks pretty cool (a bit like subway maps)!\r\nAdvanced topic - Ribbon bump\r\nchart\r\nFor the purpose of science communication, the bump charts we’ve\r\ncreated above are pretty much enough. But as a ggplot geek, it’s always\r\nfun to challenge myself a bit and go a step further to try out something\r\ncool. This is the motive for this advanced topic! Also, a shout-out to\r\nthe author of the Tweet\r\nI mentioned at the beginning of the post. The idea was largely inspired\r\nby the chart he made and much of the code below is modified from his\r\nGitHub repository.\r\nCreating a ribbon bump chart is not an easy task and requires some\r\ndata manipulations. I’ll break down the process into four steps and\r\nexplain what I’m doing in each step. I think this would make it easier\r\nto understand the underlying principles and hopefully you’ll be able to\r\nbuild your own chart in the future.\r\nSo the four steps are:  (1) Create a\r\nstacked barplot of journals’ impact factors over year  (2) Compute\r\nthe curves that connect the upper/lower ends of the bars for each\r\njournal  (3) Add\r\nribbons to the stacked barplot  (4) Polish\r\nthe appearance of the chart\r\nLet’s kick off our plotting journey. Enjoy!\r\nStep\r\n1. Create a stacked barplot of journals’ impact factors over year\r\nTo create a stacked barplot of the journals’ IFs, we need to\r\ndetermine the upper and lower ends of the bars. We’ll do this by first\r\narranging the journals in a descending order based on their rankings\r\neach year (so the lowest-ranking journal will be on the top of the\r\ndataframe) and then calculating the cumulative sums of the journals’\r\nIFs, which will be the upper ends of the bars. For the lower ends,\r\nthey’ll be the cumulative sums minus the journals’ own IFs.\r\nIt’s noteworthy that here we won’t use the conventional geom layer\r\ngeom_bar() to create the barplot, but\r\ngeom_rect() instead. The main reason for using\r\ngeom_rect() rather than geom_bar() is that\r\ngeom_rect() allows us to order the bars differently for\r\neach year, whereas geom_bar() will place the bars in the\r\nsame order across years. Since the journal rankings varied across years,\r\nwe should use the former.\r\n\r\n\r\n# Calculate the cumulative sums of the journals' IFs \r\nBES_journals_data_bars <- BES_journals_data %>% \r\n  arrange(Year, desc(Ranking)) %>% \r\n  group_by(Year) %>% \r\n  mutate(y_upper = cumsum(IF),\r\n         y_lower = cumsum(IF) - IF) %>% \r\n  ungroup()\r\n\r\n# A color palette for the journals\r\ncol_pal <- set_names(c(\"#0e96d4\", \"#7581bd\", \"#48a749\", \"#e38d26\", \"#de2127\"), nm = BES_journals)\r\n\r\n# Create a stacked barplot of the journals' IFs each year\r\nribbon_bumpchart_bars <- ggplot(BES_journals_data_bars) + \r\n  geom_rect(aes(xmin = as.numeric(Year) - 0.05, xmax = as.numeric(Year) + 0.05,\r\n                ymin = y_lower, ymax = y_upper, fill = Journal), color = \"white\") +\r\n  scale_fill_manual(values = col_pal) +\r\n  theme_classic()\r\n\r\nribbon_bumpchart_bars\r\n\r\n\r\n\r\nStep\r\n2. Compute the curves that connect the upper/lower ends of the bars for\r\neach journal\r\nNow comes the core part of the process: computing the curves that\r\nconnect the upper/lower ends of the bars for each journal. These\r\nupper/lower curves form the boundaries of the ribbons that we’ll be\r\nadding to the plot later. We’ll split the original dataframe into\r\nindividual subsets by journal and do the computation separately for each\r\nof them.\r\nFirst, for each subset, we’ll create four new columns:\r\nx_from, x_to, y_from,\r\nand y_to. x_from is the current year\r\nplus the bar width (which is 0.05); x_to is the next\r\nyear minus bar width; y_from is the upper/lower ends of\r\nthe bars in the current year; y_to is the upper/lower\r\nends of the bars next year. Together, these four columns serve as the x-\r\nand y-coordinates of the two points (x_from,\r\ny_from) and (x_to,\r\ny_to), between which a smooth connecting curve will be\r\nderived.\r\nNote that in the below code chunk, the y_to for the\r\nyear 2022 was set to NA because there is no next bar to go,\r\nand the row for that year was later removed. Also, I subtracted 0.1 from\r\nthe upper end and added 0.1 to the lower end to create a margin between\r\nribbons so that the ribbons will not go shoulder to shoulder when we\r\nplot them later.\r\nNext, we’ll use the function sigmoid() from the package\r\nggbump to compute a smooth sigmoid curve between the two\r\npoints (x_from, y_from) and\r\n(x_to, y_to). The smoothness of the\r\ncurve can be adjusted via the arguments n and\r\nsmooth (play around with different values to see how the\r\nribbons change!).\r\nFinally, we’ll merge the results (the x- and y-coordinates of the\r\npoints forming the smooth curves) of each subset into a single\r\ndataframe, which contains all the information we need for plotting the\r\nribbons.\r\n\r\n\r\nlibrary(ggbump)  # for the function \"sigmoid()\"\r\n\r\n# Compute the upper/lower curves connecting the bars\r\nBES_journals_data_ribbons <- BES_journals_data_bars %>% \r\n  split(., .$Journal) %>% \r\n  map(., function(data){\r\n    \r\n    # the upper curve\r\n    upper_curve <- data %>% \r\n      select(Journal, Year, y_upper) %>% \r\n      mutate(x_from = as.numeric(Year) + 0.05,\r\n             x_to = as.numeric(Year) + 1 - 0.05,\r\n             y_from = y_upper - 0.1,  # 0.1 sets the margin between adjacent ribbons\r\n             y_to = c(y_upper[-1], NA) - 0.1) %>% \r\n      filter(Year != \"2021\") %>% \r\n      rowwise() %>% \r\n      mutate(curve = list(sigmoid(x_from, x_to, y_from, y_to, n = 100, smooth = 8))) %>% \r\n      unnest() %>% \r\n      select(Journal, x, y_upper = y)\r\n    \r\n    # the lower curve    \r\n    lower_curve <- data %>%\r\n      select(Journal, Year, y_lower) %>% \r\n      mutate(x_from = as.numeric(Year) + 0.05,\r\n             x_to = as.numeric(Year) + 1 - 0.05,\r\n             y_from = y_lower + 0.1,\r\n             y_to = c(y_lower[-1], NA) + 0.1) %>% \r\n      filter(Year != \"2021\") %>% \r\n      rowwise() %>% \r\n      mutate(curve = list(sigmoid(x_from, x_to, y_from, y_to, n = 100, smooth = 8))) %>% \r\n      unnest() %>% \r\n      select(Journal, x, y_lower = y)\r\n    \r\n    # put the two dataframes together\r\n    curve <- left_join(upper_curve, lower_curve[, -1], by = \"x\")\r\n  }) %>% bind_rows()  # merge the results\r\n\r\ndatatable(BES_journals_data_ribbons, options = list(pageLength = 5))\r\n\r\n\r\n\r\nStep 3. Add ribbons\r\nto the stacked barplot\r\nReady to draw the ribbons! We’ll use geom_ribbon() and\r\nspecify the upper (ymax =) and lower (y_min =)\r\nboundary. The ribbons were adjusted to be slightly transparent so that\r\nwhen two ribbons cross each other, the one beneath can still be\r\nseen.\r\nWe’ll also use the function move_layers() from the\r\npackage gginnards to pull the bars (which were drawn on the\r\ngeom_rect() layer) to the top. Otherwise, the bars will be\r\ncompletely covered by the ribbons!\r\n\r\n\r\n# Add the ribbons to the barplot \r\nribbon_bumpchart <- ribbon_bumpchart_bars + \r\n  geom_ribbon(data = BES_journals_data_ribbons, \r\n              aes(x = x, ymax = y_upper, ymin = y_lower, fill = Journal), alpha = 0.75)\r\n\r\n# Move the bars to the top  \r\nlibrary(gginnards)\r\n\r\nribbon_bumpchart <- move_layers(ribbon_bumpchart, \"GeomRect\", position = \"top\")\r\nribbon_bumpchart\r\n\r\n\r\n\r\nStep 4. Polish the\r\nappearance of the chart\r\nHere we are at our final step: polishing the appearance of the chart!\r\nAgain, we’ll add a logo title, a subtitle, and a caption to it. We’ll\r\nalso label the years along the x-axis as well as the journal names on\r\nthe left of the ribbons.\r\n\r\n\r\n# Journal labels\r\nJournal_label <- c(\"<span style = 'color: #de2127'>Methods in<br>Ecology and Evolution<\/span>\",\r\n                   \"<span style = 'color: #48a749'>Journal of<br>Applied Ecology\",\r\n                   \"<span style = 'color: #0e96d4'>Journal of Ecology<\/span>\",\r\n                   \"<span style = 'color: #7581bd'>Journal of<br>Animal Ecology<\/span>\",\r\n                   \"<span style = 'color: #e38d26'>Functional Ecology<\/span>\")\r\n\r\n# Journal label positions\r\nJournal_label_position <- filter(BES_journals_data_bars, Year == 2011)$y_upper - filter(BES_journals_data_bars, Year == 2011)$IF/2\r\n\r\n# Modify the appearance of the chart\r\nribbon_bumpchart <- ribbon_bumpchart +\r\n  scale_x_continuous(breaks = c(2011:2021)) + \r\n  scale_y_continuous(breaks = Journal_label_position, labels = rev(Journal_label)) +\r\n  labs(title = \"<img src='https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2022-08-01-post-18-bump-charts-with-ggplot/BES_logo_tp.png' width = '100'/>\",\r\n       subtitle = \"Journal rankings based on their impact factors each year\",\r\n       caption = \"Data source: Journal Citation Reports\") +\r\n  theme_void() +\r\n  theme(legend.position = \"none\",\r\n        plot.margin = margin(5, 5, 5, 5),\r\n        plot.background = element_rect(fill = \"#b6e3d4\", color = NA),\r\n        plot.title = element_markdown(margin = margin(b = -5, unit = \"mm\"), hjust = -0.1),\r\n        plot.subtitle = element_text(margin = margin(t = -5, b = -10, unit = \"mm\"), hjust = 0.35, face = \"bold\", size = 13),\r\n        plot.caption = element_text(margin = margin(t = 5, unit = \"mm\"), face = \"italic\", color = \"grey60\"),\r\n        axis.text.x = element_text(margin = margin(t = 1, unit = \"mm\"), size = 10),\r\n        axis.text.y = element_markdown(margin = margin(r = -5, unit = \"mm\"), color = NULL, size = 11))\r\n\r\nribbon_bumpchart\r\n\r\n\r\n\r\n\r\n\r\n\r\nAfter a long trek through the code, we’ve now reached the destination\r\nof our plotting journey. Hooray!\r\nSummary\r\nTo recap what we did in this post, we first created a basic bump\r\ncharts from scratch using geom_line() and\r\ngeom_point(). Next, we used geom_bump() to\r\ncreate a modified bump chart with smooth curves connecting the points.\r\nLastly, we went on an adventure and created a ribbon bump chart step by\r\nstep, including some data manipulations to get the data we need for\r\nplotting. After doing this post, I found bump charts quite handy and I\r\nthink I should use them more often for communication. I believe you\r\nthink so too!\r\nHope you learn something useful from this post and don’t forget to\r\nleave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-08-01-post-18-bump-charts-with-ggplot/../../homepage_images/Post18.png",
    "last_modified": "2022-08-11T03:05:12-04:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 960
  },
  {
    "path": "posts/2022-07-02-post-17-ggplot-legend-tips-series-no6-working-on-continuous-legends-with-scalexx-functions/",
    "title": "Post #17. ggplot Legend Tips Series No.6: Working on continuous legends with scale_XX functions",
    "description": "In this post, you will learn how to modify the appearance of continuous legends in ggplots using `scale_XX` family of functions.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-07-03",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nBackground\r\nThis is the part II of the previous\r\npost where I introduced how one can adjust the discrete legends in\r\nggplots using the scale_XX family of functions. In this\r\npost, I’m going to talk about adjusting continuous legends, again using\r\nthe scale_XX functions.\r\nAn example with\r\nscale_fill_gradient()\r\nLet’s start with an example plot of eruption time vs. waiting time of\r\nthe old faithful geyser using the faithful\r\ndataset. In the below code chunk, the function geom_hex()\r\ndivides the plot panel into a grid of hexagons, counts the number of\r\noriginal data points in each hexagon, and maps the counts to the “fill”\r\naesthetic. This is a useful way to avoid overlapping points (i.e.,\r\noverplotting), especially when the dataset is huge.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(faithful, aes(x = eruptions, y = waiting)) + \r\n  geom_hex(aes(fill = ..count..)) +  # hexagon bins \r\n  labs(x = \"Eruption time (min)\", y = \"Waiting time (min)\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nNow we can try to adjust the legend bar using the arguments in\r\nscale_fill_gradient(). Three main things to change are:\r\n (1)\r\nLegend range, controlled by the argument limits\r\n (2)\r\nLegend tick positions, controlled by the argument breaks\r\n  (3) Legend\r\ntick labels, controlled by the argument labels \r\n\r\n\r\nggplot(faithful, aes(x = eruptions, y = waiting)) + \r\n  geom_hex(aes(fill = ..count..)) +\r\n  scale_fill_gradient(name = \"Number of \\n eruptions\",\r\n                      limits = c(0, 6),  # legend range\r\n                      breaks = c(1, 2, 3, 4, 5),  # legend tick positions\r\n                      labels = format(c(1, 2, 3, 4, 5), nsmall = 1)) +  # legend tick labels\r\n  labs(x = \"Eruption time (min)\", y = \"Waiting time (min)\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nWe can also cut the legend bar into several bins by using the\r\nargument guide = guide_colorsteps():\r\n\r\n\r\nggplot(faithful, aes(x = eruptions, y = waiting)) + \r\n  geom_hex(aes(fill = ..count..)) +\r\n  scale_fill_gradient(name = \"Number of \\n eruptions\",\r\n                      limits = c(0, 6),  \r\n                      breaks = c(1, 2, 3, 4, 5),  \r\n                      labels = format(c(1, 2, 3, 4, 5), nsmall = 1),\r\n                      guide = guide_colorsteps()) +  # cut the legend bar into bins\r\n  labs(x = \"Eruption time (min)\", y = \"Waiting time (min)\") + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nSummary\r\nIn this post, we’ve seen how to adjust a continuous legend via the\r\narguments in scale_fill_gradient(): limits for\r\nsetting the range of the legend bar, breaks for drawing the\r\nlegend ticks, and labels for adding the tick labels. We can\r\nalso convert the continuous legend bar into a discrete one by specifying\r\nguide = guide_colorsteps().\r\nHope you learn something useful from this simple post and don’t\r\nforget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-07-02-post-17-ggplot-legend-tips-series-no6-working-on-continuous-legends-with-scalexx-functions/../../homepage_images/Post17.png",
    "last_modified": "2022-07-04T23:11:41-04:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 672
  },
  {
    "path": "posts/2022-06-09-post-16-ggplot-legend-tips-series-no5-working-on-discrete-legends-with-scalexx-functions/",
    "title": "Post #16. ggplot Legend Tips Series No.5: Working on discrete legends with scale_XX functions",
    "description": "In this post, you will learn how to modify the appearance of discrete legends in ggplots using `scale_XX` family of functions.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-06-09",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nBackground\r\nWelcome to the fifth post of ggplot Legend Tips\r\nSeries! This post is a continuation of a previous\r\npost, where I introduced how to modify the appearance of discrete\r\nlegends in ggplots with guides(), such as legend label\r\nfont, legend key size, and legend direction and position (give it a read\r\nif you’re interested!).\r\nToday, we will explore another way to modify discrete legends: using\r\nscale_XX family of functions (e.g.,\r\nscale_color_manual() and\r\nscale_shape_manual()). There are three handy adjustments\r\nyou can do with these scale functions:\r\n\r\n(1) Change legend name and labels  (2)\r\nChange the order of legend keys  (3)\r\nSelectively display certain legend keys\r\nWithout further ado, let’s jump right in!\r\nAn example with\r\nscale_color_brewer()\r\nWe will use the ChickWeight\r\ndataset for our example plots. The dataset contains the body weights of\r\nchicks fed with four different protein diets recorded over a course of\r\n20 days.\r\nLet’s compute the average weight of chicks in each diet treatment and\r\nplot the growth curve over time. We’ll map diet treatment to the “color”\r\naesthetic and use scale_color_brewer() to set the colors\r\nfor the legend.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Average chick weight over time in each diet treatment\r\nChickWeight_avg <- ChickWeight %>% \r\n  group_by(Diet, Time) %>% \r\n  summarise(weight = mean(weight))\r\n\r\n### Growth curve of the chicks\r\nP <- ggplot(ChickWeight_avg) + \r\n  geom_line(aes(x = Time, y = weight, color = Diet)) + \r\n  geom_point(aes(x = Time, y = weight, color = Diet)) +  \r\n  labs(x = \"Day\", y = \"Weight (g)\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP\r\n\r\n\r\n\r\n\r\n(1) Change legend name and\r\nlabels\r\nChanging legend name and labels is perhaps the most common thing\r\nggplot users would do for their legends. This is super straightforward:\r\nsimply specify the argument name = for the new legend name\r\nand pass a vector of labels to argument labels = in\r\nscale_color_brewer(). Easy-peasy!!!\r\n\r\n\r\nP + scale_color_brewer(palette = \"Set1\", \r\n                       name = \"Diet Treatment\",  # new legend name\r\n                       labels = c(\"Red diet\", \"Blue diet\", \"Green diet\", \"Purple diet\"))  # new legend labels\r\n\r\n\r\n\r\n\r\n(2) Change the order of legend\r\nkeys\r\nThe second thing we can do is reordering the legend keys. As you can\r\nsee, the chicks fed with “Green” diet grew the best, followed by those\r\nfed with “Purple” and “Blue” diet, and those fed with “Red” diet grew\r\nthe worst. So can we change the order of legend keys to reflect this\r\nranking?\r\nOf course we can! The main argument for this is break =,\r\nwhich takes a vector of levels in the legend variable (in this example\r\n1, 2, 3, and 4 in the factor Diet). The order of the levels\r\npassed to the argument will determine the order of key items displayed\r\nin the legend.\r\n\r\n\r\nP + scale_color_brewer(palette = \"Set1\", \r\n                       name = \"Diet Treatment\", \r\n                       breaks = c(3, 4, 2, 1),  # new order of the legend keys\r\n                       labels = c(\"Green diet\", \"Purple diet\", \"Blue diet\", \"Red diet\"))\r\n\r\n\r\n\r\n\r\n(3) Selectively display\r\ncertain legend keys\r\nSuppose we want to show only the best (“Green”) and the worst diet\r\n(“Red”) in the legend and hide the other two intermediate ones. We can\r\ndo this by passing the selected levels (here 1 and 3) to the\r\nbreak = argument in the desired order (3 first then 1):\r\n\r\n\r\nP + scale_color_brewer(palette = \"Set1\", \r\n                       name = \"Diet Treatment\", \r\n                       breaks = c(3, 1),  # select the best and the worst diet\r\n                       labels = c(\"Green diet (best)\", \"Red diet (worst)\"))\r\n\r\n\r\n\r\n\r\n\r\nIt is worth noting that there is a second way to selectively display\r\ncertain legend keys, via the argument limits =. However,\r\nthe argument will affect the main plot as well; the levels not specified\r\nin limits = will not be drawn in the plot! In fact, this is\r\nbasically the same as dropping the levels in the factor, and so the\r\naesthetic mapping will change accordingly. See an example below:\r\n\r\n\r\nP + scale_color_brewer(palette = \"Set1\", \r\n                       name = \"Diet Treatment\", \r\n                       limits = c(3, 1),  # select the best and the worst diet\r\n                       labels = c(\"Best diet\", \"Worst diet\"))  # the best and the worst diet are not in green and red now! \r\n\r\n\r\n\r\n\r\n\r\nAs you can see, only the curves for the best and the worst diet are\r\nshown in the plot, and the colors of these two curves have also changed\r\nbecause the number of levels is no longer 4 but 2.\r\nSo depending on the purpose of your figure, you might want to use\r\nbreaks = or limits = to select certain legend\r\nkeys of interest. But just keep in mind that the aesthetic mapping may\r\ndiffer between the two methods!\r\nSummary\r\nIn this post, we looked at how to modify a discrete legend via the\r\narguments in scale_color_brewer(): names = and\r\nlabels = for legend name and labels, as well as\r\nbreaks = and limits = for legend keys. The\r\nsame principle applies to other discrete legend types too, for instance,\r\nlinetype and shape.\r\nHope you learn something useful and don’t forget to leave your\r\ncomments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-06-09-post-16-ggplot-legend-tips-series-no5-working-on-discrete-legends-with-scalexx-functions/../../homepage_images/Post16.png",
    "last_modified": "2022-06-11T23:23:37-04:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 672
  },
  {
    "path": "posts/2022-05-12-post-15-manipulating-axis-scales-for-individual-facets/",
    "title": "Post #15. Manipulating the axes for individual facets with `tidytext` and `ggh4x`",
    "description": "Bothered by the hassle of manipulating the axes for individual facets? This is the post for you!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-05-12",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nJust realized the blog is one year old: it’s now entering the 1st instar! It has definitely grown a lot since it hatched. Keep developing!\r\nBackground\r\nFaceting is arguably one of the most fantastic features of ggplots—it can quickly split the data into subsets by the given categorical variables and visualize these subsets in a grid of panels (facets). However, fine-tuning individual facets can be quite daunting. For example, I’ve been trying to reorder the items along the x-axis within each facet (i.e., different item orders for different facets), or to adjust the y-axis range and tick marks of some specific facets. These tasks don’t sound complicated on the surface, but there is actually no built-in ggplot function/argument to do so.\r\nAfter doing some research online, I found two extension packages: tidytext and ggh4x, that have functions to deal with the these issues. I feel that many ggplot users might have encountered similar problems before, and this is indeed the motivator for me to write something on them. So in this post, I’ll share with you the two nice packages and hope they will come in handy for your own ggplots in the future!\r\n1. Reorder items along x-axis for indiviudual facets\r\nLet’s kick things off by creating a faceted plot using the diamonds dataset, which contains the attributes and prices of over 50,000 diamonds.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(diamonds, aes(x = color, y = price)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut) + \r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13)\r\n\r\n\r\n\r\n\r\nThe above plot shows the means and 95% confidence intervals of the price of diamonds in different colors grouped by cut.\r\nNow, we can reorder the points in an ascending fashion for individual facets, using the function reorder_within() and scale_x_reordered() from the package tidytext.\r\nIn reorder_within(x, by, within, fun), the argument x is the factor you would like to reorder, by is the continuous variable based on which x is reordered, within is the faceting variable, and fun is the function to compute a statistics on the by variable that determines the ordering of levels in x. Ok, that’s quite wordy. An example will make things clear:\r\n\r\n\r\n# install.packages(\"tidytext\")  # install the package if you haven't\r\nlibrary(tidytext)\r\n\r\nggplot(diamonds, aes(x = reorder_within(x = color, by = price, within = cut, fun = mean), y = price)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free_x\") +  # need to set scales = \"free_x\" to allow for varying x-axes for individual facets  \r\n  scale_x_reordered() +  # specify \"limits = rev\" in the function to get descending points\r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13)\r\n\r\n\r\n\r\n\r\nReordered. Nice!\r\nSay we want to adjust the item order for just the facet “Fair”. We can do so using the function facetted_pos_scales() from the package ggh4x:\r\n\r\n\r\n# install.packages(\"ggh4x\")  # install the package if you haven't\r\nlibrary(ggh4x)\r\n\r\n# reordered color levels for \"fair\" diamonds\r\nreordered_levels_fair <- fct_reorder(.f = filter(diamonds, cut == \"Fair\")$color, \r\n                                     .x = filter(diamonds, cut == \"Fair\")$price, \r\n                                     .fun = mean) %>% levels()\r\n\r\nggplot(diamonds, aes(x = color, y = price)) +\r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free_x\") + \r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13) + \r\n  facetted_pos_scales(x = list(cut == \"Fair\" ~ scale_x_discrete(limits = reordered_levels_fair)))  \r\n\r\n\r\n\r\n# x = list(...) means x-axis; cut == \"Fair\" identifies the facet \"Fair\"; ~ scale_x_discrete(limits = ) gives the new item order for that facet   \r\n\r\n\r\n\r\n\r\n2. Adjust y-axis scales for individual facets\r\nThere is an argument scales = in facet_wrap() that allows you to have varying axes for individual facets. You’ve already seen the use of scales = \"free_x\" in the previous plots, and the same goes for y-axis:\r\n\r\n\r\nggplot(diamonds, aes(x = color, y = price)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free_y\") + \r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13)\r\n\r\n\r\n\r\n\r\nNow the y-axes are determined by the range of the data within each facet. However, what if you want to truly customize the axes, say changing the positions and labels of the tick marks? Again, facetted_pos_scales() can do the trick!\r\nLet’s add a few tick marks to the “Fair” and “Premium” panel and cut a few for the “Very Good” and “Ideal” panel so that each panel has five tick marks:\r\n\r\n\r\nlibrary(ggh4x)\r\n\r\nggplot(diamonds, aes(x = color, y = price)) +\r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free_y\") +  # need to set 'scales = \"free_y\"'\r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13) + \r\n  # a list of panels to be modified\r\n  facetted_pos_scales(y = list(cut == \"Fair\" ~ scale_y_continuous(breaks = c(3500, 4000, 4500, 5000, 5500)),\r\n                               cut == \"Premium\" ~ scale_y_continuous(breaks = c(3500, 4200, 4900, 5600, 6300)),\r\n                               cut == \"Very Good\" ~ scale_y_continuous(breaks = c(3000, 3600, 4200, 4800, 5400)),\r\n                               cut == \"Ideal\" ~ scale_y_continuous(breaks = c(2400, 3100, 3800, 4500, 5200))))\r\n\r\n\r\n\r\n\r\nFinally, we can combine both reordering and rescaling to create some cool visual effects:\r\n\r\n\r\nlibrary(tidytext)\r\nlibrary(ggh4x)\r\n\r\nggplot(diamonds, aes(x = reorder_within(x = color, by = price, within = cut, fun = mean), y = price)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = mean_cl_normal) + \r\n  facet_wrap(~cut, scales = \"free\", nrow = 1) +  \r\n  scale_x_reordered() + \r\n  labs(x = \"Color\", y = \"Price\") +\r\n  theme_bw(base_size = 13) +\r\n  facetted_pos_scales(y = list(cut == \"Fair\" ~ scale_y_continuous(limits = c(3800, 12000), breaks = c(3500)), \r\n                               cut == \"Good\" ~ scale_y_continuous(limits = c(1500, 11500), breaks = c(3875)),\r\n                               cut == \"Very Good\" ~ scale_y_continuous(limits = c(-1000, 10000), breaks = c(4250)),\r\n                               cut == \"Premium\" ~ scale_y_continuous(limits = c(-5000, 9000), breaks = c(4625)),\r\n                               cut == \"Ideal\" ~ scale_y_continuous(limits = c(-8500, 4700), breaks = c(5000))))\r\n\r\n\r\n\r\n\r\nOf course this plot is definitely NOT appropriate for data communication; it’s so deceiving and misleading! Just for pure fun and also to demonstrate how versatile the two packages can be!!!\r\nSummary\r\nTo summarize what we’ve talked about, we learned (1) how to reorder the items along the x-axis for individual facets (all at once) using reorder_within() and scale_x_reordered() from the tidytext package, or for specific facet(s) using facetted_pos_scales() from the ggh4x package, and (2) how to adjust axis scales for individual facets using facetted_pos_scales() from the ggh4x package. Having these two skills under your belt will certainly help you go a long way on your ggplot journey!\r\nThat’s it for now and hope the topic in this post would be helpful for you sometime in the future. And as always, don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-05-12-post-15-manipulating-axis-scales-for-individual-facets/../../homepage_images/Post15.png",
    "last_modified": "2022-05-15T23:06:44-04:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 768
  },
  {
    "path": "posts/2022-04-24-post-14-multiple-color-scales-in-one-ggplot/",
    "title": "Post #14. Multiple color scales in one ggplot",
    "description": "Using different color scales for multiple geom layers in one ggplot with `ggnewscale` and `relayer`",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-04-24",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nThe problem\r\nLet’s kick things off with an example:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(data = iris) + \r\n  geom_point(aes(x = Species, y = Sepal.Length, color = Sepal.Length), position = position_jitter(width = 0.1)) + \r\n  geom_boxplot(aes(x = Species, y = Sepal.Length), width = 0.5, outlier.color = NA, fill = NA) + \r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_viridis_c(name = \"Sepal length\")\r\n\r\n\r\n\r\n\r\n Here, we make a boxplot of the sepal length for the three species and add the original data points, which are mapped to a continuous color scale.\r\nNow, what if we also want to use different colors for the boxes? Let’s try it out:\r\n\r\n\r\nggplot(data = iris) + \r\n  geom_point(aes(x = Species, y = Sepal.Length, color = Sepal.Length), position = position_jitter(width = 0.1)) + \r\n  geom_boxplot(aes(x = Species, y = Sepal.Length, color = Species), width = 0.5, outlier.color = NA, fill = NA) +  # map species to color\r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_viridis_c(name = \"Sepal length\") + \r\n  scale_color_brewer(name = \"Species\", palette = \"Set1\")  # color scale for species\r\n\r\n\r\nScale for 'colour' is already present. Adding another scale for\r\n'colour', which will replace the existing scale.\r\nError: Continuous value supplied to discrete scale\r\n\r\n Eek, it throws an error!!! The message says “Continuous value supplied to discrete scale”, meaning that we cannot use another color scale for the plot (the discrete one for species) when there is already one (the continuous one for sepal length). What can we do?\r\nThe solution\r\nThankfully, there are two extension packages designed to solve this problem: ggnewscale and relayer. I’ll walk through them in the following sections.\r\n(1) ggnewscale\r\nLooking for a quick fix? ggnewscale is the go-to: The main function new_scale_color() is super straightforward and easy to use. Simply insert the function before the second color scale (in this case scale_color_brewer()). This will “decouple” the first scale from the second one so that the two scales will not interfere with each other. Indeed, you can apply the principle to three or more color scales!\r\nBy the way, note that new_scale_color() only works for scale, not geom! So if you put both geom_point() and geom_boxplot() before the function, the error will still occur (you can try this out yourself!).\r\n\r\n\r\n# install.packages(\"ggnewscale\")  # install the package if you haven't\r\nlibrary(ggnewscale)\r\n\r\nggplot(iris) + \r\n  geom_point(aes(x = Species, y = Sepal.Length, color = Sepal.Length), position = position_jitter(width = 0.1)) + \r\n  scale_color_viridis_c(name = \"Sepal length\") + \r\n  new_scale_color() +\r\n  geom_boxplot(aes(x = Species, y = Sepal.Length, color = Species), width = 0.5, outlier.color = NA, fill = NA) + \r\n  scale_color_brewer(palette = \"Set1\") + \r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14)\r\n\r\n\r\n\r\n\r\n(2) relayer\r\nThe second way to handle the problem is to use the function rename_geom_aes() in the package relayer. The basic idea of the function is to assign different “names” to the same aesthetic (e.g., color) as if they were different aesthetics so that these “pseudo-aesthetics” will be treated independently and not interfere with each other.\r\nConfused? Let’s break it down in the following example!\r\n\r\n\r\n# devtools::install_github(\"clauswilke/relayer\")  # install the package if you haven't\r\nlibrary(relayer)\r\n\r\nggplot(iris) +\r\n  \r\n  # the first color aesthetic mapping \r\n  # note that you need to use \"colour\" instead of \"color\" for the function to work!\r\n  geom_point(aes(x = Species, y = Sepal.Length, colour = Sepal.Length), position = position_jitter(width = 0.1)) +\r\n  \r\n  # use the new name \"colour_for_species\" for the second color aesthetic mapping\r\n  # specify that \"colour_for_species\" corresponds to the color aesthetic in rename_geom_aes()\r\n  (geom_boxplot(aes(x = Species, y = Sepal.Length, colour_for_species = Species), width = 0.5, outlier.color = NA, fill = NA) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"colour_for_species\"))) + \r\n  \r\n  # the color scale for the first color aesthetic mapping (\"colour\")\r\n  scale_color_viridis_c(aesthetics = \"colour\", name = \"Sepal length\") + \r\n  \r\n  # the color scale for the second color aesthetic mapping (\"colour_for_species\")\r\n  scale_color_brewer(aesthetics = \"colour_for_species\", palette = \"Set1\", name = \"Species\") +\r\n  \r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14)\r\n\r\n\r\n\r\n\r\n There are a few more cool things we can do with the relayer package. For example, we can color the points by both sepal length and species (i.e., three sets of color palettes for the points).\r\n\r\n\r\n# install.packages(\"RColorBrewer\")  # install the package if you haven't\r\nlibrary(RColorBrewer)  \r\npal_species <- brewer.pal(3, \"Set1\")  # the point colors for the three species\r\n\r\nggplot(iris) +\r\n  \r\n  # specify \"group = species\" to use different colors for each species\r\n  # use the new names (col1, col2, and col3) for the color aesthetic mappings\r\n  # specify the color mappings for the corresponding species in aes() \r\n  (geom_point(aes(x = Species, y = Sepal.Length, col1 = Sepal.Length, col2 = Sepal.Length, col3 = Sepal.Length, group = Species), position = position_jitter(width = 0.1)) %>% \r\n  rename_geom_aes(new_aes = c(\"colour\" = \"col1\", \"colour\" = \"col2\", \"colour\" = \"col3\"), aes(colour = case_when(group == 1 ~ col1, group == 2 ~ col2, group == 3 ~ col3)))) +\r\n  \r\n  # geom layer for the boxplot\r\n  (geom_boxplot(aes(x = Species, y = Sepal.Length, col4 = Species), width = 0.5, outlier.color = NA, fill = NA) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col4\"))) + \r\n  \r\n  # color scales for the points (three scales, each for one species)\r\n  scale_color_gradient(aesthetics = \"col1\", low = \"white\", high = pal_species[1], name = \"setosa\", guide = guide_legend(order = 1, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  scale_color_gradient(aesthetics = \"col2\", low = \"white\", high = pal_species[2], name = \"versicolor\", guide = guide_legend(order = 2, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  scale_color_gradient(aesthetics = \"col3\", low = \"white\", high = pal_species[3], name = \"virginica\", guide = guide_legend(order = 3, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  \r\n  # color scale for the boxplot\r\n  scale_color_brewer(aesthetics = \"col4\", palette = \"Set1\", name = \"Species\", guide = guide_legend(order = 4, direction = \"vertical\")) + \r\n\r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14) + \r\n  theme(legend.title.align = 0.5,\r\n        legend.spacing.y = unit(0.05, \"in\"))\r\n\r\n\r\n\r\n\r\n In the example above, the three point legends are jointly determined by the sepal length of the three species, and so they all have the same range. This works fine here, but may not work if the three species had quite different sepal lengths (imagine one species has its sepal ten times longer than that of the other two species, then in that case the legend range will be greatly distorted!)\r\nSo is it possible to have individual range for each legend (i.e., the range of each legend is determined only by the sepal length of the corresponding species)? Of course!\r\n\r\n\r\nggplot() +\r\n  \r\n  # draw three separate geom layers for the points so that their color aesthetic mappings are independent of each other\r\n  (geom_point(data = filter(iris, Species == \"setosa\"), aes(x = Species, y = Sepal.Length, col1 = Sepal.Width), position = position_jitter(width = 0.1)) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col1\"))) +\r\n  (geom_point(data = filter(iris, Species == \"versicolor\"), aes(x = Species, y = Sepal.Length, col2 = Sepal.Width), position = position_jitter(width = 0.1)) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col2\"))) +\r\n  (geom_point(data = filter(iris, Species == \"virginica\"), aes(x = Species, y = Sepal.Length, col3 = Sepal.Width), position = position_jitter(width = 0.1)) %>% \r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col3\"))) +\r\n  \r\n  # geom layer for the boxplot\r\n  (geom_boxplot(data = iris, aes(x = Species, y = Sepal.Length, col4 = Species), width = 0.5, outlier.color = NA, fill = NA) %>%\r\n     rename_geom_aes(new_aes = c(\"colour\" = \"col4\"))) +\r\n  \r\n  # color scales for the points (three scales, each for one species)\r\n  scale_color_gradient(aesthetics = \"col1\", low = \"white\", high = pal_species[1], name = \"setosa\", guide = guide_legend(order = 1, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  scale_color_gradient(aesthetics = \"col2\", low = \"white\", high = pal_species[2], name = \"versicolor\", guide = guide_legend(order = 2, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  scale_color_gradient(aesthetics = \"col3\", low = \"white\", high = pal_species[3], name = \"virginica\", guide = guide_legend(order = 3, direction = \"horizontal\", title.position = \"top\", keywidth = unit(0.05, \"in\"))) +\r\n  \r\n  # color scale for the boxplot\r\n  scale_color_brewer(aesthetics = \"col4\", palette = \"Set1\", name = \"Species\", guide = guide_legend(order = 4, direction = \"vertical\")) +\r\n  \r\n  labs(y = \"Sepal length (cm)\") + \r\n  theme_classic(base_size = 14) + \r\n  theme(legend.title.align = 0.5,\r\n        legend.spacing.y = unit(0.05, \"in\"))\r\n\r\n\r\n\r\n\r\n The main difference from the previous example is that, instead of drawing all the points and specifying all the color mappings in one geom layer, now we do them separately in three geom layers, each for one species so that the three legends will be determined independently for each layer.\r\n *NOTE*\r\nIt seems that currently the relayer package only works for discrete legends. Therefore, if the mapped variable is continuous (like Sepal.Length), you have to force a continuous color scale (like scale_color_gradient()) to be a discrete one using the argument guide = guide_legend().\r\nSummary\r\nTo recap, we learned two packages that allow us to use different color scales for multiple geom layers: ggnewscale is the most convenient for simple purposes; relayer is slightly more complicated yet also more versatile.\r\nIn this post, I use color aesthetic as an example (which I think is the most common situation you will be encountering). But the same principle applies to other aesthetics as well: fill, shape, linetype, etc. (although the authors of the packages do warm that “It’s very experimental, so use at your own risk!”).\r\nThat’s it for now and as always, don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-04-24-post-14-multiple-color-scales-in-one-ggplot/../../homepage_images/Post14.png",
    "last_modified": "2022-04-29T03:33:01-04:00",
    "input_file": {},
    "preview_width": 1056,
    "preview_height": 672
  },
  {
    "path": "posts/2022-03-02-post-13-ggplot-legend-tips-series-no4-merging-ggplot-legends/",
    "title": "Post #13. ggplot Legend Tips Series No.4: Merging ggplot legends",
    "description": "Come and learn two handy tips to merge two ggplot legends into one!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-03-02",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nThe problem\r\nSometimes in ggplots, we get two legends that represent the same variable yet are drawn separately, and we would like to combine the two legends into one. This is the problem we are going to look into in the post.\r\nHere, we will be using the CO2 dataset for our example plots. Let’s first create a boxplot of the CO2 uptake rates of plant individuals under two chilling treatments. The boxes are colored by the site from which the plants originated (the column Type):\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nP1 <- ggplot() + \r\n  geom_boxplot(data = CO2, aes(x = Treatment, y = uptake, color = Type), width = 0.5, outlier.color = NA) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP1\r\n\r\n\r\n\r\n\r\nNow suppose that we want to show the mean uptake rates too. We can compute the means for each Type and Treatment combination and add them to the boxes using another geom layer geom_point(). Also, since the column name Type doesn’t sound intuitive, we’ll change it to Site:\r\n\r\n\r\n### Mean CO2 uptake rates by Type and Treatment\r\nCO2_mean <- CO2 %>% group_by(Treatment, Type) %>% \r\n  summarise(uptake_mean = mean(uptake)) %>%\r\n  rename(Site = Type)\r\n\r\n### Add the means (different point colors and shapes for the two sites)\r\nP2 <- P1 + geom_point(data = CO2_mean, aes(x = Treatment, y = uptake_mean, color = Site, shape = Site), size = 2.5, position = position_dodge(width = 0.5))\r\n\r\nP2\r\n\r\n\r\n\r\n\r\nHmm, the two legends (one mapped to “shape” and the other to “color” aesthetic) are not looking good. They shouldn’t have been separated! How can we put them together?\r\nThe solutions\r\nIt’s quite simple actually. There are two ways to fix the problem:\r\n (1) Reset the legend title  (2) Modify the legend keys\r\nWe’ll take a look at them now.\r\n(1) Reset the legend title\r\nThe first way to combine the two legends is to set the same legend title for them, which can be done by specifying the argument name = in the scale_XX_YY() functions. By doing so, ggplot will know that the two legends are indeed the same one and merge them together.\r\n\r\n\r\nP2 + scale_color_brewer(name = \"Site\", palette = \"Set1\") +\r\n  scale_shape_manual(name = \"Site\", values = c(16, 17))\r\n\r\n\r\n\r\n\r\nTip 2. Modify the legend keys\r\nThe second way is more of a manual merging. The idea is that, we can modify the keys of one legend (in this example the boxes) by adding the keys of the other legend (in this example the points) and then hide the useless legend (in this example the legend for the points).\r\nTo do so, use guides(): simply pass a list of additional legend keys to the argument override.aes for the legend you want to modify and specify \"none\" to hide the useless legend:\r\n\r\n\r\nP2 + guides(color = guide_legend(title = \"Site\", override.aes = list(shape = c(16, 17))),\r\n            shape = \"none\")\r\n\r\n\r\n\r\n\r\nSlightly more tedious than the first way, but still quite easy to do!\r\nSummary\r\nTo recap the two ways to merge ggplot legends, we can (1) reset the legend title, or (2) modify the legend keys. Here I only showed you how to do it for two legends, but the principle applies to multiple legends as well. In fact, you can even “selectively” merge certain legends and leave others alone!\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-03-02-post-13-ggplot-legend-tips-series-no4-merging-ggplot-legends/../../homepage_images/Post13.png",
    "last_modified": "2022-03-07T00:47:19-05:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2022-02-05-post-12-ggplot-legend-tips-series-no3-three-ways-to-turn-off-ggplot-legends/",
    "title": "Post #12. ggplot Legend Tips Series No.3: Three ways to turn off the legends in ggplots",
    "description": "Come and learn three handy tips to turn off the legends in ggplots!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-02-05",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nIntroduction\r\nWhen we map a variable to an aesthetic (e.g., color), ggplot will automatically create a legend for it, which is quite convenient. However, sometimes we may want to hide the legend (maybe the information there is redundant to the plot itself). This is actually pretty easy, and in this post I will show you three ways to do so, each for different purposes and with different effects:\r\n (1) Hide the legend for a geom layer  (2) Hide the legend for an aesthetic mapping  (3) Hide all the legends in the figure\r\nLet’s make an example figure first and we’ll walk through the three methods one by one.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nP <- ggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = Treatment, shape = Type), position = position_jitter(width = 0.05)) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP\r\n\r\n\r\n\r\n\r\n(1) Hide the legend for a geom layer\r\nSuppose that we want to remove all the points and keep only the boxes in the legend. We can do so by specifying show.legend = F in the corresponding geom layer (in this case geom_point()):\r\n\r\n\r\nggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = Treatment, shape = Type), position = position_jitter(width = 0.05), show.legend = F) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\n\r\n\r\n\r\nAs you can see, all the points in the legend (including the ones in the boxes) are now gone and only the boxes are left.\r\n(2) Hide the legend for an aesthetic mapping\r\nLooks like the legend for “color” aesthetic in the original figure is a bit redundant: we’ve already known from the main plot that red represents “nonchilled” and blue represents “chilled”. On the other hand, we need the legend for “shape” aesthetic to show the site information (Quebec vs. Mississippi), which is not present in the plot. So is it possible to remove the legend for color but keep the one for shape? Of course it is! Just specify \"none\" for the aesthetic you want to remove (here color) in guides():\r\n\r\n\r\nP + guides(color = \"none\")\r\n\r\n\r\n\r\n\r\nWe’ve removed the legend for color and kept the shape. Great!\r\n(3) Hide all the legends in the figure\r\nThe last method to hide the legend is to specify legend.position = \"none\" in theme() (which literally means no place for the legend). This will remove all the legends in the figure:\r\n\r\n\r\nP + theme(legend.position = \"none\")\r\n\r\n\r\n\r\n\r\nSummary\r\nTo recap, we’ve learned three ways to turn off ggplot legends: (1) by geom layer, (2) by aesthetic mapping, and (3) all legends together. For figures with a single geom layer and aesthetic mapping, all three methods will give the same results. For figures with more complex legends, they will generate different effects and it would be helpful to think about what the legend should look like and use the above principles to customize your legend.\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-02-05-post-12-ggplot-legend-tips-series-no3-three-ways-to-turn-off-ggplot-legends/../../homepage_images/Post12.png",
    "last_modified": "2022-02-06T23:45:11-05:00",
    "input_file": {},
    "preview_width": 768,
    "preview_height": 576
  },
  {
    "path": "posts/2022-02-01-post-11-ggplot-legend-tips-series-no2-working-on-continuous-legends-with-guides/",
    "title": "Post #11. ggplot Legend Tips Series No.2: Working on continuous legends with guides()",
    "description": "In this post, you will learn how to tweak the appearance of continuous legends in ggplots with `guides()`.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-02-01",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nIn this post, we will be working on continuous legends in ggplots with guides(). This is a continuation of the previous post on discrete legends. Check it out here if you haven’t!\r\nContinuous legends\r\nAs mentioned in the previous post, there are two main types of legends in ggplots: discrete and continuous. The former corresponds to the aesthetics mapped to categorical variables (e.g., gender and eye color), whereas the latter corresponds to the aesthetics mapped to continuous variables (e.g., tree height and population density).\r\nInstead of using built-in datasets as before, this time we will create a dataset ourselves by drawing random numbers from normal distributions (with various means but a fixed standard deviation of 1) for x- and y-coordinates, and then we’ll visualize the 2D density distribution in a contour plot.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Random numbers from normal distributions\r\nset.seed(123)\r\nx_mean <- c(-2, 2.4, 1)\r\ny_mean <- c(-1.3, -1, 2)\r\nrand_df <- data.frame(x = unlist(map(x_mean, function(x){rnorm(n = 200, mean = x, sd = 1)})),\r\n                      y = unlist(map(y_mean, function(x){rnorm(n = 200, mean = x, sd = 1)})))\r\n\r\n### Contour plot\r\nP <- ggplot(rand_df) +\r\n  stat_density_2d(aes(x = x, y = y, fill = ..level..), geom = \"polygon\") + \r\n  theme_classic(base_size = 14) +\r\n  coord_fixed(ratio = 1) + \r\n  scale_fill_gradientn(colors = terrain.colors(10))\r\n\r\nP\r\n\r\n\r\n\r\n\r\nHere, the 2D kernel density estimate ..level.., an internal variable computed for the supplied data by stat_density_2d(), was mapped to the “fill” aesthetic as a continuous variable, and the contours were drawn using geom = \"polygon\".\r\nThe guide_colorbar() function\r\nThe actual function in guides() that controls the continuous legends is guide_colorbar(). In this example, we mapped the variable “..level..” to fill, so we will pass fill = guide_colorbar() into guides() and specify the arguments.\r\nThere are several things we can modify in the legend:\r\n (1) Legend title  (2) Legend labels  (3) Legend bar  (4) Legend layout\r\n(1) Legend title\r\nWe can modify the name, position (relative to the legend labels and bar), and text appearance of the title. We can also adjust its horizontal and vertical alignment.\r\n\r\n\r\nP + guides(fill = guide_colorbar(title = \"Density\",  # name\r\n                                 title.position = \"top\",  # position\r\n                                 title.theme = element_text(size = 15, color = \"blue\", face = \"bold\"),  # text appearance\r\n                                 title.hjust = 0.5,  # horizontal alignment\r\n                                 title.vjust = 3))  # vertical alignment\r\n\r\n\r\n\r\n\r\n(2) Legend labels\r\nSimilarly, we can modify the position (relative to the legend bar) and text appearance of the labels as well as adjust the horizontal and vertical alignment. If we want to hide the labels, specify label = F.\r\n\r\n\r\nP + guides(fill = guide_colorbar(label = T,  # show the labels\r\n                                 label.position = \"left\",  # position\r\n                                 label.theme = element_text(size = 12, color = \"brown\", face = \"italic\"),  # text appearance\r\n                                 label.hjust = 0,  # horizontal alignment\r\n                                 label.vjust = 0.5))  # vertical alignment\r\n\r\n\r\n\r\n\r\n(3) Legend bar\r\nWe can change the width and height of the legend bar to make the color gradient more discernible. We can also modify the appearance of bar frame and bar ticks.\r\n\r\n\r\nP + guides(fill = guide_colorbar(barwidth = unit(0.2, \"inches\"),  # bar width\r\n                                 barheight = unit(2, \"inches\"),  # bar height\r\n                                 frame.colour = \"black\",  # bar frame color\r\n                                 frame.linewidth = 2,  # bar frame width\r\n                                 frame.linetype = \"solid\",  # bar frame linetype\r\n                                 ticks = T,  # show the ticks on the bar\r\n                                 ticks.linewidth = 2,  # tick width\r\n                                 ticks.colour = \"red\",  # tick color\r\n                                 draw.ulim = T,  # show the tick at the upper limit\r\n                                 draw.llim = T  # show the tick at the lower limit\r\n                                 ))\r\n\r\n\r\n\r\n\r\n(4) Legend layout\r\nWe can display the legend either horizontally or vertically and flip the bar if needed.\r\n\r\n\r\nP + guides(fill = guide_colorbar(direction = \"horizontal\",  # direction of the legend\r\n                                 reverse = T))  # flip the bar\r\n\r\n\r\n\r\n\r\nSummary\r\nIn this post, we’ve learned how to modify the appearance and layout of legend bar in continuous ggplot legends using the function guides(). Play around with the arguments a bit and I believe you will be able to make a nice legend(s) for your figure!\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-02-01-post-11-ggplot-legend-tips-series-no2-working-on-continuous-legends-with-guides/../../homepage_images/Post11.png",
    "last_modified": "2022-02-01T20:45:52-05:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2022-01-28-post-10-ggplot-legend-tips-series-no1-working-on-discrete-scale-legends-with-guides/",
    "title": "Post #10. ggplot Legend Tips Series No.1: Working on discrete legends with guides()",
    "description": "In this post, you will learn how to tweak the appearance of discrete legends in ggplots with `guides()`.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2022-01-28",
    "categories": [
      "2022",
      "Legend Tips Series"
    ],
    "contents": "\r\n\r\nWelcome to the first post of 2022—also my 10th ggGallery post! A tiny but meaningful milestone reached!\r\nBackground\r\nLegends are arguably one of the greatest advantages of ggplots over the R base graphics; they are so versatile that you can basically create anything you want. Though, it often takes quite a while to wrap your head around lots of argument details. Also, there are several “players” controlling the legends in ggplots—scale, guide, and theme, adding further complications to the already-complicated system.\r\nInspired by the problems I’ve personally encountered throughout my ggplot learning journey and the questions my friends have asked me about, I’ve decided to launch a blog post series “Legend Tips”, where I dive into the relevant functions/arguments and show how you can make use them to enhance your ggplot legends, as well as provide some handy tips for dealing with frequently-encountered legend issues. I feel that legends would be a great topic to write about, both for myself and for those geeks who use/love ggplots so much as I do!\r\nWe’ll kick this series off by working on discrete legends using the function guides(). Keep reading!\r\nDiscrete legends\r\nThere are two main types of legends in ggplots: discrete and continuous. Discrete legends correspond to the aesthetics mapped to categorical variables (factors), for example, gender and eye color; continuous legends correspond to the aesthetics mapped to continuous variables, for example, tree height and population density. These two legend types can live together in the same figure. They do have many commonalities, but still differ in some detail specifications.\r\nIn this post, we will be using the CO2 dataset, which contains the CO2 uptake rates of 12 grass plant individuals (Echinochloa crus-galli) from two sites Quebec and Mississippi (each 6) measured at several CO2 concentrations. Additionally, half of the plant individuals from each site were chilled overnight before measurement.\r\nLet’s first take a look at the CO2 uptake rates under the two treatments (nonchilled vs. chilled):\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### Boxplot of CO2 uptake rates by treatment\r\nP <- ggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = Treatment), position = position_jitter(width = 0.05)) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP\r\n\r\n\r\n\r\n\r\nSeems that nonchilled individuals have higher CO2 uptake rates than chilled ones by visual inspection. Well, this is not the focus of this post. Let’s get to the main topic and see how we can modify the legend using guides().\r\nThe guide_legend() function\r\nThe actual function in guides() that controls the discrete legends is guide_legend(). In this example, we mapped the factor “Treatment” to color, so we will pass color = guide_legend() into guides() and specify the arguments in guide_legend().\r\nThere are several things we can modify in the legend:\r\n (1) Legend title  (2) Legend labels  (3) Legend keys  (4) Legend layout\r\nAdditionally, we can (5) change the default aesthetic mappings and (6) make specific adjustments for multiple legends.\r\n(1) Legend title\r\nWe can modify the name, position (relative to the legend labels and keys), and text appearance of the title. We can also adjust its horizontal and vertical alignment.\r\n\r\n\r\nP + guides(color = guide_legend(title = \"Treatment\",  # name\r\n                                title.position = \"top\",  # position\r\n                                title.theme = element_text(size = 15, color = \"darkgreen\", face = \"bold.italic\"),  # text appearance\r\n                                title.hjust = 0.5,  # horizontal alignment\r\n                                title.vjust = 2))  # vertical alignment\r\n\r\n\r\n\r\n\r\n(2) Legend labels\r\nSimilar to what we’ve done for the title, we can modify the position (relative to the legend keys) and text appearance of the labels as well as adjust the horizontal and vertical alignment. If we want to hide the labels, specify label = F.\r\n\r\n\r\nP + guides(color = guide_legend(label = T,  # show the labels\r\n                                label.position = \"top\",  # position\r\n                                label.theme = element_text(size = 12, color = \"brown\", face = \"italic\"),  # text appearance\r\n                                label.hjust = 0.5,  # horizontal alignment\r\n                                label.vjust = 0.5))  # vertical alignment\r\n\r\n\r\n\r\n\r\n(3) Legend keys\r\nWe can change the width and height of the legend keys. This is especially handy for adjusting the length (width) of line segments.\r\n\r\n\r\nP + guides(color = guide_legend(keywidth = unit(0.25, \"inches\"),\r\n                                keyheight = unit(0.5, \"inches\")))\r\n\r\n\r\n\r\n\r\n(4) Legend layout\r\nWe can display the legend either horizontally or vertically, with legend items separated into several rows and columns. We can also reverse the order of the items.\r\n\r\n\r\nP + guides(color = guide_legend(direction = \"horizontal\",  # direction of the legend\r\n                                nrow = 1,  # number of rows\r\n                                ncol = 2,  # number of columns\r\n                                byrow = T,  # arrange the legend items row by row \r\n                                reverse = T))  # reverse the legend items\r\n\r\n\r\n\r\n\r\n(5) Change default mappings\r\nSuppose that we want to change the default aesthetic mappings, for example, the color of boxes, the shape of the points, and the size of the legend keys. We can do this by passing a list of new aesthetics to the argument override.aes:\r\n\r\n\r\nP + guides(color = guide_legend(override.aes = list(color = c(\"purple\", \"green\"),\r\n                                                    shape = 17,\r\n                                                    size = 1)))\r\n\r\n\r\n\r\n\r\n(6) Multiple legends\r\nRecall that the plant individuals come from two sites Quebec and Mississippi (variable “Type” in the dataset). We can map it to the “shape” aesthetic:\r\n\r\n\r\n### Different shapes for the two sites\r\nP_multi_legend <- ggplot(data = CO2) + \r\n  geom_boxplot(aes(x = Treatment, y = uptake, color = Treatment), width = 0.5) + \r\n  geom_point(aes(x = Treatment, y = uptake, color = Treatment, shape = Type), position = position_jitter(width = 0.05)) + \r\n  labs(x = \"Treatment\", y = expression(paste(CO[2], \" uptake rate\"))) + \r\n  theme_classic(base_size = 14) + \r\n  scale_color_brewer(palette = \"Set1\")\r\n\r\nP_multi_legend\r\n\r\n\r\n\r\n\r\nNo we have two legends in the figure; time to make some changes for them!\r\nHere, we apply guide_legend() individually to color and shape aesthetic and specify the respective arguments. Also, we use an additional argument order to tell ggplot the order in which the legends should be placed.\r\n\r\n\r\nP_multi_legend + guides(color = guide_legend(title.position = \"top\",\r\n                                             title.hjust = 0.5,\r\n                                             label.position = \"top\",\r\n                                             keywidth = unit(0.7, \"inches\"),\r\n                                             keyheight = unit(0.8, \"inches\"),\r\n                                             direction = \"horizontal\",\r\n                                             order = 1),\r\n                        shape = guide_legend(title = \"Site\",\r\n                                             title.hjust = 0.5,\r\n                                             label.position = \"left\",\r\n                                             label.hjust = 0.5,\r\n                                             label.vjsut = 0.5,\r\n                                             keywidth = unit(0.5, \"inches\"),\r\n                                             reverse = T,\r\n                                             override.aes = list(size = 3),\r\n                                             order = 2)\r\n                        )\r\n\r\n\r\n\r\n\r\nThe changes don’t really make sense to me. Of course, it’s just a toy example showing the principles so that you can apply them next time to real-life situations.\r\nWell that’s pretty much for now. But before we finish, it is worth mentioning that many of the arguments in guides() actually overlap with those in another legend function theme() (which will be the topic in another post of this series). So what’s the difference between these two functions? Which one should you use?\r\nSo the main difference is that, the arguments in guides() only affect the legends corresponding to the specified aesthetics, whereas the arguments in theme() will affect all the legends in the figure together. So if you have only one legend, using either function would give the same results. However, if you have multiple legends and you want to make different adjustments for each of them, then guides() is the go-to.\r\nSummary\r\nIn this post, we’ve learned how to modify the appearance and layout of legend items in discrete ggplot legends using the function guides(). We can even customize the legend keys by overriding the default aesthetic mappings. Try playing around with the arguments a bit and I believe you will be able to make a nice legend(s) for your figure!\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-01-28-post-10-ggplot-legend-tips-series-no1-working-on-discrete-scale-legends-with-guides/../../homepage_images/Post10.png",
    "last_modified": "2022-02-01T20:46:40-05:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-12-20-post-9-arrange-multiple-ggplots/",
    "title": "Post #9. Arrange multiple ggplots on one graphic device",
    "description": "Come and learn two methods to arrange multiple ggplots on one graphic device.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-12-20",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nFeel excited to re-blog after taking a one-and-a-half months break. Quite shocked at my rusty writing skills. I think I really need to brush up a bit! This time, I will just do a simple post as a warm-up.\r\nIntroduction\r\nSometimes we have a set of related plots and we would like to arrange them as a single graph. Instead of doing this manually (e.g., using MS PowerPoint), we can actually do it in R. This not only streamlines the figure generation process, but also makes it fully reproducible so that others can get the exact figure as yours with your code.\r\nIn this post, I will show you two methods for laying out multiple ggplots: (1) using the function ggarrange() in the package ggpubr, and (2) using the function draw_plot() and its families in the package cowplot. Let’s jump right in!\r\nMethod 1. Using ggarrange() in the package ggpubr\r\nggarrange() is a convenient function for arranging multiple ggplots on a same graphic device. It also allows the users to make some adjustments, for example, adding panel labels and aligning the plots by axis. Moreover, the package offers a function for adding text annotations to the figure. We’ll go through these features one by one in the following.\r\nTo begin with, let’s create some plots using the famous iris data set:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### 1. A scatterplot of Sepal.Length vs. Sepal.Width\r\nP1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point() + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14)\r\n\r\n### 2. Density plot of Sepal.Length\r\nP2 <- ggplot(iris, aes(x = Sepal.Length, color = Species)) + \r\n  geom_density(aes(y = ..scaled..)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2))\r\n\r\n### 3. Density plot of Sepal.Width\r\nP3 <- ggplot(iris, aes(x = Sepal.Width, color = Species)) + \r\n  geom_density(aes(y = ..scaled..)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2)) +\r\n  coord_flip()\r\n  \r\nP1\r\nP2\r\nP3\r\n\r\n\r\n\r\n\r\n1. Basic layout\r\nNow, say, we would like to place the density plots at the top (for Sepal.Length) and right (for Sepal.Width) of the scatterplot to show their distributions. We can do this by passing the above ggplot objects (P1, P2 and P3) into ggarrange() and specify the layout designs (the numbers of rows and columns along with their widths and heights).\r\n\r\n\r\nlibrary(ggpubr)\r\n\r\nP_arrg_1 <- ggarrange(P2 + labs(x = \"\", y = \"\"),  # remove the axis labels\r\n                      NULL,  # you can add an empty plot using \"NULL\" to create a white space in the graphic device\r\n                      P1, \r\n                      P3 + labs(x = \"\", y = \"\"), \r\n                      nrow = 2,  # split the graphic device into two rows\r\n                      ncol = 2,  # split the graphic device into two columns\r\n                      widths = c(0.65, 0.35),  # the widths of the two columns\r\n                      heights = c(0.35, 0.65),  # the heights of the two rows\r\n                      common.legend = T)  # use the same legend for all plots\r\n\r\nP_arrg_1\r\n\r\n\r\n\r\n\r\n2. Panel labels\r\nAfter getting our basic layout done, we can then add panel labels to the plots by specifying their x and y positions for each individual plots using values in the range of 0 to 1 (e.g., (x, y) = (0, 0) means bottom-left corner of the plot; values outside this range are also allowed and it will draw the labels outside the plot area).\r\n\r\n\r\nP_arrg_2 <- ggarrange(P2 + labs(x = \"\", y = \"\"),  \r\n                      NULL,\r\n                      P1, \r\n                      P3 + labs(x = \"\", y = \"\"), \r\n                      nrow = 2, \r\n                      ncol = 2,\r\n                      widths = c(0.65, 0.35),  \r\n                      heights = c(0.35, 0.65),  \r\n                      common.legend = T,\r\n                      labels = c(\"(a)\", \"\", \"(b)\", \"(c)\"),  # the panel labels for each plot (also an empty string for the \"NULL\" plot)\r\n                      label.x = c(0, 0, 0, 0),  # the x positions of the labels\r\n                      label.y = c(1.1, 1.1, 1.1, 1.1))  # the y positions of the labels\r\n\r\nP_arrg_2\r\n\r\n\r\n\r\n\r\n3. Text annotations\r\nSometimes we might want to add some text annotations to the figure. ggpubr provides a handy function annotate_figure() for this: simply create a grob object using text_grob() (in which you can specify the x and y positions of the text as well as its horizontal and vertical adjustments) and pass it to annotate_figure()\r\n\r\n\r\nP_arrg_3 <- annotate_figure(P_arrg_2,\r\n                            top = text_grob(\"Visualizing Iris Data\", \r\n                                            color = \"blue\", \r\n                                            face = \"bold.italic\", \r\n                                            size = 14, \r\n                                            x = 0.825, \r\n                                            y = 1, \r\n                                            vjust = 10))\r\n\r\nP_arrg_3\r\n\r\n\r\n\r\n\r\n4. Plot alignment\r\nAnother nice functionality of ggarrange() is that it can automatically align the plot panels by axis (vertically and/or horizontally). This is particularly useful when the plots have different margin sizes (e.g., due to different label lengths). Sounds a bit abstract right? Let’s take a look at an example:\r\n\r\n\r\n### A scatterplot of Sepal.Length vs. Sepal.Width\r\nP4 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point(show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14)\r\n\r\n### Density plot of Sepal.Length\r\nP5 <- ggplot(iris, aes(x = Sepal.Length, color = Species)) + \r\n  geom_density(aes(y = ..scaled..), show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") +\r\n  labs(x = NULL, y = NULL) +\r\n  theme_classic(base_size = 14) \r\n\r\n### The y-axes of the two plots are not aligned by default\r\nggarrange(P5, \r\n          P4,\r\n          nrow = 2,\r\n          heights = c(0.3, 0.7))\r\n\r\n\r\n\r\n\r\n\r\n\r\n### The y-axes of the two plots are now vertically aligned\r\nggarrange(P5, \r\n          P4,\r\n          nrow = 2,\r\n          heights = c(0.3, 0.7),\r\n          align = \"v\")\r\n\r\n\r\n\r\n\r\n\r\nMethod 2. Using draw_plot() in the package cowplot\r\nThe package cowplot provides a family of functions for adding plots/images/text to the graphic device. We will see how to make use of them shortly. Again, let’s first create some example plots:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n### 1. A scatterplot of Sepal.Length vs. Sepal.Width\r\nP1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point(show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14)\r\n\r\n### 2. Density plot of Sepal.Length\r\nP2 <- ggplot(iris, aes(x = Sepal.Length, color = Species)) + \r\n  geom_density(aes(y = ..scaled..)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2))\r\n\r\n### 3. Density plot of Sepal.Width\r\nP3 <- ggplot(iris, aes(x = Sepal.Width, color = Species)) + \r\n  geom_density(aes(y = ..scaled..), show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2)) +\r\n  coord_flip()\r\n  \r\nP1\r\nP2\r\nP3\r\n\r\n\r\n\r\n\r\n1. Basic layout\r\nThe first method ggarrange works by “cutting” the graphic device into grids of various widths and heights and placing the corresponding plots into those grids.\r\nHere, the second method draw_plot(), is a bit different though. Basically, we will first create a drawing canvas (using the function ggdraw()), which has the x- and y-coordinates of 0 to 1. Next, we use draw_plot() to add the plots to this canvas by specifying their x and y positions using values in the range of 0 to 1 (again, (x, y) = (0, 0) corresponds to the bottom-left corner of the plot) as well as the widths and heights.\r\n\r\n\r\nlibrary(cowplot)\r\n\r\nggdraw() + \r\n  draw_plot(P2 + labs(x = \"\", y = \"\"), x = 0, y = 0.65, width = 0.925, height = 0.3) + \r\n  draw_plot(P1, x = 0, y = 0, width = 0.65, height = 0.65) +\r\n  draw_plot(P3 + labs(x = \"\", y = \"\"), x = 0.65, y = 0, width = 0.3, height = 0.65)\r\n\r\n\r\n\r\n\r\n2. Panel labels\r\nWe can add panel labels to the figure using the function draw_text(), with the same principle as draw_plot():\r\n\r\n\r\nggdraw() + \r\n  draw_plot(P2 + labs(x = \"\", y = \"\"), x = 0, y = 0.65, width = 0.925, height = 0.3) + \r\n  draw_plot(P1, x = 0, y = 0, width = 0.65, height = 0.65) +\r\n  draw_plot(P3 + labs(x = \"\", y = \"\"), x = 0.65, y = 0, width = 0.3, height = 0.65) + \r\n  draw_text(c(\"(a)\", \"(b)\", \"(c)\"), x = c(0.075, 0.075, 0.725), y = c(0.975, 0.675, 0.675)) + \r\n  draw_text(\"Visualizing Iris Data\", x = 0.5, y = 0.975, color = \"blue\", size = 14, fontface = \"italic\") \r\n\r\n\r\n\r\n\r\n3. Add external images\r\nAnother cool thing when working with cowplot is that you can add external images to the graphic device. Use draw_image() to do this (note that you need to have the package magick installed beforehand for this function to work):\r\n\r\n\r\n# install.packages(\"magick\")\r\nggdraw() + \r\n  draw_plot(P2 + labs(x = \"\", y = \"\"), x = 0, y = 0.65, width = 0.925, height = 0.3) + \r\n  draw_plot(P1, x = 0, y = 0, width = 0.65, height = 0.65) +\r\n  draw_plot(P3 + labs(x = \"\", y = \"\"), x = 0.65, y = 0, width = 0.3, height = 0.65) + \r\n  draw_text(c(\"(a)\", \"(b)\", \"(c)\"), x = c(0.075, 0.075, 0.725), y = c(0.975, 0.675, 0.675)) + \r\n  draw_text(\"Visualizing Iris Data\", x = 0.5, y = 0.975, color = \"blue\", size = 14, fontface = \"italic\") +\r\n  draw_image(\"https://archive.ics.uci.edu/ml/assets/MLimages/Large53.jpg\", x = 0.75, y = 0.9, width = 0.1, height = 0.1)\r\n\r\n\r\n\r\n\r\n4. Insets and legends\r\nWe can even do more tricks in the figure, for instance, adding inset plots. Additionally, the package has a function called get_legend(), which allows one to extract the legend from a plot (as a grob object) for further use. See the example below to get an idea of how they work:\r\n\r\n\r\n### 1. A scatterplot of Sepal.Length vs. Sepal.Width\r\nP1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point(show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_continuous(limits = c(3, NA)) + \r\n  scale_y_continuous(limits = c(1, NA))\r\n\r\n### 2. Density plot of Sepal.Length\r\nP2 <- ggplot(iris, aes(x = Sepal.Length, color = Species)) + \r\n  geom_density(aes(y = ..scaled..), show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_continuous(limits = c(3, NA)) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2))\r\n\r\n### 3. Density plot of Sepal.Width\r\nP3 <- ggplot(iris, aes(x = Sepal.Width, color = Species)) + \r\n  geom_density(aes(y = ..scaled..), show.legend = F) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_continuous(limits = c(1, NA)) + \r\n  scale_y_continuous(breaks = seq(0, 1, 0.2)) +\r\n  coord_flip()\r\n\r\n### 4. Extract the legend from the scatterplot\r\nP1_legned <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + \r\n  geom_point() + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_continuous(limits = c(3, NA)) + \r\n  scale_y_continuous(limits = c(1, NA))\r\n\r\nP_legend <- get_legend(P1_legned)\r\n\r\n### 5. Inset boxplots \r\nP5 <- ggplot(iris, aes(x = Species, y = Sepal.Length, color = Species)) + \r\n  geom_boxplot(show.legend = F, outlier.shape = NA) + \r\n  scale_y_continuous(limits = c(3, NA)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") + \r\n  coord_flip() + \r\n  theme_classic(base_size = 14) + \r\n  scale_x_discrete(labels = c(\"1\", \"2\", \"3\")) + \r\n  theme(axis.title = element_text(color = \"transparent\"),\r\n        axis.text = element_text(color = \"transparent\"),\r\n        axis.line = element_line(color = \"transparent\"),\r\n        axis.ticks = element_line(color = \"transparent\"),\r\n        panel.background = element_blank(),\r\n        plot.background = element_blank())\r\n  \r\nP6 <- ggplot(iris, aes(x = Species, y = Sepal.Width, color = Species)) + \r\n  geom_boxplot(show.legend = F, outlier.shape = NA) + \r\n  scale_y_continuous(limits = c(1, NA)) + \r\n  scale_color_brewer(palette = \"Set1\", name = \"\") +\r\n  theme_classic(base_size = 14) + \r\n  scale_x_discrete(labels = c(\"1\", \"2\", \"3\")) + \r\n  theme(axis.title = element_text(color = \"transparent\"),\r\n        axis.text = element_text(color = \"transparent\"),\r\n        axis.line = element_line(color = \"transparent\"),\r\n        axis.ticks = element_line(color = \"transparent\"),\r\n        panel.background = element_blank(),\r\n        plot.background = element_blank())\r\n\r\n### Put everything together\r\nggdraw() + \r\n  draw_plot(P2 + labs(x = \"\", y = \"\"), x = -0.025, y = 0.65, width = 0.7, height = 0.3) + \r\n  draw_plot(P1, x = 0, y = 0, width = 0.65, height = 0.65) +\r\n  draw_plot(P3 + labs(x = \"\", y = \"\"), x = 0.65, y = 0, width = 0.3, height = 0.65) + \r\n  draw_text(c(\"(a)\", \"(b)\", \"(c)\"), x = c(0.075, 0.075, 0.725), y = c(0.975, 0.675, 0.675)) + \r\n  draw_text(\"Visualizing Iris Data\", x = 0.5, y = 0.975, color = \"blue\", size = 14, fontface = \"italic\") +\r\n  draw_grob(P_legend, x = 0.75, y = 0.75, width = 0.1, height = 0.1) + \r\n  draw_image(\"https://archive.ics.uci.edu/ml/assets/MLimages/Large53.jpg\", x = 0.75, y = 0.85, width = 0.1, height = 0.1) + \r\n  draw_plot(P5, x = 0, y = 0.025, width = 0.65, height = 0.2) + \r\n  draw_plot(P6, x = 0.025, y = 0, width = 0.2, height = 0.65)\r\n\r\n\r\n\r\n\r\nNote that you might need to experiment a bit so that the inset boxplots align with the axes of the main panel. A tip here is to use exactly the same axis settings (labels, ticks, ranges, font size, etc.) for the main panel and the insets as well as the same x and y positions in draw_plot() (so basically the insets will overlay the main panel). After making sure that the main panel and the insets are nicely aligned, you can remove those unnecessary theme elements from the inset plot and then re-draw them on the main panel.\r\nSummary\r\nTo recap, we’ve walked through two methods to arrange multiple ggplots on one graphic device. The first one, ggarrange() in the package ggpubr, is straightforward and easy-to-use. Just pass the individual plots into the function, tell it your layout designs, and you’re done. The package also offers a function for adding text annotations to the figure. So if you simply just want to combine several ggplots together without complex layout, this is perhaps the go-to method and will save you lots of time.\r\nThe second method, draw_plot() and its family functions in the package cowplot, create a drawing canvas that allows you to put any plots/text/images at any places on it. You can also create plot insets as well as extract the legend from the plot to customize its position. This method provides much greater flexibility in terms of plot layout, but at a cost that it might take some time to experiment a bit so that the objects are at the exact positions you want with the desired sizes. This second method is better-suited for complex plot layout, or if you really want to tweak the plot positions to your heart’s content.\r\nWhatever method you use, the most important thing is to think about what your final figure should look like. Maybe sketch it out on a paper first. After getting sort of an idea, you can then proceed to preparing the individual plots, determining their positions and sizes, doing some decorations like adding panel labels and text annotations, and finally fine-tuning the objects before printing it out.\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-12-20-post-9-arrange-multiple-ggplots/../../homepage_images/Post9.png",
    "last_modified": "2022-01-27T23:58:08-05:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "posts/2021-10-01-post-8-pokemon-phylogeny-with-ggdendro/",
    "title": "Post #8. Pokemon phylogeny with ggdendro",
    "description": "Create a Pokemon phylogenetic tree in ggplot with the extension package ggdendro.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-10-01",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nDifferent from previous posts, this time we are going to have a fun one: Pokemon phylogeny in ggplot! Sounds exciting? Let’s go!\r\nBackground\r\nPokemon is arguably one of the most popular computer games around the world. Not only does it inspire our imagination and creativity, but it also reflects our understanding and passion for nature. In fact, Pokemon was one of my favorite games back in my childhood days: I really enjoyed the sheer joy and excitement of collecting, training, and battling.\r\nPokemon represents a fantasy world teeming with a high diversity of amazing creatures distributed over diverse landscapes. There are currently 900ish Pokemon species as of 2021, belonging to 18 different types/functional groups. They roam around the oceans, wander through the mountains, soar in the sky, dwell under the ground, and even live with humans in the urban areas!\r\nEach Pokemon species is associated with a set of stats pertaining to their ability and performance, including HP (Hit Point), Attack, Defense, Special Attack, Special defense, and Speed. The values of these stats may vary among species of different types, and so it would be quite interesting to do some cluster analysis to explore the relationships among Pokemon types in terms of their stats.\r\nIn this post, we are going to construct the phylogeny of Pokemon types based on their stats and visualize the results using a dendrogram in ggplot. Hopefully, we will gain some novel insights into the Pokemon evolutionary history. Without further ado, let’s get started!\r\nGet the data\r\nThe first and most important thing is to get our Pokemon stats data at hand. We will scrape the data from the Pokemon Database and tidy them a bit.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(rvest)\r\n\r\n# Read the webpage contents\r\nPokemon_html <- read_html(\"https://pokemondb.net/pokedex/all\")\r\n\r\n# Extract and tidy the stats table\r\nPokemon_df <- Pokemon_html %>% \r\n  html_element(\"#pokedex\") %>% \r\n  html_table() %>%\r\n  select(-1, -4) %>%\r\n  mutate(Type = str_extract(Type, pattern = \"[:upper:]{1}[:lower:]*\"))\r\n\r\nhead(Pokemon_df)\r\n\r\n\r\n# A tibble: 6 x 8\r\n  Name            Type     HP Attack Defense `Sp. Atk` `Sp. Def` Speed\r\n  <chr>           <chr> <int>  <int>   <int>     <int>     <int> <int>\r\n1 Bulbasaur       Grass    45     49      49        65        65    45\r\n2 Ivysaur         Grass    60     62      63        80        80    60\r\n3 Venusaur        Grass    80     82      83       100       100    80\r\n4 VenusaurMega V~ Grass    80    100     123       122       120    80\r\n5 Charmander      Fire     39     52      43        60        50    65\r\n6 Charmeleon      Fire     58     64      58        80        65    80\r\n\r\nHierarchical cluster analysis\r\nNow we have the data ready, our next step is to perform hierarchical cluster analysis on the stats data to reveal the relationships among Pokemon types. Since the stats are measured in different units, we will first standardize them and compute the mean (of the standardized values) for each stat by Pokemon type. After that, we will create a dissimilarity matrix of the stats means based on Euclidean distance and use hclust() to do the hierarchical cluster analysis using the complete linkage method.\r\n\r\n\r\n# Standardize the stats and compute the stats means by type\r\nPokemon_df_HC <- Pokemon_df %>% \r\n  mutate(across(HP:Speed, ~scale(.x))) %>%\r\n  group_by(Type) %>% \r\n  summarise(across(HP:Speed, ~mean(.x)))\r\n\r\n# Hierarchical cluster analysis  \r\nPokemon_clust <- Pokemon_df_HC[, -1] %>% \r\n  dist(., method = \"euclidean\") %>%\r\n  hclust(., method = \"complete\")\r\n\r\nPokemon_clust$labels <- Pokemon_df_HC$Type\r\n\r\n\r\n\r\nCreate the dendrogram\r\nSo far so good. Time to get down to our main topic today: creating the dendrogram! There are two main extension packages for visualizing tree-like objects in ggplot: ggdendro and ggtree. ggdendro is an easy-to-use package with simple user-friendly functions, allowing for quick and basic visualization of cluster data. On the other hand, ggtree is a more comprehensive and versatile package geared towards sophisticated visualization and annotation of phylogenetic trees. It has a lot of nice features to offer, but requires more time and effort to really get the hang of the details.\r\nTo keep things simple, we will use ggdendro to visualize our cluster results. The function dendro_data() in the package extracts the line segments and labels from the cluster objects and returns the data as a list of data frames. These data frames can then be used for plotting as well as customizing the appearance of the dendrogram, for example, changing the colors of the terminal branches and setting the labels of the terminal nodes.\r\n\r\n\r\nlibrary(ggdendro)\r\n\r\n# Extract the cluster data\r\nPokemon_dendro <- Pokemon_clust %>% \r\n  as.dendrogram() %>%\r\n  dendro_data(., type = \"rectangle\")\r\n\r\n# Extract the terminal branches\r\nPokemon_dendro_tb <- segment(Pokemon_dendro) %>%\r\n                 filter(yend == 0) %>%\r\n                 left_join(label(Pokemon_dendro)[, c(1, 3)], by = \"x\")\r\n\r\n# The color palette for the Pokemon types\r\ntype_cols_pal <- c(\"Normal\" = \"#A8A77A\", \r\n  \"Fire\" = \"#EE8130\", \r\n  \"Water\" = \"#6390F0\", \r\n  \"Electric\" = \"#F7D02C\",\r\n  \"Grass\" = \"#7AC74C\",\r\n  \"Ice\" = \"#96D9D6\",\r\n  \"Fighting\" = \"#C22E28\",\r\n  \"Poison\" = \"#A33EA1\",\r\n  \"Ground\" = \"#E2BF65\",\r\n  \"Flying\" = \"#A98FF3\",\r\n  \"Psychic\" = \"#F95587\",\r\n  \"Bug\" = \"#A6B91A\",\r\n  \"Rock\" = \"#B6A136\",\r\n  \"Ghost\" = \"#735797\",\r\n  \"Dragon\" = \"#6F35FC\",\r\n  \"Dark\" = \"#705746\",\r\n  \"Steel\" = \"#B7B7CE\",\r\n  \"Fairy\" =  \"#D685AD\")\r\n\r\n# Create the dendrogram\r\nPokemon_dg <- ggplot() +\r\n  geom_segment(data = segment(Pokemon_dendro), \r\n               aes(x = x, y = y, xend = xend, yend = yend)) +\r\n  geom_segment(data = Pokemon_dendro_tb, \r\n               aes(x = x, y = y, xend = xend, yend = yend, color = label),\r\n               show.legend = F) +\r\n  geom_point(data = label(Pokemon_dendro), \r\n             aes(x = x, y = y, label = label, colour = label, hjust = 0), \r\n             size = 3, show.legend = F) +\r\n  geom_text(data = label(Pokemon_dendro), \r\n            aes(x = x, y = y-0.1, label = label, colour = label, hjust = 0), \r\n            size = 3, show.legend = F) + \r\n  coord_flip(clip = \"off\") +  # Make the tree horizontal\r\n  scale_y_reverse(expand = c(0.12, 0)) +  # Place the tree root on the left\r\n  scale_color_manual(values = type_cols_pal) + \r\n  theme_void()\r\n  \r\nPokemon_dg\r\n\r\n\r\n\r\n\r\nAdd Pokemon images\r\nThe above dendrogram looks pretty neat, but we can further spice it up a bit! Guess what ingredients we are going to add to the plot? Yes, The Pokemon images!\r\nWe will retrieve the Pokemon images representative of each type from the Pokemon Database and add them to the terminal nodes using the extension package ggtext. I have done a post on how to use ggtext before. Check it out here if interested!\r\n\r\n\r\nlibrary(ggtext)\r\n\r\n# HTML <img> tags\r\nPokemon_images <- c(\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/dragonite.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/venusaur.png' height = '13' width = '15'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/blastoise.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/articuno.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/arbok.png' height = '17' width = '19'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/clefable.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/gengar.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/alakazam.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/umbreon.png' height = '18' width = '20'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/cramorant.png' height = '18' width = '20'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/pikachu.png' height = '25' width = '27'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/charizard.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/steelix.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/butterfree.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/persian.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/hitmonchan.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/dugtrio.png' height = '15' width = '17'/>\",\r\n\"<img src = 'https://img.pokemondb.net/sprites/sword-shield/icon/onix.png' height = '15' width = '17'/>\")\r\n\r\n# Add the images to the dendrogram\r\nPokemon_dg + \r\n  scale_x_continuous(breaks = c(1:8, 9.1, 10, 11.2, 12:18), labels = Pokemon_images, position = \"top\") +\r\n  theme(axis.text.y.right = element_markdown(vjust = 0.6)) \r\n\r\n\r\n\r\n\r\nQuite a few interesting points from the dendrogram:\r\nOverall, there seem to be two major groups of Pokemon types: Rock ~ Steel and Fire ~ Dragon.\r\nRock, Ground, and Fighting form a monophyletic group: These types are characterized by ground-dwelling species.\r\nFire and Electric are closely related to each other, so are Ice and Water: This makes much sense as fire and electric are both related to heat and energy, and ice and water are just the same substance of different phases.\r\nFairy and Ghost are paired together: Both of them consist of elusive and enigmatic species. In fact, they are pretty much two sides of the same coin—one represents “bright/positive” and the other represents “dark/negative”.\r\nSurprisingly, Grass and Bug are quite distant from each other despite their (presumably) strong trophic connections: This is perhaps because one is a primary producer and the other is a consumer, thus having distinct stat properties.\r\nSummary\r\nTo recap what we have done, we first got the Pokemon stats data from the website and tidied them. Next, we standardized the stats data and performed hierarchical cluster analysis on the mean stats of Pokemon types. Finally, we visualized the cluster results in ggplot using the package ggdendro and added some Pokemon images to the terminal nodes of the dendorgram using the package ggtext.\r\nAt this point, you might have seen that we used quite a few different methods and techniques throughout the process before arriving at our final product. In fact, this is the essence of data science workflow: starting with data collection and import, followed by data tidying and transformation, then data modeling and visualization, and finally data communication, which is just the post you are reading right now!\r\nHope you enjoy the reading and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-10-01-post-8-pokemon-phylogeny-with-ggdendro/../../homepage_images/Post8.png",
    "last_modified": "2021-10-01T02:13:00-04:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 960
  },
  {
    "path": "posts/2021-09-11-post-7-customize-the-axis-scales-for-individual-facets/",
    "title": "Post #7. Customize the axis scales for individual ggplot facets",
    "description": "Come and learn how to customize the axis scales (axis limits, tick breaks, and tick labels) for individual ggplot facets!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-09-11",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nWelcome to my new post! I have been a bit busy lately and I feel so excited to come back to my blog.\r\nIn this post, I will share with you some useful tips for adjusting the axis scales for individual panels when you’re using ggplot facets. I have been dealing with this problem several times before (and I guess you too!), and so I think this would be a great topic to write about. Keep reading and you will surely get something out of it!\r\nThe problem\r\nFacets are quite useful for displaying data by category/level/class. However, sometimes you might have facets in different units, and this might cause some problems for the appearances of the panels (e.g., the panels with large absolute axis range may “distort” the ones with small absolute range). Although you can set scales = \"free_XXX\" to allow the axes to vary by panel, it might not be as satisfying as you think, and this would require further adjustments of the individual facet panels.\r\nWe will be using the airquality dataset as our example data. This dataset contains the daily measurements of four environmental variables, including ozone concentration, solar radiance, temperature, and wind speed, in New York from May to September 1973.\r\nFirst, let’s visualize these four variables at once using facets:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Convert the original dataframe to long format\r\nair_df <- airquality %>% pivot_longer(cols = 1:4, \r\n                                      names_to = \"Env_vars\", \r\n                                      values_to = \"Values\")\r\n\r\n# Plot   \r\nP_air <- ggplot(air_df, aes(x = Day, y = Values, color = as.factor(Month), group = Month)) + \r\n  geom_point() + \r\n  geom_line() +\r\n  labs(x = \"Day of month\", y = NULL) +\r\n  scale_color_brewer(palette = \"Set1\", \r\n                     labels = c(\"May\", \"June\", \"July\", \"August\", \"September\")) +\r\n  facet_wrap(~Env_vars, \r\n             nrow = 2, \r\n             scales = \"free_y\",\r\n             strip.position = \"left\", \r\n             labeller = as_labeller(c(Temp = \"Temperature (°F)\", \r\n                                      Solar.R = \"Solar radiace (lang)\",\r\n                                      Wind = \"Wind (mph)\",\r\n                                      Ozone = \"Ozone (ppb)\"))) + \r\n  theme(strip.background = element_blank(),\r\n        strip.placement = \"outside\",\r\n        legend.position = \"top\",\r\n        legend.title = element_blank())\r\n\r\nP_air\r\n\r\n\r\n\r\n\r\nHmm, the y-axes of the panels look fine, but what if we want to do something further (e.g., change the axis ranges or tick breaks)? Can we modify the axis scales for the individual facets to our heart’s content? Of course we can. Continue reading!\r\nThe solutions\r\nCustomizing the axis scales in ggplot facets is definitely not an easy task, and sometimes it requires a lot of trial and error. There are two ways you can do for it:\r\n Method 1. Manual fix: adjusting the axis scales step by step  Method 2. Quick fix: setting the axis scales using extension package\r\nI’ll go through them in more detail in the following section.\r\nMethod 1. Manual fix\r\nThe basic idea of this method is to identify the individual facets and apply specific scale arguments to each of them. This method includes three main steps: (1) Adjust the limits, (2) Adjust the breaks, and (3) Adjust the labels.\r\nStep (1) - Adjust the limits\r\nWe first start by extracting the current axis limits of each facet panel:\r\n\r\n\r\n# Get a vector of the levels of the facet variable \r\nvar_names <- air_df$Env_vars %>% unique() %>% sort()\r\n\r\n# Extract the limits of each facet panel \r\nfacet_lims <- map(1:4, function(x){\r\n  lims <- ggplot_build(P_air)$layout$panel_scales_y[[x]]$range$range\r\n  set_names(lims, c(\"Lower\", \"Upper\"))\r\n  }) %>%\r\n  `names<-`(var_names) %>%\r\n  bind_rows(.id = \"Facet\")\r\n\r\nfacet_lims\r\n\r\n\r\n# A tibble: 4 x 3\r\n  Facet   Lower Upper\r\n  <chr>   <dbl> <dbl>\r\n1 Ozone     1   168  \r\n2 Solar.R   7   334  \r\n3 Temp     56    97  \r\n4 Wind      1.7  20.7\r\n\r\n\r\nNext, we will create a function using a series of if else statements to “gradually” identify the individual facet panels based on their current limits, and then set the new limits for each of them. This function will later be passed to the breaks = argument in scale_y_continuous() to draw new limits. (I know this is somewhat abstract; see the below code to get a better idea of how this works!)\r\nAlso note that in the if else statements, you can pick any number you like in the logical condition parts, as long as it can distinguish among the facets. For example, you can use max(x) < 50 or max(x) < 30 to identify the “Wind” panel. Though, I would suggest using the midpoint between the upper limits of the two “closest” panels to avoid potential errors (e.g., max(x) < 50 would be better than max(x) < 30 for distinguishing between “Wind” and “Temp” panel).\r\n\r\n\r\nlimits_fun <- function(x) {\r\n  if (max(x) < 50) {  # This will identify the current \"Wind\" panel\r\n    c(0, 30)  # New limits for the \"Wind\" panel\r\n  } else if (max(x) < 150) {  # This will identify the current \"Temp\" panel\r\n    c(40, 120)  # New limits for the \"Temp\" panel\r\n  } else if (max(x) < 250) {  # This will identify the current \"Ozone\" panel\r\n    c(0, 200)  # New limits for the \"Ozone\" panel\r\n  } else {  # This will identify the current \"Solar.R\" panel (the \"leftover\" panel)\r\n    c(0, 350)  # New limits for the \"Solar.R\" panel\r\n  }\r\n}\r\n\r\nP_air + scale_y_continuous(limits = limits_fun)\r\n\r\n\r\n\r\n\r\nWe have changed the axis limits, and now we will proceed to our second step: change the breaks.\r\nStep 2. Change the breaks\r\nSimilar to what we’ve done in the first step, we will create another function, again using a series of if else statements, to “gradually” identify the individual facet panels based on their current tick breaks, and then set the new breaks for each of them.\r\n\r\n\r\nbreaks_fun <- function(x) {\r\n  if (max(x) < 50) {\r\n    seq(0, 30, 5)  # New tick breaks for the \"Wind\" panel\r\n  } else if (max(x) < 150) {\r\n    seq(40, 120, 20)  # New tick breaks for the \"Temp\" panel\r\n  } else if (max(x) < 250) {\r\n    seq(0, 200, 40)  # New tick breaks for the \"Ozone\" panel\r\n  } else {\r\n    seq(0, 350, 50)  # New tick breaks for the \"Solar.R\" panel\r\n  }\r\n}\r\n\r\nP_air + scale_y_continuous(limits = limits_fun,\r\n                           breaks = breaks_fun)\r\n\r\n\r\n\r\n\r\nStep 3. Change the labels\r\nThis step is optional; if you’ve already set the new breaks, then the tick labels should automatically get set too. However, in some cases, you might want change the labels, and you can do it using the same principle as you used in the first two steps. Just make sure the numbers of labels you supply to each facet should match the numbers of tick breaks in that facet. (Here I’ll show you how to set new tick labels but just for demonstration purpose, and so the tick labels might not make any sense!)\r\n\r\n\r\nlabels_fun <- function(x) {\r\n  if (max(x) < 50) {\r\n    letters[1:7]  # New tick labels for the \"Wind\" panel\r\n  } else if (max(x) < 150) {\r\n    letters[8:12]  # New tick labels for the \"Temp\" panel\r\n  } else if (max(x) < 250) {\r\n    letters[13:18]  # New tick labels for the \"Ozone\" panel\r\n  } else {\r\n    letters[19:26]  # New tick labels for the \"Solar.R\" panel\r\n  }\r\n}\r\n\r\nP_air + scale_y_continuous(limits = limits_fun,\r\n                           breaks = breaks_fun,\r\n                           labels = labels_fun)\r\n\r\n\r\n\r\n\r\nThis “manual” method is a bit tedious to be honest, but it does let you know how ggplot deals with the axis scales under the hood. However, who on earth would have the extra time to do this kind of manual adjustments? This is when the second method comes in handy!\r\n(2) Quick fix\r\nThe package ggh4x has many nice functions for working with facets (you can install it from GitHub). Among these, the function facetted_pos_scales() allows users to directly set the scale arguments for each individual facets by name.\r\n\r\n\r\n# devtools::install_github(\"teunbrand/ggh4x\")\r\nlibrary(ggh4x)\r\n\r\nP_air + facetted_pos_scales(\r\n  y = list(Env_vars == \"Ozone\" ~ scale_y_continuous(limits = c(0, 200), \r\n                                                    breaks = seq(0, 200, 40),\r\n                                                    labels = letters[13:18]),\r\n           Env_vars == \"Solar.R\" ~ scale_y_continuous(limits = c(0, 350),\r\n                                                      breaks = seq(0, 350, 50),\r\n                                                      labels = letters[19:26]),\r\n           Env_vars == \"Temp\" ~ scale_y_continuous(limits = c(40, 120), \r\n                                                   breaks = seq(40, 120, 20),\r\n                                                   labels = letters[8:12]),\r\n           Env_vars == \"Wind\" ~ scale_y_continuous(limits = c(0, 30), \r\n                                                   breaks = seq(0, 30, 5),\r\n                                                   labels = letters[1:7]))\r\n      )\r\n\r\n\r\n\r\n\r\nDone! Exact output. Easy-peasy!\r\nSummary\r\nIn this post, we have walked through two ways to customize the axis scales for individual ggplot facets. Facets are really useful, but sometimes they’re also difficult to work with, and it really takes time to get your head around. Fortunately, there are many extension packages designed to make ggplots more user-friendly and versatile, and people in the R community have also been discussing all kinds of ggplot-related issues. Simply search on the net and you’ll find the solutions to your problems out there!\r\nHope this post helps and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-09-11-post-7-customize-the-axis-scales-for-individual-facets/../../homepage_images/Post7.png",
    "last_modified": "2021-09-15T02:31:15-04:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 768
  },
  {
    "path": "posts/2021-08-02-post-6-play-good-music-for-your-data-violin-plots-with-ggplot/",
    "title": "Post #6. Play good music for your data - violin plots with ggplot",
    "description": "Visualize data distributions using violin plots with ggplot.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-08-02",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nIntroduction\r\nData exploration is the very first step for any data analysis project, allowing us to grasp an idea of what our data look like before proceeding to further analyses. We can use some simple summary statistics (e.g., mean, SD, the five-number summary 1) to do so. Alternatively, we can plot the data to really show their “true colors” and potentially uncover some interesting/weird patterns (to see is to believe right?!). This is especially handy for large datasets where it is difficult to inspect each data point.\r\nThere are quite a few types of graphs we can use to visualize the distribution of (continuous) data. In this post, I will show you some commonly-used graphs, first the basic ones (strip plot, box plot, and point-range plot), and then to our focus—the violin plot.\r\nSome basic visualizations for data distributions\r\nWe will be using the crabs dataset from the MASS package as our example data. This dataset contains five morphological measurements (frontal lobe size, rear width, carapace length, carapace width, and body depth) of 50 purple rock crab (Leptograpsus variegatus) individuals for each of the two color forms (blue and orange) and sexes (male and female). An interesting question here is whether the carapace width, an important indicator for individuals’ growth and development, differ between sexes for the two color forms. Before conducting formal statistical tests, it would be great to first visualize the carapace width by color form and sex so that we can get an idea of what the data look like.\r\nLet’s begin with some basic and most-commonly used graphs:\r\n (1) Strip plot  (2) Box plot  (3) Point-range plot\r\n(1) Strip plot\r\nA strip plot is no more than drawing the raw data points along the axis to show their distribution and range. In fact, it is simply a special version of scatterplot where one dimension (usually x-axis) is fixed to one or a few positions.\r\n\r\n\r\nlibrary(MASS)  # For the \"crabs\" dataset\r\nlibrary(tidyverse)\r\n\r\ncrabs_df <- crabs %>%\r\n  select(sp, sex, CW) %>%\r\n  transmute(color = case_when(sp == \"B\" ~ \"Blue\",\r\n                              sp == \"O\" ~ \"Orange\"),\r\n            sex = case_when(sex == \"M\" ~ \"Male\",\r\n                            sex == \"F\" ~ \"Female\"),\r\n            carapace_width = CW)\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_point(position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.7)) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nHere I use position_jitterdodge() to dodge the points for the two sexes within each color form so that they won’t overlap with each other at the same x-axis position, and also to jitter the points (i.e., adding some random noise) within each sex to prevent overplotting (points lying on top of each other).\r\nAs you can see, blue males tend have a wider carapace than blue females, whereas orange males and females seem to have similar carapace widths.\r\n(2) Box plot\r\nA common alternative to strip plot is the box plot, where the data are displayed as a box and two whiskers based on the five-number summary (remember this term in the “Introduction”?).\r\n\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_boxplot(position = position_dodge(width = 0.7), width = 0.5) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nWe can see that the median carapace width of blue males is larger than that of the blue females, while the opposite is true for the orange form.\r\n(3) Point-range plot\r\nYet another alternative to strip plot is the point-range plot, where the data are displayed as a mean and some measure of uncertainty (e.g., SD, SE, and confidence interval).\r\n\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  stat_summary(geom = \"pointrange\", fun.data = \"mean_se\", position = position_dodge(width = 0.5)) +  # The bars represent SE \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nApparently, blue males are on average wider than blue females and vice versa for the orange form.\r\n\r\nViolin plot\r\nNow let’s get down to our main topic—the violin plot. A violin plot displays the kernel density estimates of the data as two symmetrical probability curves, forming a violin-like area and hence the name.\r\nA violin plot provides more information than a box plot or a point-range plot does, as it shows the full distribution of the data rather than just a few summary statistics. In particular, when the data distribution is bi-modal or multi-modal (i.e., more than one peak), a violin plot can show the positions of the peaks as well as their relative magnitudes, which are otherwise not revealed by a box plot or a point-range plot.\r\nThere is a trade-off though. Depending on the data, the probability curves can actually be quite curly and you might want to dispose of the “malformed” violin if that’s the case.\r\nTo make a violin plot with ggplot, simply use the ggplot2 built-in function geom_violin():\r\n\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), width = 0.5) + \r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nThis violin plot looks a bit plain. We can modify some arguments in geom_violin() to make it more appealing. For example, we can turn off the trim argument to allow for full density curves beyond the data range, add lines inside the violins to denote the quartiles, and fill the empty violins with some colors to make them more “concrete”.\r\n\r\n\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.5,\r\n              size = 1,  # Thicker lines\r\n              trim = F,  # Don't trim off the tails of density curves beyond data range\r\n              scale = \"area\",  # All violins have the same area size \r\n              draw_quantiles = c(0.25, 0.5, 0.75),  # Add quartiles to the violins\r\n              fill = alpha(\"grey\", 0.3)) +  # Fill the violins\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\nAn important aspect of a violin plot is the density curves, determined by two factors: bandwidth and kernel (this is a bit mathy; see this post for details if interested). Bandwidth is the easier (and also straightforward) one to adjust. It is a real positive number and controls the smoothness of the density estimates: a smaller value gives a “spikier” curve, whereas a larger value results in a “smoother” look.\r\n\r\n\r\nmap(c(0.5, 1, 2, 5), function(bw_values){  # Pass a set of bandwidth values to the ggplot\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.5,\r\n              size = 1,  \r\n              trim = F,\r\n              scale = \"area\",\r\n              draw_quantiles = c(0.25, 0.5, 0.75),\r\n              fill = alpha(\"grey\", 0.3),\r\n              bw = bw_values) +  # Control the bandwidth\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = paste0(\"Bandwidth = \", bw_values)) + \r\n  guides(color = \"none\") +\r\n  theme_classic(base_size = 12) + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n})\r\n\r\n\r\n\r\n\r\nDepending on the nature of the data, you might want to try out a few bandwidth values and see which one best captures the data distribution. Or, you can just do nothing and let ggplot pick a default one for you!\r\n\r\nVariants of violin plots\r\nLet’s now go a bit further and take a look at some cool variants of violin plots.\r\n(1) Overlay other plot types\r\nWe can add strip plots, box plots, or point-range plots to the violin plots to show more information about the data.\r\n\r\n\r\n### Violin plot + strip plot\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.7,\r\n              size = 1,\r\n              trim = F,\r\n              scale = \"area\") +\r\n  geom_point(position = position_jitterdodge(jitter.width = 0.05, dodge.width = 0.7), show.legend = FALSE) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n### Violin plot + box plot\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.7,\r\n              size = 1,\r\n              trim = F,\r\n              scale = \"area\") +\r\n  geom_boxplot(position = position_dodge(width = 0.7), width = 0.2, show.legend = FALSE) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n### Violin plot + point-range plot\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex)) + \r\n  geom_violin(position = position_dodge(width = 0.7), \r\n              width = 0.7,\r\n              size = 1,\r\n              trim = F,\r\n              scale = \"area\") +\r\n  stat_summary(geom = \"pointrange\", \r\n               fun = mean, \r\n               fun.min = function(x) mean(x) - sd(x),  # The bars represent SD\r\n               fun.max = function(x) mean(x) + sd(x),\r\n               position = position_dodge(width = 0.7), show.legend = FALSE) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5))\r\n\r\n\r\n\r\n\r\n(2) Hybrid violin plot\r\nWhen there are two groups (violins) within each x-axis category (e.g., “male” and “female” in this example), we can halve the two violins and combine them into one hybrid violin for a better comparison.\r\nThere is no direct function or argument to create a hybrid violin plot, and so we would need to code it a bit: first compute the kernel density estimates manually, then do some data manipulations, and finally map the processed data to the plot. I have wrapped these steps into a function called geom_hybrid_violin(). See the comments in the below code chuck for what the functions actually does under the hood!\r\nBy the way, there is also a function called geom_split_violin() on stackoverflow. It is basically an extended geom of the original geom_violin(), built using the ggproto system (quite an advanced topic; saved for future posts!). You can simply copy and paste the code into your R session and it is ready for use.\r\n\r\n\r\n### Create the function \"geom_hybrid_violin()\"\r\ngeom_hybrid_violin <- function(data,  # A dataset you would like to visualize\r\n                               x_var,  # An unquoted name of the (categorical) variable for the x-axis \r\n                               hybrid_var, # An unquoted name of the (binary) variable of which the two levels are to be compared with each other\r\n                               y_var,  # An unquoted name of the (continuous) variable of which the distribution is to be visualized \r\n                               bandwidth = NULL,  # A real positive number specifying the bandwidth for kernel density estimates\r\n                               width_adj = 1,  # A real positive number multiplied with the density estimates to adjust the width of the violins (1 means no adjustment)\r\n                               x_lab,  # A quoted string as x-axis label\r\n                               y_lab){  # A quoted string as y-axis label\r\n  \r\n  # Step 1. Quote the arguments\r\n  x_var <- enquo(x_var)\r\n  hybrid_var <- enquo(hybrid_var)\r\n  y_var <- enquo(y_var)\r\n  \r\n  # Step 2. Convert the x_var and hybrid_var into factors\r\n  # The \"!!\" (pronounced \"bang bang\") symbol is to unquote the variables so that they can be evaluated in a non-standard way \r\n  data_fct <- data %>% mutate(!!x_var := as.factor(!!x_var),\r\n                              !!hybrid_var := as.factor(!!hybrid_var))\r\n  \r\n  # Step 3. Get the levels of the x_var and hybrid_var\r\n  x_var_levels <- select(data_fct, !!x_var) %>% pull() %>% levels()\r\n  hybrid_var_levels <- select(data_fct, !!hybrid_var) %>% pull() %>% levels()\r\n  \r\n  # Step 4. Compute kernel density estimates by x_vars and hybrid_var\r\n  dens_df <- data_fct %>% \r\n    group_by(!!x_var, !!hybrid_var) %>%\r\n    summarize(prob_raw = ifelse(is.null(bandwidth), list(density(!!y_var)$y), list(density(!!y_var, bw = bandwidth)$y)),\r\n              y = ifelse(is.null(bandwidth), list(density(!!y_var)$x), list(density(!!y_var, bw = bandwidth)$x))) %>%\r\n    unnest(cols = c(prob_raw, y)) %>%\r\n    mutate(prob_adj = prob_raw*width_adj,  # Multiply the original density estimates by a constant to adjust the violin width\r\n           prob_flip = ifelse(!!hybrid_var == hybrid_var_levels[1], prob_adj*-1, prob_adj),  # Flip the curve of the density estimates for the level on the right-hand side\r\n           prob_final = prob_flip + as.numeric(!!x_var))  # Spread out the density estimates for each level of x_var according to the order in which they appear along the x-axis\r\n\r\n  # Step 5. Plot the data using geom_polygon\r\n  p <- ggplot(data = dens_df, aes(x = prob_final, y = y, \r\n                                  color = !!hybrid_var, \r\n                                  fill = after_scale(alpha(color, 0.8)), \r\n                                  group = interaction(!!x_var, !!hybrid_var))) +\r\n    geom_polygon() + \r\n    scale_color_brewer(palette = \"Set1\") +\r\n    scale_fill_brewer(palette = \"Set1\") +\r\n    scale_x_continuous(limits = c(0.5, length(x_var_levels)+0.5), breaks = 1:length(x_var_levels), labels = x_var_levels) +  # Specify the positions along the x-axis at which the violins are displayed\r\n    labs(x = x_lab, y = y_lab) + \r\n    theme_classic() + \r\n    theme(legend.title = element_text(hjust = 0.5))\r\n\r\nreturn(p)\r\n  \r\n}\r\n\r\n### Pass the data to the function and specify the arguments\r\ngeom_hybrid_violin(data = crabs_df, \r\n                   x_var = color, \r\n                   hybrid_var = sex, \r\n                   y_var = carapace_width,\r\n                   bandwidth = 2,\r\n                   width_adj = 3,\r\n                   x_lab = \"Color form\",\r\n                   y_lab = \"Carapace width (mm)\")\r\n\r\n\r\n\r\n\r\n(3) Wilkinson dot plot and beeswarm plot\r\nInstead of showing the data distribution as curves and areas, we can use dots to represent the density estimates. This kind of plot is called a “Wilkinson dot plot” or a “beeswarm plot” (it does look like a swarm of bees!). In fact, it is a modified strip plot and you can think of it as the “discrete” version of the violin plot.\r\nThere are two ways for creating a Wilkinson dot plot or a beeswarm plot: one is using the ggplot2 built-in function geom_dotplot(), and the other is the geom_beeswarm() or geom_quasirandom() from the extension package ggbeeswarm.\r\n\r\n\r\n### geom_dotplot()\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex, fill = sex)) + \r\n  geom_dotplot(binaxis = \"y\", stackdir = \"center\", position = position_dodge(width = 0.8), dotsize = 0.7) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  scale_fill_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = \"geom_dotplot()\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n### geom_beeswarm()\r\n# install.packages(\"ggbeeswarm\")\r\nlibrary(ggbeeswarm)\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex, fill = sex)) + \r\n  geom_beeswarm(cex = 2.5, dodge.width = 0.8, size = 2) +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = \"geom_beeswarm()\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n### geom_quasirandom() with bandwidth = 0.1\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex, fill = sex)) + \r\n  geom_quasirandom(bandwidth = 0.1, nbins = 100, cex = 2, dodge.width = 0.8, method = \"smiley\") +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = \"geom_quasirandom() \\n (bandwidth = 0.1)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n### geom_quasirandom() with bandwidth = 2\r\nggplot(data = crabs_df, aes(x = color, y = carapace_width, color = sex, fill = sex)) + \r\n  geom_quasirandom(bandwidth = 2, nbins = 100, cex = 2, dodge.width = 0.8, method = \"smiley\") +\r\n  scale_color_brewer(palette = \"Set1\") +\r\n  labs(x = \"Color form\", y = \"Carapace width (mm)\", title = \"geom_quasirandom() \\n (bandwidth = 2)\") + \r\n  theme_classic() + \r\n  theme(legend.title = element_text(hjust = 0.5),\r\n        plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n\r\n\r\n\r\nSimilar to geom_violin(), you can specify the bandwidth in geom_quasirandom() to adjust the “smoothness” of the swarm.\r\nSummary\r\nIn this post, we have seen some basic graph types as well as the violin plot and its extensions for visualizing data distributions. Violin plots can be quite useful for conveying the message in the data; however, they are much less popular in scientific communication (compared with strip plots or box plots). Believe it or not, I didn’t even hear of “violin plot” until I started learning ggplots!\r\nYou can make a plain violin plot more informative by combining other graph types to display different aspects of the data. Just don’t overdo it as the information can be too rich and perhaps obscured. Experiment a bit and find the right balance. Your data will appreciate you if you play a beautiful piece of music for them!\r\nThat’s it for this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\nThe five-number summary is set of descriptive statistics consisting of the minimum value, the lower quartile (Q1), the median (Q2), the upper quartile (Q3), and the maximum value.↩︎\r\n",
    "preview": "posts/2021-08-02-post-6-play-good-music-for-your-data-violin-plots-with-ggplot/../../homepage_images/Post6.png",
    "last_modified": "2021-08-27T03:38:41-04:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-07-10-post-5-awesome-text-display-with-ggtext/",
    "title": "Post #5. Awesome text displays with ggtext",
    "description": "Enhance text displays in your ggplots with the extension package ggtext!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-07-10",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nOverview\r\nText is one of the fundamental elements in a graph. A well-designed text display can make your plot look pleasant and more informative. ggplot2 provides many functions and arguments for text manipulation (appearance, layout, annotation, etc.), which are already more than enough most of the time. But if you want to do something further, the extension package ggtext has more to offer. This package has several added functionalities currently not implemented in ggplot2, the most important being that it supports the use of Markdown/HTML/CSS, which offers greater flexibility in text rendering. So in this post, I will be showing you some of these cool features. Ready? Let’s get started!\r\nDate preparation\r\nWe will be using the data from the International Biology Olympiad website. IBO is arguably the largest annual biology event for high school students. Each year, a member country will host the competition, and students around the world will gather to participate in this great event. Since the very first IBO held in 1990 in the Czech Republic, more countries have joined as members, and it would be interesting to see how the numbers of participating students changed over the past three decades.\r\nTo do so, we will first scrap the data from the website using the package rvest, and then do some data manipulation for later plotting use. Since web-scraping is not the main focus of this post, I will not go into the details. If interested, you can visit the package’s website for more information. There are also plenty of learning resources out there on the internet.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(rvest)\r\n\r\n# The website url\r\nIBO_url <- \"https://www.ibo-info.org/en/contest/past-ibos.html\"\r\n\r\n# Read the html and select elements using css selectors\r\nIBO_html <- read_html(IBO_url) %>%\r\n  html_elements(\"div.item__content\") %>%\r\n  html_text2()\r\n\r\n# Extract the information from the html text\r\nYear <- IBO_html %>% str_extract(\"[:digit:]{4}(?=:)\")\r\n\r\nCountry <- IBO_html %>% str_extract(\"(?<=,\\\\s)[:alpha:]+[:blank:]*[:alpha:]*\") %>%\r\n  replace_na(\"Japan\")\r\n\r\nStudents <- IBO_html %>% str_extract(\"[:digit:]*(?=\\\\s*students)\")\r\n\r\n# Put all information in a dataframe  \r\nIBO_data <- tibble(Year, Country, Students) %>%\r\n  mutate(Year = as.numeric(Year),\r\n         Students = as.numeric(Students)) %>%\r\n  filter(Year %in% 1990:2020)  # Use data only from 1990 to 2020\r\n\r\n\r\n\r\n\r\nThe basic plot\r\nNow we have our dataset at hand. It’s time to visualize it using a simple line chart:\r\n\r\n\r\nggplot(IBO_data, aes(x = Year, y = Students)) + \r\n  geom_point() + \r\n  geom_line() + \r\n  labs(y = \"Number of participants\") +\r\n  theme_classic() \r\n\r\n\r\n\r\n\r\nAs you can see, the number of participants had generally increased over time, but there was a sharp drop in 2020 due to the COVID-19 global pandemic, which might have caused some countries to withdraw from the event.\r\nMake it texty\r\nThe above line chart looks fine, though a bit plain. So now we will make use of ggtext to add some flavor to it. I will split the line chart into two panels (one from 1990 to 2005 and the other from 2006 to 2020) using facets for two reasons: (1) to avoid crowding and overlapping, and (2) to demonstrate how we can modify the facet strips.\r\n\r\n\r\nlibrary(ggtext)\r\nlibrary(extrafont) # Fonts for plotting\r\n\r\n# Import and register the system fonts\r\n# font_import()  # Please run this line to import the fonts; only need to do it once\r\nloadfonts(quiet = T)  # Need to load the system fonts in every R session\r\n\r\n# Create a new column for the two time periods\r\nIBO_data <- IBO_data %>% \r\n  mutate(Time_period = ifelse(Year <= 2005, \"1990 to 2005\", \"2006 to 2020\"))\r\n\r\n# Plain faceted line chart\r\nIBO_plot <- ggplot(IBO_data, aes(x = Year, y = Students)) + \r\n  geom_point() + \r\n  geom_line() + \r\n  facet_wrap(~Time_period, scales = \"free\", nrow = 2, strip.position = \"right\") +\r\n  scale_x_continuous(breaks = 1990:2020) + \r\n  theme_classic()\r\n\r\nIBO_plot \r\n\r\n\r\n\r\n\r\nThere are three main things we can do with ggtext:\r\n (1) Modify text outside the plot area  (2) Modify text inside the plot area  (3) Add external images to the plot\r\nI will go through the details in the following sections.\r\n(1) Modify text outside the plot area\r\nFirst, we will begin by modifying the text outside the plot area — title, axis labels, axis ticks, captions, facet strips, etc.\r\nTitle\r\n\r\n\r\n# Title\r\nIBO_plot <- IBO_plot + \r\n  labs(title = \"<span style = 'font-size: 18pt'><i>**I**nternational **B**iology **O**lympiad<i/><\/span><br>Numbers of participants over past three decades\") + \r\n  theme(plot.title = element_textbox_simple(size = 10,\r\n                                            family = \"Century Gothic\",\r\n                                            color = \"#007575\",\r\n                                            fill = \"#e0f2f2\",\r\n                                            halign = 0.5,\r\n                                            lineheight = 1.5,\r\n                                            padding = margin(5, 1, 5, 1), \r\n                                            margin = margin(0, 0, 5, 0)))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nAxis labels\r\n\r\n\r\n# Axis labels\r\nIBO_plot <- IBO_plot + \r\n  labs(x = \"\", y = \"Number of participants<br><span style = 'font-size: 9pt;'>(**Note:** different y-axis scales in the two panels)<\/span>\") + \r\n  theme(axis.title.y = element_textbox_simple(size = 14,\r\n                                              family = \"Arial\",\r\n                                              color = \"#045a8d\",\r\n                                              fill = \"#fff080\",\r\n                                              halign = 0.5,\r\n                                              orientation = \"left-rotated\",\r\n                                              r = unit(5, \"pt\"),\r\n                                              padding = margin(4, 4, 4, 4),\r\n                                              margin = margin(0, 0, 8, 0),\r\n                                              minwidth = unit(2, \"in\"),\r\n                                              maxwidth = unit(5, \"in\")))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nAxis ticks\r\n\r\n\r\n# Axis ticks\r\nbreaks_fun <- function(x) {  # A function to specify the axis tick positions for the two panels\r\n  if (min(x) < 50) {\r\n    seq(0, 200, 50)\r\n  } else {\r\n    seq(150, 300, 50)\r\n  }\r\n}\r\n\r\nlabels_fun <- function(x) {  # A function to specify the axis tick labels for the two panels\r\n  if (min(x) < 50) {\r\n    c(\"<span style = 'font-size: 12pt; color: red;'>0<\/span>\", seq(50, 150, 50), \"<span style = 'font-size: 12pt; color: red;'>200<\/span>\")\r\n  } else {\r\n    c(\"<span style = 'font-size: 12pt; color: red;'>150<\/span>\", seq(200, 250, 50), \"<span style = 'font-size: 12pt; color: red;'>300<\/span>\")\r\n  }\r\n}\r\n\r\nIBO_plot <- IBO_plot + \r\n  scale_y_continuous(expand = c(0, 40),  # For adjusting the y-axis range \r\n                     breaks = breaks_fun,\r\n                     labels = labels_fun) +\r\n  theme(axis.text.y = element_markdown())\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nCaption\r\n\r\n\r\n# Caption\r\nIBO_plot <- IBO_plot + \r\n  labs(caption = \"<i><span style = 'font-size: 9pt;'>Data source: https:&#47;&#47;www&#46;ibo-info.org/en/contest/past-ibos.html<\/span><br>Retrieved July, 2021<i/>\") + \r\n  theme(plot.caption = element_markdown(size = 8,\r\n                                        family = \"serif\",\r\n                                        color = \"grey50\",\r\n                                        lineheight = 1.5))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nFacet strips\r\n\r\n\r\n# Facet strips\r\nIBO_plot <- IBO_plot + \r\n  theme(strip.background = element_blank(),\r\n        strip.text.y = element_textbox_simple(size = 12,\r\n                                              family = \"Comic Sans MS\",\r\n                                              color = \"white\", \r\n                                              fill = \"#810f7c\", \r\n                                              halign = 0.5,\r\n                                              orientation = \"right-rotated\",\r\n                                              r = unit(8, \"pt\"),\r\n                                              padding = margin(1, 1, 1, 1),\r\n                                              margin = margin(3, 3, 3, 3)))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nThe key functions here are element_textbox_simple() and element_markdown(). Basically they do the same job; the main difference is that the former allows for more control over the appearance of the text box, whereas the latter focuses on modifying the text itself. So if you are working with text only, you can simply use element_markdown().\r\nThere are many things you can modify for the text. For example, the font size, font family, font color, font position and alignment, and line spacing. As for the text box, you can change the border color, fill color, size, corner radius (for rounded box), and so on. Take a look at the documentations of the two functions to see what other arguments there are!\r\nThe usage of element_textbox_simple() and element_markdown() are pretty much similar to their ggplot2 counterpart element_text(). When you want to modify a specific part of the plot (e.g., title), just call these functions to the corresponding arguments (e.g., plot.title =) in the theme().\r\nAlso, you might have seen that I use quite a bit of the Markdown/HTML/CSS syntaxes. Remember in the beginning, I mentioned that ggtext can render text written in Markdown/HTML/CSS languages. With these, you can easily do some advanced text manipulation, for instance, modifying the appearance of a specific letter/word in a sentence (like what I did for the title).\r\n(2) Modify text inside the plot area\r\nAfter getting the text outside the plot area done, we can proceed to the text inside the plot area. Specifically, I will add country labels to the points and modify their appearances a bit.\r\nHere I use the function geom_richtext() to map the country labels to the points. This function is quite similar to ggplot2’s geom_text() or geom_label(), but it has an additional feature: the text/box can be rotated by any angles.\r\n\r\n\r\n# Add country labels to the points\r\nIBO_plot <- IBO_plot +\r\n  geom_richtext(aes(label = Country), \r\n                size = 2,\r\n                color = colorRampPalette(c(\"#a50f15\", \"#e66101\"))(nrow( IBO_data)),\r\n                fill = \"transparent\",\r\n                angle = 45,\r\n                hjust = 0.1,\r\n                vjust = -0.1,\r\n                label.r = unit(4, \"pt\"),\r\n                label.padding = unit(c(1, 5, 1, 5), \"pt\"))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\n(3) Add external images to the plot\r\nNow we are finished with our text manipulation. Most of the time, we will end it here and be happy to go. However, there is one extra thing we can do to make the plot fancier — adding external images to the plot! Of course you can do this manually later (perhaps in PowerPoint), but isn’t it great to complete all the work at once in R? This will streamline the process and make it fully reproducible! So let’s do it!\r\nThe principle of adding images is the use of HTML <img> tag, which has a basic syntax structure <img scr = 'path_to_image'/>. If you are not familiar with HTML, don’t panic. Simply copy and paste the code in the example below and replace the image path with yours (can be a website url or a local directory). The additional height and width attribute in the <img> tag allow for controlling the size of the images.\r\nYou can add images to two places of a figure: axis ticks and plot panel.\r\nAdd images to the axis ticks\r\nTo add images to the axis ticks, you need to specify in scale_x|y_XXX() the tick positions at which the images should be placed on the axis (breaks =), along with the HTML <img> tags as labels (labels =). After that, call element_markdown() to the corresponding theme element (in this example axis.text.x =) in theme(). The images will then be displayed along the axis.\r\n\r\n\r\n# Download the zip file of the logos from my GitHub repository\r\n# The file will be saved in your current directory\r\ndownload.file(url = \"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2021-07-10-post-5-awesome-text-display-with-ggtext/IBO_logos.zip\", destfile = \"./IBO_logos.zip\")\r\n\r\n# Unzip the file\r\nunzip(zipfile = \"./IBO_logos.zip\")\r\n\r\n# HTML <img> tags\r\nIBO_logo <- paste0(\"<img src = './IBO_logos/\", 1990:2020, \".png' height = '15' width = '15' /><br>\", 1990:2020)\r\n\r\n# Add the logos to the x-axis ticks\r\nIBO_plot <- IBO_plot +\r\n  scale_x_continuous(breaks = 1990:2020, labels = IBO_logo) +\r\n  theme(axis.text.x = element_markdown(color = \"black\", size = 7))\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nAdd images to the plot panel\r\nTo add images to the plot panel, simply create a dataframe containing the x and y positions as well as a column containing the HTML <img> tags, and use geom_richtext(aes(label = )) to map the image tags to the plot. The images will then be displayed at the designated positions.\r\n\r\n\r\n# Add the main logo to the upper panel\r\nIBO_logo_df <- data.frame(x = 1992, \r\n                          y = 200,\r\n                          Time_period = \"1990 to 2005\",\r\n                          logo = paste0(\"<img src = './IBO_logos/main.png' width = '100' />\"))\r\n\r\nIBO_plot <- IBO_plot +\r\n  geom_richtext(data = IBO_logo_df, \r\n                aes(x = x, y = y, label = logo), \r\n                colour = \"transparent\")\r\n\r\nIBO_plot\r\n\r\n\r\n\r\n\r\nTo give you a better idea of how the final figure is generated, I have organized the code chunk pieces throughout the post into a full code chunk below. You can simply copy and paste it into your R session, swap your own data and modify the arguments as you wish!\r\n\r\n\r\n# Library\r\nlibrary(tidyverse)\r\nlibrary(rvest)\r\nlibrary(ggtext)\r\nlibrary(extrafont)\r\n\r\n# Import and register the system fonts\r\n# font_import()  # Please run this line to import the fonts; only need to do it once\r\nloadfonts(quiet = T)  # Need to load the system fonts in every R session\r\n\r\n# The IBO website url\r\nIBO_url <- \"https://www.ibo-info.org/en/contest/past-ibos.html\"\r\n\r\n# Read and extract the website contents into a dataframe\r\nIBO_html <- read_html(IBO_url) %>%\r\n  html_elements(\"div.item__content\") %>%\r\n  html_text2()\r\n\r\nYear <- IBO_html %>% str_extract(\"[:digit:]{4}(?=:)\")\r\nCountry <- IBO_html %>% str_extract(\"(?<=,\\\\s)[:alpha:]+[:blank:]*[:alpha:]*\") %>% replace_na(\"Japan\")\r\nStudents <- IBO_html %>% str_extract(\"[:digit:]*(?=\\\\s*students)\")\r\n\r\nIBO_data <- tibble(Year, Country, Students) %>%\r\n  mutate(Year = as.numeric(Year),\r\n         Students = as.numeric(Students)) %>%\r\n  filter(Year %in% 1990:2020) %>%\r\n  mutate(Time_period = ifelse(Year <= 2005, \"1990 to 2005\", \"2006 to 2020\"))\r\n\r\n# Functions for setting breaks and labels for each of the two facet panels\r\nbreaks_fun <- function(x) {\r\n  if (min(x) < 50) {\r\n    seq(0, 200, 50)\r\n  } else {\r\n    seq(150, 300, 50)\r\n  }\r\n}\r\n\r\nlabels_fun <- function(x) {\r\n  if (min(x) < 50) {\r\n    c(\"<span style = 'font-size: 12pt; color: red;'>0<\/span>\", seq(50, 150, 50), \"<span style = 'font-size: 12pt; color: red;'>200<\/span>\")\r\n  } else {\r\n    c(\"<span style = 'font-size: 12pt; color: red;'>150<\/span>\", seq(200, 250, 50), \"<span style = 'font-size: 12pt; color: red;'>300<\/span>\")\r\n  }\r\n}\r\n\r\n# Download the IBO logos\r\ndownload.file(url = \"https://raw.githubusercontent.com/GenChangHSU/ggGallery/master/_posts/2021-07-10-post-5-awesome-text-display-with-ggtext/IBO_logos.zip\", destfile = \"./IBO_logos.zip\")\r\nunzip(zipfile = \"./IBO_logos.zip\")\r\n\r\n# A vector of HTML <img> tags as x-axis tick logos\r\nIBO_logo <- paste0(\"<img src = './IBO_logos/\", 1990:2020, \".png' height = '15' width = '15' /><br>\", 1990:2020)\r\n\r\n# A dataframe for the main logo\r\nIBO_logo_df <- data.frame(x = 1992, \r\n                          y = 200,\r\n                          Time_period = \"1990 to 2005\",\r\n                          logo = paste0(\"<img src = './IBO_logos/main.png' width = '100' />\"))\r\n\r\n# Plot\r\nggplot(IBO_data, aes(x = Year, y = Students)) +\r\n  \r\n  # Country labels\r\n  geom_richtext(aes(label = Country), \r\n                size = 2,\r\n                color = colorRampPalette(c(\"#a50f15\", \"#e66101\"))(nrow( IBO_data)),\r\n                fill = \"transparent\",\r\n                angle = 45,\r\n                hjust = 0.1,\r\n                vjust = -0.1,\r\n                label.r = unit(4, \"pt\"),\r\n                label.padding = unit(c(1, 5, 1, 5), \"pt\")) +\r\n  \r\n  # Main logo in the upper panel\r\n  geom_richtext(data = IBO_logo_df, \r\n                aes(x = x, y = y, label = logo), \r\n                colour = \"transparent\") +\r\n  \r\n  # Points\r\n  geom_point() + \r\n  \r\n  # Lines\r\n  geom_line() + \r\n  \r\n  # Facets\r\n  facet_wrap(~Time_period, scales = \"free\", nrow = 2, strip.position = \"right\") +\r\n  \r\n  # x-axis tick logos\r\n  scale_x_continuous(breaks = 1990:2020, labels = IBO_logo) +\r\n  \r\n  # y-axis tick labels\r\n  scale_y_continuous(expand = c(0, 40),\r\n                     breaks = breaks_fun,\r\n                     labels = labels_fun) +\r\n  \r\n  # Built-in theme\r\n  theme_classic() + \r\n  \r\n  # Specify title, y-axis label, caption, and facet strips using Markdown/HTML/CSS language\r\n  labs(title = \"<span style = 'font-size: 18pt'><i>**I**nternational **B**iology **O**lympiad<i/><\/span><br>Numbers of participants over past three decades\",\r\n       x = \"\", \r\n       y = \"Number of participants<br><span style = 'font-size: 9pt;'>(**Note:** different y-axis scales in the two panels)<\/span>\",\r\n       caption = \"<i><span style = 'font-size: 9pt;'>Data source: https:&#47;&#47;www&#46;ibo-info.org/en/contest/past-ibos.html<\/span><br>Retrieved July, 2021<i/>\") + \r\n  \r\n  theme(# Title\r\n        plot.title = element_textbox_simple(size = 10,\r\n                                            family = \"Century Gothic\",\r\n                                            color = \"#007575\",\r\n                                            fill = \"#e0f2f2\",\r\n                                            halign = 0.5,\r\n                                            lineheight = 1.5,\r\n                                            padding = margin(5, 1, 5, 1), \r\n                                            margin = margin(0, 0, 5, 0)),\r\n        # y-axis label\r\n        axis.title.y = element_textbox_simple(size = 14,\r\n                                              family = \"Arial\",\r\n                                              color = \"#045a8d\",\r\n                                              fill = \"#fff080\",\r\n                                              halign = 0.5,\r\n                                              orientation = \"left-rotated\",\r\n                                              r = unit(5, \"pt\"),\r\n                                              padding = margin(4, 4, 4, 4),\r\n                                              margin = margin(0, 0, 8, 0),\r\n                                              minwidth = unit(2, \"in\"),\r\n                                              maxwidth = unit(5, \"in\")),\r\n        \r\n        # x-axis tick logos\r\n        axis.text.x = element_markdown(color = \"black\", size = 7),\r\n        \r\n        # y-axis tick labels\r\n        axis.text.y = element_markdown(),\r\n        \r\n        # Caption\r\n        plot.caption = element_markdown(size = 8,\r\n                                        family = \"serif\",\r\n                                        color = \"grey50\",\r\n                                        lineheight = 1.5),\r\n        \r\n        # Facet strips\r\n        strip.background = element_blank(),\r\n        strip.text.y = element_textbox_simple(size = 12,\r\n                                              family = \"Comic Sans MS\",\r\n                                              color = \"white\", \r\n                                              fill = \"#810f7c\", \r\n                                              halign = 0.5,\r\n                                              orientation = \"right-rotated\",\r\n                                              r = unit(8, \"pt\"),\r\n                                              padding = margin(1, 1, 1, 1),\r\n                                              margin = margin(3, 3, 3, 3)))\r\n\r\n\r\n\r\nSummary\r\nA quick recap of what we have done throughout the post. First, we modified the plot title, axis labels, axis ticks, caption, and facet strips using two theme() elements element_textbox_simple() and element_markdown(). Second, we added some country labels to the points using the geom layer geom_richtext() and customized the labels a bit. Third, we used element_markdown() to add external images to the x-axis, and geom_richtext() to add another image to the plot panel.\r\nHonestly, I feel that the final figure in this post does not look so satisfying. I tried to show the things you can do with ggtext as many as possible, making the figure kind of “over-texty”. It is just for demonstration purpose though. When working with your own figure, you might want to think a bit about how to better design it. Maybe spend some time exploring the package website to learn more. Also, I highly recommend having a basic understanding of Markdown/HTML/CSS, which will allow you to fully leverage the strength of ggtext!\r\nOh, one last thing forget to say: I was one of the participants in the 2014 IBO in Bali, Indonesia. It’s been seven years. Time flies! In fact, this is one of the main reasons why I chose IBO data as the example dataset. The other is that the website has many logos, which serves well the purpose of this post.\r\nThat’s it for this post and don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-07-10-post-5-awesome-text-display-with-ggtext/../../homepage_images/Post5.png",
    "last_modified": "2021-08-27T03:38:41-04:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "posts/2021-06-26-post-4-consistent-colors-of-the-same-factor-levels-across-figures/",
    "title": "Post #4. Consistent colors of the same factor levels across figures",
    "description": "In this post, I will show you a simple trick to keep the colors of the same factor levels consistent across different ggplot figures.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-06-26",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nThe problem\r\nSuppose that we want to visualize the relationship (i.e., a scatterplot) between engine displacement (displ) and highway miles per gallon (hwy) of cars in the mpg dataset. And for some reason, we would like to create separate figures for each of the three drive train types (drv) rather than having a single figure with three panels (i.e., facets). Also, the data points in the figures will be colored by car type (class).\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Four-wheel drive\r\nplot_drv4 <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"4\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  stat_smooth(method = \"lm\", se = F) + \r\n  lims(x = c(1, 7), y = c(10, 30)) +\r\n  labs(title = \"Four-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Front-wheel drive\r\nplot_drvf <- mpg %>% \r\n  mutate(class = factor(class)) %>%  \r\n  filter(drv == \"f\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(1, 6), y = c(10, 45)) +\r\n  labs(title = \"Front-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Rear wheel drive\r\nplot_drvr <- mpg %>%   \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"r\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  stat_smooth(method = \"lm\", se = F) + \r\n  lims(x = c(3, 7.5), y = c(10, 30)) +\r\n  labs(title = \"Rear-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\nplot_drv4\r\nplot_drvf\r\nplot_drvr\r\n\r\n\r\n\r\n\r\nHave you spotted something weird? Yup, the colors of the levels in class are not consistent across the three figures (e.g., salmon red represents “compact” in the first two figures but “2seater” in the third; “subcompact” has three different colors in the three figures!) This problem arises because some factor levels are shared across (two or all three) figures while the others are missing, and by default ggplot will only color the levels appearing in the data and omit the rest.\r\nThe partial solution\r\nSo how can you fix this problem? Well, there is a workaround: since ggplot by default omits the unused levels, we can ask ggplot not to do so by specifying drop = F in scale_color_XXX():\r\n\r\n\r\n# Four-wheel drive\r\nplot_drv4_undropped <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"4\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_discrete(drop = F) +  # Not to drop the unused levels\r\n  stat_smooth(method = \"lm\", se = F) + \r\n  lims(x = c(1, 7), y = c(10, 30)) +\r\n  labs(title = \"Four-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Front-wheel drive\r\nplot_drvf_undropped <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"f\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_discrete(drop = F) +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(1, 6), y = c(10, 45)) +\r\n  labs(title = \"Front-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Rear wheel drive\r\nplot_drvr_undropped <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"r\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_discrete(drop = F) +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(3, 7.5), y = c(10, 30)) +\r\n  labs(title = \"Rear-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\nplot_drv4_undropped\r\nplot_drvf_undropped\r\nplot_drvr_undropped\r\n\r\n\r\n\r\n\r\nNow, as you can see, each level in class is associated with a specific color across all three figures. However, another problem comes (I bet you already know what it is): the unused levels are shown in the legends even though they do not appear in the plots (e.g., there is no “2seater” car with four-wheel drive, but “2seater” still shows up in the legend). Depending on the nature of your figure and your purpose, if the legends are not necessary, you can simply hide them while having consistent colors across the figures. But what if you want to keep the legends? Keep reading!\r\nThe ultimate solution\r\nSo what is the ultimate solution to this problem? Three steps:\r\nFirst, create a named vector with colors (can be either hex color codes, color names, or a mixture of them) as the vector elements and factor levels as their names. Note that all levels of the factor across the figures should appear as the vector names, which means the length of the vector should be the same as the number of factor levels. This named vector will be the palette for the next step.\r\nNext, use scale_color_manual(values = name_of_palette) to manually set the colors of the factor levels based on the palette.\r\nFinally, identify the subset of factor levels appearing in the data you are using for that specific figure and specify them using the argument limits = in scale_color_manual().\r\nOkay, to see is to believe. Here is a demo:\r\n\r\n\r\nlibrary(RColorBrewer)\r\n\r\n# Create a named vector as the palette\r\nclass <- unique(mpg$class)  # All factor levels across figures\r\ncolors <- brewer.pal(length(class), \"Set1\")  # Colors\r\nmy_palette <- set_names(colors, class)  # Named vector\r\n\r\n# Four-wheel drive\r\nclass_drv4 <- mpg %>%\r\n  filter(drv == \"4\") %>% \r\n  .$class %>%\r\n  unique()  # Subset of levels in \"class\" for four-wheel drive cars\r\n\r\nplot_drv4_manual <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"4\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_manual(values = my_palette, limits = class_drv4) +  # Manually set the colors of the factor levels based on the palette and also specify the levels present in the data \r\n  stat_smooth(method = \"lm\", se = F) + \r\n  lims(x = c(1, 7), y = c(10, 30)) +\r\n  labs(title = \"Four-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Front-wheel drive\r\nclass_drvf <- mpg %>% \r\n  filter(drv == \"f\") %>% \r\n  .$class %>%\r\n  unique()\r\n  \r\nplot_drvf_manual <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"f\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_manual(values = my_palette, limits = class_drvf) +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(1, 6), y = c(10, 45)) +\r\n  labs(title = \"Front-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\n# Rear wheel drive\r\nclass_drvr <- mpg %>% \r\n  filter(drv == \"r\") %>% \r\n  .$class %>%\r\n  unique()\r\n\r\nplot_drvr_manual <- mpg %>% \r\n  mutate(class = factor(class)) %>%\r\n  filter(drv == \"r\") %>%\r\n  ggplot(aes(x = displ, y = hwy)) + \r\n  geom_point(aes(color = class)) + \r\n  scale_color_manual(values = my_palette, limits = class_drvr) +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  lims(x = c(3, 7.5), y = c(10, 30)) +\r\n  labs(title = \"Rear-wheel drive\") +\r\n  theme_classic() + \r\n  theme(plot.title = element_text(size = 12, hjust = 0.5), \r\n        legend.title.align = 0.5)\r\n\r\nplot_drv4_manual\r\nplot_drvf_manual\r\nplot_drvr_manual\r\n\r\n\r\n\r\n\r\nNow, not only are the colors of the factor levels consistent across the figures, but also the legends are properly displaying the levels appearing in the plots. Problem solved!\r\nAn advantage of this approach is that it offers great flexibility for users to select the colors they would like for each factor level. Of course, you have to spend a bit of time creating the palette yourself instead of just lazily asking ggplot to automatically color the levels for you. But think in the other way round: you get 100% control of the colors! Doesn’t that sound good?\r\nLast but not least, in this example I used the built-in color palette “Set1” from the package RColorBrewer, which provides different types of palettes coming in a variety of colors. And if you want to build your own palette from scratch, definitely check out the website ColorBrewer. There are tons of options to customize the colors to your heart’s content.\r\nThat’s it for this post and don’t forget to leave your comments and suggestions below if you have any. Also, do let me know if you find another (perhaps even simpler) way to do the same job!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-06-26-post-4-consistent-colors-of-the-same-factor-levels-across-figures/../../homepage_images/Post4.png",
    "last_modified": "2021-09-13T03:33:40-04:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-06-18-post-3-pie-charts-with-ggplot/",
    "title": "Post #3. Pie charts with ggplot",
    "description": "Want to know how to create effective pie charts with ggplot? Dig in to learn more!",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-06-18",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nBackground\r\nPie charts are arguably one of the most fundamental graphs in the world. They are primarily used for presenting categorical variables with numerical values (values that can be converted to proportions). These charts are so simple and straightforward that almost everyone can grasp the information at first glance without thinking, thus quite useful for data exploration and communication (yet some have argued not to use them, especially in scientific publications. See this article for more details). That said, an ill-designed pie chart could still ruin your good data. So in this “cook” post, we will be looking at some ways to enhance your pie chart and make it more “attractive” and “effective”!\r\nBasic pie charts with ggplot\r\nTo create a pie chart with ggplot, simply make a stacked barplot and add the function coord_polar(theta = \"y\"):\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Data preparation: cars with different numbers of cylinders\r\nn_cyl <- mtcars %>%\r\n  group_by(cyl) %>%\r\n  summarise(N = n()) %>%\r\n  mutate(cyl = as.factor(cyl))\r\n\r\n# Basic pie chart  \r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  coord_polar(theta = \"y\")\r\n\r\n\r\n\r\n\r\nYou can also change the direction in which the categories/levels are ordered by specifying direction = -1 in coord_polar():\r\n\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  coord_polar(theta = \"y\", direction = -1)  # Counter-clockwise\r\n\r\n\r\n\r\n\r\nSo what does theta = \"y\" do? Basically, this argument tells ggplot to map the y-axis to a polar coordinate system. The stacks in the barplot are bent into a circle, with the arc length of each slice proportional to the original heights of the stacks. Remember, pie charts are just circular stacked barplots!\r\nMore tweaks\r\nRecipe 1: clean up the pie\r\nThe above pie chart does not look satisfying. The axis tick marks and labels, grid lines, and the grey background are kind of extra, so let’s remove them. We will also add a title to the plot.\r\n\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  coord_polar(theta = \"y\", direction = -1) +\r\n  scale_fill_discrete(name = NULL) +  # Remove legend title\r\n  labs(title = \"Number of Cylinders\") +  # Add plot title\r\n  theme_void() +  # Empty theme\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n\r\n\r\n\r\nRecipe 2: label the pie\r\nSometimes you may want to directly label the slices rather than having a separate legend. Here is a trick: change the y axis tick labels to the names of the slices. We will compute the midpoints of the arcs (which are the positions at which the tick labels will be placed) and specify the label names in scale_y_continuous().\r\nBy the way, because the last factor level (in this example “cyl 8”) is at the bottom of the barplot and will go first in the pie chart, we need to reverse the order of the factor levels in our original dataframe to match the order of the stacks (slices) in the plot.\r\n\r\n\r\n# Compute the midpoints of the arcs\r\nlabel_pos <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%  # Reverse the order of the factor levels\r\n  mutate(pos = cumsum(N) - N/2)\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = label_pos$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) +  # Add some white space to the labels to prevent overlapping \r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12))\r\n\r\n\r\n\r\n\r\nRecipe 3: annotate the pie\r\nAdditionally, you might want to annotate the slices, say for example, the proportions. We will create a new dataframe and use geom_text() to map the labels to the slices. The x positions are just an arbitrary “x” (same as the one in geom_bar()); the y positions are the midpoints of the arcs.\r\n\r\n\r\n# A dataframe for mapping the labels to the slices\r\nlabel_pos2 <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%\r\n  mutate(pos = cumsum(N) - N/2,\r\n         prop = paste(100*round(N/sum(N), 2), \"%\"))\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  geom_text(data = label_pos2, aes(x = \"x\", y = pos, label = prop)) +\r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = label_pos2$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) + \r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders \\n (n = 32)\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12)) \r\n\r\n\r\n\r\n\r\nAn even simpler alternative is to map the labels to the stacks using geom_text() and center-align their vertical positions by specifying the argument position_stack(vjust = 0.5):\r\n\r\n\r\nn_cyl2 <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%\r\n  mutate(pos = cumsum(N) - N/2,\r\n         prop = paste(100*round(N/sum(N), 2), \"%\"))\r\n\r\nggplot(n_cyl2, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\") + \r\n  geom_text(aes(label = prop), position = position_stack(vjust = 0.5)) +  # Center-align the vertical positions of the labels on each stack\r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = n_cyl2$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) + \r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders \\n (n = 32)\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12)) \r\n\r\n\r\n\r\n\r\nLooks way better than the previous ones, doesn’t it?\r\nDifferent varieties of pies\r\nNow that we have already learned how to bake a basic pie, let’s take a look at some other pie varieties:\r\n1. Exploded pie chart:\r\nIn an exploded pie chart, the slices are split apart from each other. You can “cut” the slices by adding thick white borders around them (personally I feel that this is more visually appealing than the original “unexploded” one).\r\n\r\n\r\nlabel_pos2 <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%\r\n  mutate(cumsum = cumsum(N),\r\n         mid = N/2,\r\n         pos = cumsum - mid,\r\n         prop = paste(100*round(N/sum(N), 2), \"%\"))\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\", color = \"white\", size = 5) +  # Add white borders around the slices\r\n  geom_text(data = label_pos2, aes(x = \"x\", y = pos, label = prop)) +\r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = label_pos$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) +\r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders \\n (n = 32)\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12))  \r\n\r\n\r\n\r\n\r\n2. Doughnut chart:\r\nHave you ever seen a pie chart with its center hollowed out? This is called a “Doughnut chart” (yes, from a “pie” to a “doughnut”)! There is no direct function or argument to create a doughnut chart in ggplot, and so we will use a small trick here: add an arbitrary “empty” level to the x-axis before the one we have. This works because there is nothing to be bent into a circle for that empty level, thus leaving a white area and forming a hollow there. We can use scale_x_discrete(limits = c(\"x_empty\", \"x\")) to add an arbitrary level “x_empty” to the x-axis.\r\n\r\n\r\nlabel_pos <- n_cyl %>%\r\n  arrange(desc(cyl)) %>%\r\n  mutate(cumsum = cumsum(N),\r\n         mid = N/2,\r\n         pos = cumsum - mid)\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\", width = 0.7) +\r\n  scale_x_discrete(limits = c(\"x_empty\", \"x\")) +\r\n  coord_polar(theta = \"y\", direction = -1, clip = \"off\") +\r\n  scale_y_continuous(breaks = label_pos$pos, labels = c(\"Eight     \", \"Six\", \"    Four\")) + \r\n  scale_fill_discrete(name = NULL, guide = F) +  \r\n  labs(title = \"Number of Cylinders\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15),\r\n        axis.text.x = element_text(size = 12))\r\n\r\n\r\n\r\n\r\nNotes:\r\nIn this example, I call the empty level “x_empty”. You can use whatever name you want; just make sure it is not the same as your original one.\r\nThe empty level should be added BEFORE the original level (limits = c(\"x_empty\", \"x\")), not after (limits = c(\"x\", \"x_empty\")). Otherwise, the white area will be left outside the pie instead of inside it.\r\nThe “thickness” of the doughnut can be controlled by the argument width = in geom_bar().\r\n3. Bull’s eye chart:\r\nWhat happens if you call theta = \"x\" instead of theta = \"y\" in coord_polar()? This will give you a chart with concentric circles, also known as “Bull’s eye chart”. Be careful though, this kind of chart could be a bit misleading, as the areas of the circles/rings are not proportional to the original values.\r\n\r\n\r\nggplot(n_cyl, aes(x = \"x\", y = N, fill = cyl)) +\r\n  geom_bar(stat = \"identity\", position = \"stack\", width = 1) + \r\n  coord_polar(theta = \"x\", direction = -1, clip = \"off\") +\r\n  scale_fill_discrete(name = NULL) +  \r\n  labs(title = \"Number of Cylinders\") + \r\n  theme_void() +\r\n  theme(plot.title = element_text(hjust = 0.5, size = 15))\r\n\r\n\r\n\r\n\r\nSummary\r\nAt this point, you should have got the hang of creating pie charts with ggplot. As you can see, this type of graph is best for visualizing categorical variables with numerical values. However, it becomes less effective when there are too many categories (slices). In general, the number of categories should be less than 7 to achieve a better visual effect (though it really depends on the nature of your data). Also, when you are comparing the slices across multiple pies, it can sometimes be visually deceptive since the angle of the slice represents the “proportion” rather than the original “absolute value”. In these cases, a regular barplot or a boxplot would be a better alternative.\r\nHope you learn something and will be able to make a “tasty” pie chart yourself. And as always, don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-06-18-post-3-pie-charts-with-ggplot/../../homepage_images/Post3.png",
    "last_modified": "2021-08-27T03:38:41-04:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-05-26-guest-post-1-communicating-the-essence-of-your-data/",
    "title": "Guest Post #1. Communicating the ESSENCE of your data",
    "description": "Visualizing multi-dimensional and dynamic data can be challenging. In this post, I will show how you can better communicate these features with interactive plots and animations.",
    "author": [
      {
        "name": "William Ou",
        "url": {}
      }
    ],
    "date": "2021-05-26",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nFrom the host: Here comes the first guest post by William Ou! In this post, he will show you how to “attractively” visualize the data using interactive plots and animations. This is a rather long post, but fear not, I promise you will find it interesting, and most importantly, your data visualization skills will LEVEL UP!\r\nThe challenge\r\nArguably the biggest challenge in data visualization is the fact that we live in a multi-dimensional and dynamic 1 world. Our 3D perception of the universe is an obvious case in support of the multi-dimensions part (all we need is more than 1-dimension!). You might argue that some things are in fact static though. But! If you look closely enough, everything in the physical world is dynamic, constantly moving and fluctuating in space and time. The screen on your computer may look “static” but it’s actually constantly emitting light. Even the wall in your room is made up of particles that are constantly moving. Yet, despite the ubiquity of multi-dimensionality and dynamical behaviors, a large amount of the information we acquire today comes in the standard 2D and static format: the book or Wikipedia page you’re reading, you’re Facebook feed, magazines etc.. Although there are ways of representing dynamic and multi-dimension features in 2D static mediums, doing so often distorts the original information and can hinder the “essence” of the message that one wishes to convey. In many cases, deciphering distorted information requires practice and prior knowledge which renders the information accessible to only a few selected individuals. To demonstrate my point, consider the 2 ways of visualizing the Palmer Penguins dataset below:\r\nApproach 1: Dimension reduction (PCA)\r\n\r\n\r\n\r\nApproach 2: 3D interactive plots\r\n\r\n\r\n\r\nIf you’ve learned PCA before, you might have no problem interpreting Approach 1. But if you haven’t, you might be wondering: What the **** is a PC1/PC2? What are the units of the axes? Why are there arrows pointing at different directions? What does a single point even represent? Most importantly, where did my penguins go!? Because the focus of this post is not about statistics, I won’t go into the details of explaining what a PCA is. What I do want to point out though, is how we can visualize data in a more accessible manner.\r\nNow, Approach 2 may also look like a handful. However, if you take a deep breath and carefully examine the plot, anyone would be able to interpret it, even without any background (assuming that they can read English, of course)! Upon closer inspection, you’ll see that each point in the figure is made up of 4 variables: 1. Bill length (mm), 2. Bill depth (mm), 3. Flipper length (mm), and 4. Body size (g). All these variables characterize an individual penguin (a penguin is multi-dimensional!). The 4 variables are represented by 3 axes and a color gradient. The reason why we do not have a 4th axis is because our brain is not programmed to think that way, so the 4th variable is represented as a color gradient instead. An important thing to note is that, these points on the plot show exactly what the data says. Nothing is distorted and its as raw as it can be. One cool feature of this plot is that it is interactive. Although our screen is 2D, we can get a better “feel” of the dimensionality by rotating the axes around. Rotating works by dragging the plot around with your cursor. By doing so, we’ll see that at certain angles, the points look like a big “cloud” while at other angles you can see a clear separation between clusters of points. Try playing around with the plot, explore its features, and see if you can find other ways of visualizing your data.\r\nDynamic variables\r\nNow let’s take a look at some ways to visualize dynamic variables, variables that change over time. Gapminder is a foundation founded by Hans Rosling that aims to highlight common misconceptions about global trends with data. The gapminder package in R provides a subset of its dataset. Let’s look at how life expectancy and GDP of each country changes over time (year).\r\nApproach 1: Static representation with arrows\r\n\r\n\r\n\r\nApproach 2: Animate to reveal each time step sequentially\r\n\r\n\r\n\r\nFor the dynamics example, the two figures above are actually identical. The only difference is that the animation shows how the state variable (in this case, life expectancy) develops over time by revealing each data sequentially as time progresses. Animations are particularly helpful for visualizing time-series data with multiple variables because things can get cluttered really fast when lines are drawn to represent the passage of time. Although the animated version also shows a lot of cluttering towards the end, it doesn’t necessarily impede understanding because the viewer already has a sense of where each point came from.\r\nThe gapminder dataset is the perfect example that demonstrates the power of good data visualization! If you haven’t already, I strongly encourage you to check out the seminal TED talk and this BBC trailer by Hans Rosling, the OG of descriptive and exploratory data analysis.\r\nNow for some coding\r\nLet’s go over some simple examples to see how you can make your own interactive plot with plotly and animation with gganimate. Both of these packages have really good documentation and you can find out more about them on their websites: plotly and gganimate\r\nI. Making your first interactive 3D plot with plotly\r\nWe’ll use the mtcars dataset here as an example. Make sure to have the plotly package installed on your computer.\r\nThe plotly package is built to be compatible with tidyverse with both sharing very similar syntax. Just as ggplot() is to ggplot2, the main engine of plotly plots is the function plot_ly(). Again, very similar to ggplot2, we supply the plot_ly() function with our data frame and the variables we would like to plot.\r\nWe’ll start by loading the package(s) first, and tweak the dataset a little bit prior to plotting. Here, we will treat # of cylinders as a factor instead of a integer value for visualization purposes.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(plotly)\r\n\r\nmtcars_new <-  mtcars %>%\r\n  mutate(cyl = as.factor(cyl))\r\n\r\n\r\n\r\nAgain, very similar to ggplot(), we supply the plot_ly() function with the data that we want to plot and specify the axes which would be x, y, and z since we have a 3rd dimension. Note the small differences in how the variables are defined here. In plot_ly() the variables are defined with the “~” (tilde), which is like what you would normally do when defining a linear model (e.g. lm(y ~ x1 + x2)). In addition, we’ll also specify a 4th variable/dimension as the color of the points.\r\n\r\n\r\nmt_plotly <- plot_ly(data = mtcars_new, x = ~wt, y = ~hp, z = ~qsec,\r\n        color = ~cyl)\r\nmt_plotly\r\n\r\n\r\n\r\n\r\nAnd there you have it! Pretty straightforward, right? But if you’re picky, you might not be satisfied with this and want to tweak it some more. So let’s try to edit the axis labels, since they’re all abbreviated and have no units. Through the following code, you’ll start seeing more tidyverse/ggplot2 style elements of the plot_ly syntax, see if you can spot them!\r\n\r\n\r\nmt_plotly %>%\r\n    layout(title = 'Motor Trend Car Road Tests',\r\n         scene = list(xaxis = list(title = 'Weight (1000lbs)'),\r\n                      yaxis = list(title = 'Horsepower (hp)'),\r\n                      zaxis = list(title = 'Quarter mile time (s)')),\r\n         annotations = list( # This section is hard-coded \r\n           x = 1.13,\r\n           y = 1.05,\r\n           text = '# of Cylcinders',\r\n           showarrow = FALSE))\r\n\r\n\r\n\r\n\r\nYes, plot_ly functions are pipeable! The piping here is analogous to “+” in ggplot2 syntax. The layout() is also much like the theme() in ggplot2. I will admit though, plot_ly takes time to get used to. The arguments that functions take are sometimes not as straightforward, for example, when does it need to be a list() and when does it not? Moreover, the legend title for the color scheme is hard-coded because there is no argument for specifying legend titles at the moment (at least to my knowledge).\r\nSo, in summary, I think plot_ly offers a neat way of visualizing complex data. The interactive aspect can also help make data more accessible and can be a handy pedagogical tool. However, if you’re trying to make a figure to publish in a scientific journal, this is probably an overkill.\r\nII. Making your first animation with gganimate\r\nBecause gganimate is a part of the tidverse/ggplot2 ecosystem, it should be very straightforward if you are already with familiar with either of them. The general schema of making an animation with gganimate is to:\r\nCreate a ggplot object with ALL your points plotted out.\r\nDecide how you would like the points to be animated by specifying how you would like the data to be shown over time. In the case of time-series, the “time” variable will be the index of your animation.\r\nChoose an appropriate transition function from gganimate, input your index variable (e.g. time), and simply overlay (“+”) this call to your ggplot object just as you would with adding geom_point(), geom_line(), theme()\r\nTHAT’S IT!\r\nAs you can imagine, animations take a little time to render. So for the sake brevity, I’ll use only a subset of the gapminder dataset.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(gganimate)\r\nlibrary(gapminder)\r\n\r\n# Subset the countries in Asia\r\ngapminder_asia <- gapminder %>%\r\n  filter(continent == 'Asia')\r\n\r\n\r\n\r\n\r\nLet’s “gg”plot it out:\r\n\r\n\r\nasia_p <- gapminder_asia %>%\r\n  ggplot(aes(x = year, y = pop, group = country)) +\r\n  geom_point() +\r\n  geom_path() +\r\n  geom_text(aes(label = country), hjust = -0.3, size = 2.5) +\r\n  scale_y_log10() +\r\n  xlim(1950, 2030) +\r\n  theme_bw()\r\n\r\nasia_p\r\n\r\n\r\n\r\n\r\nThis looks horrible, doesn’t it? But this is what I meant by “plot it all out”. This will become clearer through the animation process though, since the points and texts of each country will only appear once at each time point. Because the line specified by geom_path is continuous (only 1 line per group), it will only “grow” as time progresses. In other words, each country will only have a single line, a single point, and a single text throughout the animation.\r\nTo make the plot an animation, simply choose an appropriate transition function from the gganimate package and add it to your ggplot. But what the heck is a transition function? Transition functions are the functions the allow you to specify how you want your plot to be animated. In most cases, all you need to provide to the function is the variable from your dataframe in which you want the animations to be indexed. For example, if we want the animations to progress over time, then we want the time-indexed variable to be our argument. Here, we’ll use the transition_reveal() function as our transition function since we are trying to visualize the temporal evolution of population size.\r\n\r\n\r\nasia_p + transition_reveal(year)\r\n\r\n\r\n\r\n\r\nAs its name suggests, transition_reveal() works by gradually “revealing” your data. The video/gif you see is really just a combination of multiple frames, and each frame consists of only data from a given year. The order of appearance is dependent on the order of your index variable (in our case, year). In some cases, it might not be time that you want to animate and a continuous animation might not be the “essence” that you want your plot to communicate. Finding the correct transition function ultimately depends on the message that you want to convey.\r\nSummary\r\nI started off by suggesting to you that 2D static plots can sometimes limit our ability to communicate the story of our data. This is because our world is multi-dimensional and dynamic! I then showed you that we can overcome some of these limitations by creating I. Interactive plots that allow you to rotate axes, thereby giving the perception of “depth”, and II. Animations that captures the “passage of time”.\r\nThrough this post, I hope I, at least slightly, highlighted the pedagogical implications of making intuitive and accessible data through thoughtful visualizations. So there you have it! May you live long and prosper 🖖\r\nWilliam Ou is an ecologist broadly interested in complexity science, eco-evolutionary dynamics, and more recently, cognitive psychology. When not sciencing, he enjoys biking around the city, eating ice cream, making generative art with ggplot, and watching netflix. Check out his website to learn more!\r\n\r\nI refer to dynamic here as a term that indicates change over time, recognizing that time is sometimes interpreted as another dimension↩︎\r\n",
    "preview": "posts/2021-05-26-guest-post-1-communicating-the-essence-of-your-data/../../homepage_images/Guest_post1.gif",
    "last_modified": "2021-08-27T03:38:41-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-05-07-post-2-three-ways-to-create-log-axes-in-ggplots-which-one-should-you-use/",
    "title": "Post #2. Three ways to create log axes in ggplots: which one should you use?",
    "description": "This post shows you three different ways to create log axes in ggplots and provides some suggestions on which method to use for your figures.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-05-07",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nWe often have data spanning across several orders of magnitude or\r\nhaving skewed distributions. In either case, we might consider\r\ntransforming our data, and log transformation is one of the most common\r\ndata transformation techniques people use.\r\nIn ggplots, there are three different methods to do log\r\ntransformation: (1)\r\nTransformation of variables  (2)\r\nTransformation of scales  (3)\r\nTransformation of coordinates\r\nYou can take a look at a brief demonstration of the three methods on\r\nthis ggplot2\r\nwebsite. These methods share something in common, but also differ\r\nfrom each other in some ways, and I often find it confusing to use them\r\n(I think you might feel the same way as I do!)\r\nIn this post, I will go over these methods one by one, explain the\r\ndetails, and make a comprehensive comparison. Hopefully, after reading\r\nthe article, you will clear up the confusions and know how which method\r\nto go for your figures!\r\nBy the way, we will be working with the famous diamonds\r\ndataset in ggplot2, which contains the price and various attributes of\r\naround 54,000 diamonds.\r\nSay we would like to see how the price of diamonds is related to the\r\nweight (carat) of diamonds. Let’s first make a scatterplot to visualize\r\ntheir relationship:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nIt looks a bit over-plotted, but still you can see a seemingly\r\nnon-linear positive relationship between price and carat. So we decide\r\nto log-transform the data to make the relationship more linear.\r\nMethod 1. Transformation\r\nof variables\r\nThe first method is transformation of variables. This is done by\r\napplying log() directly to the x and/or y variables in the\r\naes():\r\n\r\n\r\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\r\n  geom_point() +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nAs you can see, the relationship does become more linear. This method\r\nsimply log-transforms the x and y variables and plot them as is, and so\r\nnow the axis ticks display the transformed rather than the original\r\nvalues.\r\nIf we fit a line through the points using stat_smooth(),\r\nwe are essentially fitting a linear model with log-transformed carat and\r\nprice as the predictor and the response:\r\n\r\n\r\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\r\n  geom_point() +\r\n  stat_smooth(method = \"lm\", se = F) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nJust that simple and easy! Though, a minor drawback of this method is\r\nthat, since the axes now represent the transformed values, the\r\ninterpretation might become a bit not so straightforward (e.g., what is\r\na diamond of -0.4 log10(carat), or a diamond with a\r\nlog10(price) of around 3.5?!)\r\nMethod 2. Transformation of\r\nscales\r\nThe second method is transformation of scales. This is done by\r\nspecifying the trans = argument in the\r\nscale_XXX_continuous() function:\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  scale_x_continuous(trans = \"log10\") + \r\n  scale_y_continuous(trans = \"log10\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nLooks pretty similar to the plot we get from the first method right?\r\nBasically, this second method does the same thing as the first one in\r\nthe beginning: log-transforming the data. But then, instead of\r\ndisplaying the transformed vales on the axes like what the first method\r\ndoes, it actually converts them back into the original values. This is\r\nwhy you will find that the tick marks are equally-spaced yet their\r\ncorresponding numbers are not equally-distanced.\r\nAgain, we fit a line using stat_smooth():\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  scale_x_continuous(trans = \"log10\") + \r\n  scale_y_continuous(trans = \"log10\") +\r\n  stat_smooth(method = \"lm\", se = F) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nIt is important to note that the line is fitted after the log\r\ntransformation of data. In other words, the line is fitted using the\r\nlog-transformed carat and price as the predictor and the response (i.e.,\r\nlog10(price) ~ log10(carat), not price~carat !!!).\r\nSo in the plot, a price of around $3,000 for a 1.0 carat diamond\r\nactually represents the back-converted predicted log10-price\r\nfor that diamond.\r\nIn fact, any statistical computations (e.g., fitted line, mean,\r\nmedian, error bars) applied to the data will always occur\r\nAFTER the transformation of scales. That is, the\r\nstatistics will be computed on the log-transformed data!\r\nMethod 3.\r\nTransformation of coordinates\r\nThe third method is transformation of coordinates. This is done by\r\nspecifying the transformation for the x and/or y axis in\r\ncoord_trans():\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  coord_trans(x = \"log10\", y = \"log10\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nYou can see that the axes display original values, same as what we\r\nhave seen in the second method. But it is pretty obvious that the tick\r\nmarks are not equally-spaced, different from the second method (take a\r\nquick look back at the previous plot!).\r\nIndeed, what this third method does is that it converts the original\r\nlinear axes into log axes and shifts the original tick marks (which are\r\nequally-spaced with equally-distanced numbers) to the new corresponding\r\nlog positions (which of course will not be equally-spaced but the\r\ncorresponding numbers are still the same). As a result, the numbers on\r\nthe tick marks are equally-distanced yet the tick marks themselves are\r\nnot equally-spaced.\r\nNow we call stat_smooth() to fit a line:\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  coord_trans(x = \"log10\", y = \"log10\", ylim = c(min(diamonds$price), NA)) + # Need to specify the lower limit for y-axis!\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\nWhat! The line is not straight?! Yup, it is not straight. Your vision\r\nis fine! So why is that?\r\nThis is because the line is fitted using the original price and carat\r\nrather than the log-transformed data (i.e., price~carat, not\r\nlog10(price) ~ log10(carat) !!!), after which the\r\npredicted price is then log-transformed and drawn on the plot. So after\r\nthe transformation, the line will no longer be straight.\r\nDifferent from the second method, in this third method, any\r\nstatistical computations applied to the data will always occur\r\nBEFORE the transformation of coordinates. That is, the\r\nstatistics will be computed on the original data and then\r\nlog-transformed to be shown on the plot!\r\nNote that here I also specify the lower limit (using min price value)\r\nfor y-axis. Without this, you will get an error message saying something\r\nlike “missing value where TRUE/FALSE needed”. The line is fitted using\r\nthe original carat and price as the predictor and the response, and in\r\nthis example we have some non-positive predicted values. These\r\nnon-positive values are the culprit: the error arises when ggplot\r\nattempts to take log of them (remember the computed statistics will be\r\nlog-transformed to be drawn on the plot)!\r\n\r\n\r\nlm_diamonds <- lm(price~carat, data = diamonds)\r\npredict(lm_diamonds) %>% head() # Non-positive predicted values exist\r\n\r\n          1           2           3           4           5 \r\n-472.382688 -627.511200 -472.382688   -6.997151  148.131362 \r\n          6 \r\n-394.818432 \r\n\r\npredict(lm_diamonds) %>% log10() %>% head() # NaNs produced when you take log of the non-positive values \r\n\r\n       1        2        3        4        5        6 \r\n     NaN      NaN      NaN      NaN 2.170647      NaN \r\n\r\nFor the second method (transformation of scales), in which the line\r\nis fitted and drawn after log transformation, there is no such problem\r\nbecause the predicted values (of course can be non-positive) do not need\r\nto undergo transformation again, and so you will always get a straight\r\nline!\r\nWhich transformation method\r\nto use?\r\nStill confused? In the following table, I summarize the\r\nsimilarities/differences among the three log transformation methods we\r\nhave discussed:\r\n\r\n\r\n\r\n\r\nTransformation of variables\r\n\r\n\r\nTransformation of scales\r\n\r\n\r\nTransformation of coordinates\r\n\r\n\r\nAxis values\r\n\r\n\r\nTransformed\r\n\r\n\r\nOriginal\r\n\r\n\r\nOriginal\r\n\r\n\r\nAxis tick marks\r\n\r\n\r\nEqually-spaced\r\n\r\n\r\nEqually-spaced\r\n\r\n\r\nNot equally-spaced\r\n\r\n\r\nNumbers on tick marks\r\n\r\n\r\nEqually-distanced\r\n\r\n\r\nNot equally-distanced\r\n\r\n\r\nEqually-distanced\r\n\r\n\r\nStatistical computations\r\n\r\n\r\nAfter transformation\r\n\r\n\r\nAfter transformation\r\n\r\n\r\nBefore transformation\r\n\r\n\r\nShape of geoms\r\n\r\n\r\nNot affected\r\n\r\n\r\nNot affected\r\n\r\n\r\nMight be affected*\r\n\r\n\r\n*E.g., the fitted\r\nstraight line becomes curved.\r\n And here is a simple dichotomous key to which method to use for\r\nyour figures (of course it is my opinion, not the standard rule!):\r\nYou are fine\r\nwith log-transformed axis values…………………….. Method\r\n1\r\nYou want your\r\naxis to display original values…………………………………2\r\nYou want to\r\npreserve the shape of geoms and it is okay for the statistics to be\r\ncomputed on the log-transformed data (geom-focused)………Method\r\n2\r\nYou\r\nwant the statistics to be computed on the original data and it is okay\r\nto have the shape of geoms altered (stat-focused)…………………..Method\r\n3\r\nThis is the end of this rather long post. Hooray! Hope it is worth\r\nthe time and you do learn something useful. And as always, don’t forget\r\nto leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-05-07-post-2-three-ways-to-create-log-axes-in-ggplots-which-one-should-you-use/../../homepage_images/Post2.png",
    "last_modified": "2022-10-04T04:45:40-04:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-05-01-post-1-center-long-legend-titles-in-ggplots/",
    "title": "Post #1. Center long legend titles in ggplots",
    "description": "In this post, I will show you a simple quick hack to center long legend titles in ggplots without bothering gtables and grobs.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-05-01",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\nBefore we start\r\n“Blogenesis”! This is the origin of my first ggGallery blog post! Feel excited to write about something in which I am interested. This very first post is a simple one, but I bet it will be pretty handy. Hope you learn something from this post. Most importantly, enjoy the reading!\r\nThe problem\r\nWhen making a ggplot with legend, the legend title is left-aligned by default:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Cyl\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nIf you are happy with it, then fine. But oftentimes, we would like to align the legend title to the center so that the legend looks more balanced. For short titles, this is easy to achieve, just use theme(legend.title.align = 0.5):\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Cyl\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title.align = 0.5) # Align the title to the center\r\n\r\n\r\n\r\n\r\nHowever, for legend titles that are longer than the legend keys and labels, this method does not work:\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title.align = 0.5) # Not work!\r\n\r\n\r\n\r\n\r\nThere is a solution to this problem on stackoverflow. Basically, what it does is to extract the individual elements from the legend grobs, add extra space, and finally piece them back together. This method really delves into the heart of ggplots, but such “brute force” method might require quite a bit of time as well as decent understandings of how ggplot legends is built.\r\nSo isn’t there a simpler and more elegant way to do so?\r\nThe hack\r\nThe answer to this question is a complete no-brainer: Yes! Otherwise, I will not be writing this blog, right?! Here is the hack: just use “negative” left margin around the legend title:\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = -25))) # Negative left margin\r\n\r\n\r\n\r\n\r\nNow the title lies nicely in the center of the legend. Hooray!\r\nThe explanation\r\nSo how does negative margin work? Let’s visualize it by showing the legend box border. By default, there is no margin around the title, which will fit just right within the box border:\r\n\r\n\r\n# Default left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = 0)), \r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Default margin\")\r\n\r\n\r\n\r\n\r\nIf you specify a positive left margin, then there will be extra space added between the title and left box border:\r\n\r\n\r\n# Positive left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = 25)),\r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Positive left margin\")\r\n\r\n\r\n\r\n\r\nBut if you specify a negative margin, then you are asking ggplot to add some “negative” space between the title and left box border, and what that means is that ggplot will “pull” the title toward left beyond the box border:\r\n\r\n\r\n# Negative left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 12) + \r\n  theme(legend.title = element_text(margin = margin(l = -25)),\r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Negative left margin\")\r\n\r\n\r\n\r\n\r\nAnd after removing the box border, you will find that the title just moves to the center of the legend!\r\nFinally, I think you might ask: what negative margin value should I specify? The answer is: it depends! It really depends on the relative length of your title to your legend keys and labels, and so you might need to try out a few different values and see how it goes. Though this might seem a bit tedious, it offers you the most flexibility to place your title at the exact position you desire. It is worth the effort!\r\nDefinitely try this tip out next time. And if you have any further ideas or questions, don’t forget to leave them below!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-05-01-post-1-center-long-legend-titles-in-ggplots/../../homepage_images/Post1.png",
    "last_modified": "2021-08-27T03:38:41-04:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 672
  }
]
