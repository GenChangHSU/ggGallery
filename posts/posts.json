[
  {
    "path": "posts/2021-05-07-post-2-three-ways-to-create-log-axes-in-ggplots-which-one-should-you-use/",
    "title": "Post #2. Three ways to create log axes in ggplots: which one should you use?",
    "description": "This blog shows you three different ways to create log axes in ggplots and provides some suggestions on which method to use for your figures.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-05-07",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\n\r\nd-article a {\r\n    color: #2780e3 !important;\r\n      border-bottom: none !important;\r\n}\r\n\r\nd-article a:hover {\r\n  color: #2780e3 !important;\r\n    border-bottom: 2px solid !important;\r\n}\r\n\r\nd-byline {\r\n  margin-left: -10% !important;\r\n}\r\n\r\nd-title {\r\n  margin-left: -10%;\r\n}\r\n\r\nd-title h1{\r\n  font-size: 45px;\r\n  width: 130%;\r\n}\r\n\r\nd-article {\r\n  margin-left: -10%;\r\n}\r\n\r\np {\r\n  width: 120%;\r\n}\r\n\r\nd-article h2 {\r\n  width: 120%;\r\n}\r\n\r\ndiv.article-footer{\r\n  width: 120%;\r\n}\r\n\r\nd-article div.sourceCode { \r\n  width: 120% !important;\r\n}\r\n\r\nd-article pre { \r\n  width: 120% !important;\r\n}\r\n\r\ndiv.l-body {\r\n  width: 120% !important;\r\n}\r\n\r\nd-article table thead tr {\r\n  height: 60px !important;\r\n  width: 210px !important;\r\n}\r\n\r\nd-article table thead th {\r\n  height: 60px !important;\r\n  font-size: 22px !important;\r\n  width: 210px !important;\r\n}\r\n\r\nd-article table tbody tr td {\r\n  font-size: 21px !important;\r\n  height: 60px !important;\r\n  text-align: center !important;\r\n  width: 210px !important;\r\n}\r\n\r\nWe often have data spanning across several orders of magnitude or having skewed distributions. In either case, we might consider transforming our data, and log transformation is one of the most common data transformation techniques people use.\r\nIn ggplots, there are three different methods to do log transformation: (1) Transformation of variables  (2) Transformation of scales  (3) Transformation of coordinates\r\nYou can take a look at a brief demonstration of the three methods on this ggplot2 website. These methods share something in common, but also differ from each other in some ways, and I often find it confusing to use them (I think you might feel the same way as I do!)\r\nIn this post, I will go over these methods one by one, explain the details, and make a comprehensive comparison. Hopefully, after reading the article, you will clear up the confusions and know how which method to go for your figures!\r\nBy the way, we will be working with the famous diamonds dataset in ggplot2, which contains the price and various attributes of around 54,000 diamonds.\r\nSay we would like to see how the price of diamonds is related to the weight (carat) of diamonds. Let’s first make a scatterplot to visualize their relationship:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nIt looks a bit over-plotted, but still you can see a seemingly non-linear positive relationship between price and carat. So we decide to log-transform the data to make the relationship more linear.\r\nMethod 1. Transformation of variables\r\nThe first method is transformation of variables. This is done by applying log() directly to the x and/or y variables in the aes():\r\n\r\n\r\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\r\n  geom_point() +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nAs you can see, the relationship does become more linear. This method simply log-transforms the x and y variables and plot them as is, and so now the axis ticks display the transformed rather than the original values.\r\nIf we fit a line through the points using stat_smooth(), we are essentially fitting a linear model with log-transformed carat and price as the predictor and the response:\r\n\r\n\r\nggplot(diamonds, aes(x = log10(carat), y = log10(price))) +\r\n  geom_point() +\r\n  stat_smooth(method = \"lm\", se = F) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nJust that simple and easy! Though, a minor drawback of this method is that, since the axes now represent the transformed values, the interpretation might become a bit not so straightforward (e.g., what is a diamond of -0.4 log10(carat), or a diamond with a log10(price) of around 3.5?!)\r\nMethod 2. Transformation of scales\r\nThe second method is transformation of scales. This is done by specifying the trans = argument in the scale_XXX_continuous() function:\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  scale_x_continuous(trans = \"log10\") + \r\n  scale_y_continuous(trans = \"log10\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nLooks pretty similar to the plot we get from the first method right? Basically, this second method does the same thing as the first one in the beginning: log-transforming the data. But then, instead of displaying the transformed vales on the axes like what the first method does, it actually converts them back into the original values. This is why you will find that the tick marks are equally-spaced yet their corresponding numbers are not equally-distanced.\r\nAgain, we fit a line using stat_smooth():\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  scale_x_continuous(trans = \"log10\") + \r\n  scale_y_continuous(trans = \"log10\") +\r\n  stat_smooth(method = \"lm\", se = F) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nIt is important to note that the line is fitted after the log transformation of data. In other words, the line is fitted using the log-transformed carat and price as the predictor and the response (i.e., log10(price) ~ log10(carat), not price~carat !!!). So in the plot, a price of around $3,000 for a 1.0 carat diamond actually represents the back-converted predicted log10-price for that diamond.\r\nIn fact, any statistical computations (e.g., fitted line, mean, median, error bars) applied to the data will always occur AFTER the transformation of scales. That is, the statistics will be computed on the log-transformed data!\r\nMethod 3. Transformation of coordinates\r\nThe third method is transformation of coordinates. This is done by specifying the transformation for the x and/or y axis in coord_trans():\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  coord_trans(x = \"log10\", y = \"log10\") +\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nYou can see that the axes display original values, same as what we have seen in the second method. But it is pretty obvious that the tick marks are not equally-spaced, different from the second method (take a quick look back at the previous plot!).\r\nIndeed, what this third method does is that it converts the original linear axes into log axes and shifts the original tick marks (which are equally-spaced with equally-distanced numbers) to the new corresponding log positions (which of course will not be equally-spaced but the corresponding numbers are still the same). As a result, the numbers on the tick marks are equally-distanced yet the tick marks themselves are not equally-spaced.\r\nNow we call stat_smooth() to fit a line:\r\n\r\n\r\nggplot(diamonds, aes(x = carat, y = price)) +\r\n  geom_point() +\r\n  stat_smooth(method = \"lm\", se = F) +\r\n  coord_trans(x = \"log10\", y = \"log10\", ylim = c(min(diamonds$price), NA)) + # Need to specify the lower limit for y-axis!\r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nWhat! The line is not straight?! Yup, it is not straight. Your vision is fine! So why is that?\r\nThis is because the line is fitted using the original price and carat rather than the log-transformed data (i.e., price~carat, not log10(price) ~ log10(carat) !!!), after which the predicted price is then log-transformed and drawn on the plot. So after the transformation, the line will no longer be straight.\r\nDifferent from the second method, in this third method, any statistical computations applied to the data will always occur BEFORE the transformation of coordinates. That is, the statistics will be computed on the original data and then log-transformed to be shown on the plot!\r\nNote that here I also specify the lower limit (using min price value) for y-axis. Without this, you will get an error message saying something like “missing value where TRUE/FALSE needed”. The line is fitted using the original carat and price as the predictor and the response, and in this example we have some non-positive predicted values. These non-positive values are the culprit: the error arises when ggplot attempts to take log of them (remember the computed statistics will be log-transformed to be drawn on the plot)!\r\n\r\n\r\nlm_diamonds <- lm(price~carat, data = diamonds)\r\npredict(lm_diamonds) %>% head() # Non-positive predicted values exist\r\n\r\n\r\n          1           2           3           4           5 \r\n-472.382688 -627.511200 -472.382688   -6.997151  148.131362 \r\n          6 \r\n-394.818432 \r\n\r\npredict(lm_diamonds) %>% log10() %>% head() # NaNs produced when you take log of the non-positive values \r\n\r\n\r\n       1        2        3        4        5        6 \r\n     NaN      NaN      NaN      NaN 2.170647      NaN \r\n\r\nFor the second method (transformation of scales), in which the line is fitted and drawn after log transformation, there is no such problem because the predicted values (of course can be non-positive) do not need to undergo transformation again, and so you will always get a straight line!\r\nWhich transformation method to use?\r\nStill confused? In the following table, I summarize the similarities/differences among the three log transformation methods we have discussed:\r\n\r\n\r\n\r\n\r\nTransformation of variables\r\n\r\n\r\nTransformation of scales\r\n\r\n\r\nTransformation of coordinates\r\n\r\n\r\nAxis values\r\n\r\n\r\nTransformed\r\n\r\n\r\nOriginal\r\n\r\n\r\nOriginal\r\n\r\n\r\nAxis tick marks\r\n\r\n\r\nEqually-spaced\r\n\r\n\r\nEqually-spaced\r\n\r\n\r\nNot equally-spaced\r\n\r\n\r\nNumbers on tick marks\r\n\r\n\r\nEqually-distanced\r\n\r\n\r\nNot equally-distanced\r\n\r\n\r\nEqually-distanced\r\n\r\n\r\nStatistical computations\r\n\r\n\r\nAfter transformation\r\n\r\n\r\nAfter transformation\r\n\r\n\r\nBefore transformation\r\n\r\n\r\nShape of geoms\r\n\r\n\r\nNot affected\r\n\r\n\r\nNot affected\r\n\r\n\r\nMight be affected*\r\n\r\n\r\n*E.g., the fitted straight line becomes curved.\r\n And here is a simple dichotomous key to which method to use for your figures (of course it is my opinion, not the standard rule!):\r\nYou are fine with log-transformed axis values…………………….. Method 1\r\nYou want your axis to display original values…………………………………2\r\nYou want to preserve the shape of geoms and it is okay for the statistics to be computed on the log-transformed data (geom-focused)………Method 2\r\nYou want the statistics to be computed on the original data and it is okay to have the shape of geoms altered (stat-focused)…………………..Method 3\r\n\r\n\r\nd-article p span#aaa:before { \r\n  content: \"1a. \"; \r\n  display: inline-block;\r\n  margin-left: -2em;\r\n  margin-right: 0.5em;\r\n}\r\n\r\nd-article p span#bbb:before { \r\n  content: \"1b. \"; \r\n  display: inline-block;\r\n  margin-left: -2em;\r\n  margin-right: 0.5em;\r\n}\r\n\r\nd-article p span#ccc:before { \r\n  content: \"2a. \"; \r\n  display: inline-block;\r\n  margin-left: -2em;\r\n  margin-right: 0.5em;\r\n}\r\n\r\nd-article p span#ddd:before { \r\n  content: \"2b. \"; \r\n  display: inline-block;\r\n  margin-left: -2em;\r\n  margin-right: 0.5em;\r\n}\r\n\r\nd-article table.lightable-paper {\r\n  margin-bottom: 0px; \r\n}\r\n\r\nThis is the end of this rather long post. Hooray! Hope it is worth the time and you do learn something useful. And as always, don’t forget to leave your comments and suggestions below if you have any!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-05-07-post-2-three-ways-to-create-log-axes-in-ggplots-which-one-should-you-use/../../homepage_images/Post2.png",
    "last_modified": "2021-05-14T09:26:48-07:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 576
  },
  {
    "path": "posts/2021-05-01-post-1-center-long-legend-titles-in-ggplots/",
    "title": "Post #1. Center long legend titles in ggplots",
    "description": "In this blog, I will show you a simple quick hack to center long legend titles in ggplots without bothering gtables and grobs.",
    "author": [
      {
        "name": "Gen-Chang Hsu",
        "url": {}
      }
    ],
    "date": "2021-05-01",
    "categories": [
      "2021"
    ],
    "contents": "\r\n\r\n\r\nd-article a {\r\n    color: #2780e3 !important;\r\n    border-bottom: none !important;\r\n}\r\n\r\nd-article a:hover {\r\n    color: #2780e3 !important;\r\n    border-bottom: 2px solid !important;\r\n}\r\n\r\nd-byline {\r\n    margin-left: -10% !important;\r\n}\r\n\r\nd-title {\r\n    margin-left: -10%;\r\n}\r\n\r\nd-title h1{\r\n    font-size: 45px;\r\n    width: 130%;\r\n}\r\n\r\nd-article {\r\n    margin-left: -10%;\r\n}\r\n\r\np {\r\n    width: 120%;\r\n}\r\n\r\nd-article h2 {\r\n    width: 120%;\r\n}\r\n\r\ndiv.article-footer{\r\n    width: 120%;\r\n}\r\n\r\nd-article div.sourceCode { \r\n    width: 120% !important;\r\n}\r\n\r\nd-article pre { \r\n    width: 120% !important;\r\n}\r\n\r\ndiv.l-body {\r\n    width: 120% !important;\r\n}\r\n\r\nBefore we start\r\n“Blogenesis”! This is the origin of my first ggGallery blog post! Feel excited to write about something in which I am interested. This very first post is a simple one, but I bet it will be pretty handy. Hope you learn something from this post. Most importantly, enjoy the reading!\r\nThe problem\r\nWhen making a ggplot with legend, the legend title is left-aligned by default:\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Cyl\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13)\r\n\r\n\r\n\r\n\r\nIf you are happy with it, then fine. But oftentimes, we would like to align the legend title to the center so that the legend looks more balanced. For short titles, this is easy to achieve, just use theme(legend.title.align = 0.5):\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Cyl\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title.align = 0.5) # Align the title to the center\r\n\r\n\r\n\r\n\r\nHowever, for legend titles that are longer than the legend keys and labels, this method does not work:\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title.align = 0.5) # Not work!\r\n\r\n\r\n\r\n\r\nThere is a solution to this problem on stackoverflow. Basically, what it does is to extract the individual elements from the legend grobs, add extra space, and finally piece them back together. This method really delves into the heart of ggplots, but such “brute force” method might require quite a bit of time as well as decent understandings of how ggplot legends is built.\r\nSo isn’t there a simpler and more elegant way to do so?\r\nThe hack\r\nThe answer to this question is a complete no-brainer: Yes! Otherwise, I will not be writing this blog, right?! Here is the hack: just use “negative” left margin around the legend title:\r\n\r\n\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = -25))) # Negative left margin\r\n\r\n\r\n\r\n\r\nNow the title lies nicely in the center of the legend. Hooray!\r\nThe explanation\r\nSo how does negative margin work? Let’s visualize it by showing the legend box border. By default, there is no margin around the title, which will fit just right within the box border:\r\n\r\n\r\n# Default left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = 0)), \r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Default margin\")\r\n\r\n\r\n\r\n\r\nIf you specify a positive left margin, then there will be extra space added between the title and left box border:\r\n\r\n\r\n# Positive left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 13) + \r\n  theme(legend.title = element_text(margin = margin(l = 25)),\r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Positive left margin\")\r\n\r\n\r\n\r\n\r\nBut if you specify a negative margin, then you are asking ggplot to add some “negative” space between the title and left box border, and what that means is that ggplot will “pull” the title toward left beyond the box border:\r\n\r\n\r\n# Negative left margin\r\nggplot(mtcars, aes(wt, mpg)) + \r\n  geom_point(aes(colour = factor(cyl))) + \r\n  geom_smooth(aes(colour = factor(cyl)), method = \"lm\", se = F) +\r\n  scale_color_discrete(name = \"Number of cylinders\", \r\n                       label = c(\"Four\", \"Six\", \"Eight\")) + \r\n  theme_classic(base_size = 12) + \r\n  theme(legend.title = element_text(margin = margin(l = -25)),\r\n        legend.background = element_rect(color = \"black\")) +\r\n  labs(title = \"Negative left margin\")\r\n\r\n\r\n\r\n\r\nAnd after removing the box border, you will find that the title just moves to the center of the legend!\r\nFinally, I think you might ask: what negative margin value should I specify? The answer is: it depends! It really depends on the relative length of your title to your legend keys and labels, and so you might need to try out a few different values and see how it goes. Though this might seem a bit tedious, it offers you the most flexibility to place your title at the exact position you desire. It is worth the effort!\r\nDefinitely try this tip out next time. And if you have any further ideas or questions, don’t forget to leave them below!\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-05-01-post-1-center-long-legend-titles-in-ggplots/../../homepage_images/Post1.png",
    "last_modified": "2021-05-07T04:50:28-07:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 672
  }
]
