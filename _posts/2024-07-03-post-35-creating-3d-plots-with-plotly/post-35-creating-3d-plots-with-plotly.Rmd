---
title: "Post #35. Creating 3D plots with plotly and rayshader"
description: |
  Bring your plots to the next dimension with `plotly` and `rayshader`!
author:
  - name: Gen-Chang Hsu
date: 2024-07-03
output:
  distill::distill_article:
    self_contained: false
categories:
  - "2024"
preview: ../../homepage_images/Post35.png
draft: true
---

<!-- Webpage style -->

<style>
d-article a {
  color: #2780e3 !important;
  border-bottom: none !important;
}

d-article a:hover {
  color: #2780e3 !important;
  border-bottom: 2px solid !important;
}

d-byline {
  margin-left: -10% !important;
}

d-title {
  margin-left: -10%;
}

d-title h1{
  font-size: 45px;
  width: 130%;
}

d-article {
  margin-left: -10%;
}

p {
  width: 120%;
}

d-article h2 {
  width: 120%;
}

d-article h3 {
  width: 120%;
  font-size: 28px;
}

div.article-footer{
  width: 120%;
}

d-article div.sourceCode { 
  width: 120% !important;
}

d-article pre { 
  width: 120% !important;
}

div.l-body {
  width: 120% !important;
}

d-article table thead tr {
  height: 60px !important;
  width: 210px !important;
}

d-article table thead th {
  height: 60px !important;
  font-size: 22px !important;
  width: 210px !important;
}

d-article table tbody tr td {
  font-size: 21px !important;
  height: 60px !important;
  text-align: center !important;
  width: 210px !important;
}

div.l-body img {
    margin-right: 20% !important;
}

</style>

<head>
  <base target="_blank">
</head>

```{r setup, include = FALSE}
knitr::opts_chunk$set(message = F, 
                      error = F, 
                      warning = F,
                      fig.align = "center")

```

<!-- Start of the article -->

## Introduction

2D plots with an x- and a y-axis displaying the relationships between two variables are probably the most common type of plots in our everyday life. If we want to incorporate more information into the plots, we can use different appearances (colors, sizes, shapes, etc.) of points and lines (or other graphic elements). But sometimes, plotting the data in a 3D space can be more visually appealing and may even help us gain deeper insights into the data. Although ggplot does not have geoms for 3D plots by the time of this post, there are other R packages that do the job. And in this post, I'm going to introduce two of these packages to you: `plotly` and `rayshader`. They both have cool functions to generate awesome 3D plots. So buckle up and let's get ready to bring our plots to the next dimension!


## 3D plots with `plotly`

The first package we'll be using is [`plotly`](https://plotly.com/r/). This package features interactive plots and contains functions for generating a wide array of figures. Moreover, besides its own plotting functions, `plotly` also provides the function `ggplotly()`, which directly converts ggplots to the corresponding interactive plots. 

Here, we're going to explore the `plotly` functions for creating 3D plots. Specifically, we'll create a 3D scatterplot with fitted lines and a 3D surface plot with contours and a path.

### (1) 3D scatterplot

The syntax for plotly is pretty similar to ggplot: we call the global function `plotly()` to create a plotting canvas (akin to `ggplot()`) and add other graphical elements using the functions `add_XXX()` (akin to `geom_XXX()`).

To create a basic 3D scatterplot, we use the function `add_markers()` (similar to `geom_point()`). Simply pass the x-, y-, and z-coordinates to the function and specify the variable you would like to color the points by.

To add the lines, we use the function `add_path()` (similar to `geom_path()`). Again, simply pass the x-, y-, and z-coordinates to the function and specify the variable you would like to color the line by.

We can modify the the appearance of the axes and legend using the function `layout()` (see [here](https://plotly.com/r/reference/layout/) for a complete list of things you can adjust!).


```{r, fig.width = 10, fig.height = 5, out.width = "80%"}
library(tidyverse)
library(plotly)

### Model predictions
iris_lm_prediction <- iris %>% 
  group_by(Species) %>% 
  summarise(Model = list(lm(Petal.Length ~ Sepal.Length + Sepal.Width))) %>% 
  rowwise() %>% 
  mutate(Newdata = list(data.frame(Sepal.Length = range(Model$model$Sepal.Length),
                                   Sepal.Width = range(Model$model$Sepal.Width)))) %>% 
  mutate(Prediction = list(cbind(Newdata, Prediction = predict(Model, newdata = Newdata)))) %>% 
  dplyr::select(Species, Prediction) %>% 
  unnest(col = Prediction)

### Create a 3D scatterplot with the fitted lines
scatterplot3d <- plot_ly() %>% 
  # add the points
  add_markers(data = iris, 
              x = ~ Sepal.Length, 
              y = ~ Sepal.Width, 
              z = ~ Petal.Length, 
              color = ~ Species, 
              colors = c("#BF382A", "#0C4B8E", "#018571"),
              size = 2) %>% 
  # add the lines
  add_paths(data = iris_lm_prediction,
            x = ~ Sepal.Length, 
            y = ~ Sepal.Width, 
            z = ~ Prediction,
            color = ~ Species,
            colors = c("#BF382A", "#0C4B8E", "#018571"),
            showlegend = F) %>% 
  layout(legend = list(x = 0.9, y = 0.5),
         scene = list(xaxis = list(title = "Sepal length", range = list(4, 8)),
                      yaxis = list(title = "Sepal width", range = list(1, 5)),
                      zaxis = list(title = "Petal length", range = list(1, 7))))

scatterplot3d

```


### (2) 3D surface plot



```{r, fig.width = 10, fig.height = 5, out.width = "80%"}
library(MASS)

### 2D kernel density estimates of the sepal length and width
iris_kd_matrix <- kde2d(iris$Sepal.Length, iris$Sepal.Width, n = 100)[[3]]

### Create a 3d surface plot with contours
### Note that the matrix column (Sepal.Width) will be plotted as the x-axis and the row (Sepal.Length) will be plotted as the y-axis
surfaceplot3d <- plot_ly() %>%
  add_surface(x = seq(min(iris$Sepal.Width), max(iris$Sepal.Width), length.out = 100),
              y = seq(min(iris$Sepal.Length), max(iris$Sepal.Length), length.out = 100),
              z = iris_kd_matrix,
              contours = list(z = list(start = 0, 
                                       end = 0.5, 
                                       size = 0.1,
                                       show = T, 
                                       usecolormap = F))) %>% 
  layout(scene = list(xaxis = list(title = "Sepal width"),
                      yaxis = list(title = "Sepal length"),
                      zaxis = list(title = "Density")))

### Get a random path on the landscape
set.seed(123)

df <- data.frame(x = 1, y = 1)
max_df <- 1
i <- 1

while (max_df < 100) {
  df[i + 1, ] <- df[i, ] + sample(c(0, 1), size = 2, replace = F)
  max_df <- max(df)
  i <- i + 1
}

df_density <- df %>% 
  rowwise() %>% 
  mutate(Density = iris_kd_matrix[x, y]) %>% 
  mutate(Sepal.Length = seq(min(iris$Sepal.Length), max(iris$Sepal.Length), length.out = 100)[x], 
         Sepal.Width = seq(min(iris$Sepal.Width), max(iris$Sepal.Width), length.out = 100)[y])

### Add the path
surfaceplot3d %>% 
  add_paths(data = df_density, x = ~ Sepal.Width, y = ~ Sepal.Length, z = ~ Density, line = list(width = 4))

surfaceplot3d


```




### (3) Layout the plots

saving the plots in high quality





## 3D plots with `rayshader`







## Summary






Hope you learn something useful from this post and don't forget to leave your comments and suggestions below if you have any!






